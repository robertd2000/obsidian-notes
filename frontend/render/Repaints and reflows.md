При загрузке страницы, если она не пустая, всегда выполняется, как минимум, по одному reflow и repaint. Далее эти события возникают в следующих случаях:  
  
1. Часть дерева отображения нуждается в перерасчете, т. е. у какого-то узла изменились ширина, высота или координаты. Вызывается событие reflow.  
  
2. В результате изменений часть отображаемого контента должна обновиться. Речь идет, в первую очередь, о свойствах стилей: цвет фона, радиус и т. д. Вызывается событие repaint.  
  
Если вызывается reflow, после него обязательно вызовется и repaint. Но обратное неверно: repaint может вызываться независимо от reflow.  
  

###### **Какие действия вызывают reflow и/или repaint**

  
**1) Добавление, обновление, удаление DOM-узла.** Потому что при этих событиях нужно перерасчитывать дерево отображения.  
  
Функции:  
insertAdjacentHTML(),appendChild(), insertBefore(), removeChild(),replaceChild(),remove(),append()/prepend(), after()/before(), replaceWith()  
  
Изменение свойств DOM-узла:  
innerHTML,innerText, width, height, offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height  
  
Запрос свойств DOM-узла (без его изменения):  
(offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height  
  
Не только вызов функций и изменение DOM-узлов может вызвать reflow, но и простой запрос некоторых свойств, к которым, в частности, относятся все офсет-свойства. Почему при этом необходима компоновка, я расскажу позже.  
  
**2) Скрытие DOM-узла** с помощью **display: none** (reflow и repaint) или **visibility: hidden** (только repaint, потому что нет геометрических изменений).  
  
**3) Перемещение, анимация DOM-узла.**  
Меняются координаты анимируемого узла дерева отображения, также это может вызывать изменение размеров других узлов.  
  
**4) Добавление/изменение CSS**  
  
left, top,right,bottom,width,height  
Если мы захотим изменить эти css-свойства, это тоже вызовет reflow.  
  
**5) Пользовательские действия: изменение размеров окна (resize), изменение шрифта, прокрутка(scroll), drag and drop.**  
  
**6) Другое**  
  
_— JS Scrolling_: Скроллинг через скрипт и соответствующие ему свойства.  
scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth  
  
_— Глобальные методы и события для объекта window:_  
getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY  
  
_— Работа с SVG_  
  
Пример  
  

```js
var bstyle = document.body.style; // cache
 
bstyle.padding = "20px"; // reflow, repaint
bstyle.border = "10px solid red"; // another reflow and a repaint
 
bstyle.color = "blue"; // repaint only, no dimensions changed
bstyle.backgroundColor = "#fad"; // repaint
 
bstyle.fontSize = "2em"; // reflow, repaint
 
// new DOM element - reflow, repaint
document.body.appendChild(document.createTextNode('dude!'));

```

  
  
На примере этого скрипта мы видим, что, если поменять padding, придется пересчитать размеры прямоугольника. Соответственно, вызовутся reflow и repaint. Если мы поменяем border, то ему задастся новая ширина, поэтому также будут вызваны reflow и repaint. А если бы мы просто поменяли цвет border, фона или текста — вызвался бы только repaint. Меняем размеры шрифта — reflow и repaint.  
  
Браузер компонует вместе несколько запросов на reflow и repaint, и выполняет их единожды, оптимизируя свою работу. Но некоторые действия вынуждают браузер выполнить эти события незамедлительно.  
  
Свойства:  
1. offsetTop, offsetLeft, offsetWidth, offsetHeight  
2. scrollTop/Left/Width/Height  
3. clientTop/Left/Width/Height  
4. getComputedStyle(), or currentStyle in IE  
При запросе этих свойств браузеру нужно выполнить перекомпоновку незамедлительно, т. к. они должны возвращать актуальную информацию. Поэтому всякий раз, когда мы запрашиваем эти свойства, происходят reflow и repaint.  
  

###### **Советы по оптимизации кода для учета repaint и reflow**

  
**I. Не меняйте стили элемента напрямую в коде, используйте css-классы для переключения внешнего вида элемента. Или используйте свойство cssText.**  
  

```js
// bad
var left = 10,
    top = 10;
el.style.left = left + "px";
el.style.top  = top  + "px";
 
// better 
el.className += " theclassname";
 
// or when top and left are calculated dynamically...
 
// better
el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
```

  
  
Способы:  
1. Переключить CSS-класс. Часто внешний вид блока или его состояние можно изменить с помощью класса. Этот вариант лучше, чем работа напрямую со стилями, потому что хоть это все равно вызовет reflow и repaint, но только один раз. Например, в данном случае там, в первом примере, произойдет reflow и repaint при изменении события left, и ещё один reflow и repaint при изменении события top. Но если бы у нас left и top были прописаны в css-свойстве в каком-то классе, то при добавлении этого класса, у нас бы произошел один reflow и repaint вместо двух.  
2. То же самое касается свойства cssText. Если мы заменим в этом тексте все необходимые нам свойства на динамические, то у нас произойдет один reflow и repaint.  
  
**II. Объединяйте манипуляции с DOM и выполняйте их отдельно от обновления DOM:**  
  
Сделать это можно несколькими способами:  
• Используйте documentFragment, который предназначен для оптимизации работы с DOM-узлами.  
• Создайте клон DOM-узла, работайте с ним, а по окончании замените им оригинальный DOM-узел. Это также оптимизирует количество reflow и repaint.  
• Используйте display: none (1 reflow, repaint), внесите 100 изменений, восстановите display (1 reflow, repaint). Это лучше, чем вызывать по одному reflow на каждое изменение из 100.  
  
**III. Не запрашивайте вычисляемые стили слишком часто.** Это вынуждают браузер делать reflow и repaint. Приведем пример, как можно оптимизировать код в этом случае. Если вам нужно работать с ними, возьмите их один раз, закэшируйте в переменной (если есть какой-то определенный цикл, лучше работать с переменной, чем каждый раз брать свойства) и работайте с ней.  
  

```css
// no-no!
for(big; loop; here) {
    el.style.left = el.offsetLeft + 10 + "px";
    el.style.top  = el.offsetTop  + 10 + "px";
}
 
// better
var left = el.offsetLeft,
    top  = el.offsetTop
    esty = el.style;
for(big; loop; here) {
    left += 10;
    top  += 10;
    esty.left = left + "px";
    esty.top  = top  + "px";
}
```

  
  
**IV. Думайте о дереве отображения и пытайтесь понять, как много изменений вы вызываете в нем.**  
На этом моменте я остановлюсь подробнее, потому что компоновка компоновке рознь. И одна компоновка (reflow — если кто забыл) может быть значительно более трудозатратой, чем другая. Рассмотрим такой пример.  
  

```html
<div class="five red">
    <div class="four yellow">
        <div class="three green">
            <div class="two blue">
                <div class="one purple">

                </div>
            </div>
        </div>
    </div>
</div>
```

  
  
![](https://habrastorage.org/r/w1560/files/993/d42/384/993d423849e0486eb3ef6fa2b7be79b6.jpg)  
Здесь представлен небольшой фрагмент html. Допустим, мы захотим вставить какой-нибудь DOM-узел в блок 1.  
  
![](https://habrastorage.org/r/w1560/files/e14/abd/172/e14abd1724cd44b49430f2a2e3d5f347.jpg)  
  
К чему это приведет? Во-первых, блок 1 должен будет перерасчитать свои размеры, потому что неизвестно, каких размеров новый вставляемый DOM-узел. Нужно понять, есть ли необходимость сделать ширину больше или меньше и т. д. Изменение размеров блока 1 вынуждает делать перекомпоновку блока 2. Это вызывает перекомпоновку блоков 3, 4 и 5. Т. е. мы видим, что операция получается трудозатратной. Но все будет иначе, если мы вставим наш DOM-узел, например, после четвертого DOM-узла.  
  
![](https://habrastorage.org/r/w1560/files/f07/4ac/4e4/f074ac4e4a034000aad01c33f01c0c61.jpg)  
  
В этом случае обновится только пятый DOM-узел, и компоновка таким образом получается гораздо более быстрой.  
Еще один наглядный пример — работа с анимацией. Допустим, мы хотим анимировать перемещение блока 1 на 200 пикселей вправо. Если блок 1 имеет position: static, то есть он находится в стандартном потоке компоновки и учитывается другими блоками, то изменение его координат будет производить перекомпоновку всех его предков. Если же блок 1 будет иметь position: absolute, он выйдет из стандартного потока компоновки. В этом случае изменение его координат будет требовать перекомпоновки только отдельных его предков. Допустим, у прямоугольника 5 стоит position: relative, и наш прямоугольник 1 будет компоноваться относительно блока номер 5. Тогда изменение блоком 1 своих координат, будет вызывать компоновку только пятого DOM-узла.