Обычно на интервью важно не просто перечислить проблемы, а сразу говорить «проблема → как решал / как бы решал». Тогда видно системное мышление. Ниже решения именно для промо-игры с WebSocket, лидербордом и авторизацией.

---

## 1. Игровой сервис — приём результатов

### Проблема: читинг / накрутка очков

**Решения:**

- серверная валидация результата (максимальный score за время);
    
- проверка длительности сессии;
    
- лимит очков за секунду;
    
- подпись результата (session token);
    
- rate-limit на пользователя/IP.
    

Главная идея: **клиенту не верим вообще.**

---

### Проблема: дубликаты запросов

**Решения:**

- `session_id` как idempotency key;
    
- уникальный индекс в БД;
    
- Redis SET с TTL для уже обработанных сессий;
    
- Upsert вместо Insert.
    

---

### Проблема: пики нагрузки

**Решения:**

- Kafka / очередь между API и обработкой;
    
- батч-обработка результатов;
    
- autoscaling контейнеров;
    
- ограничение RPS на gateway.
    

---

### Проблема: блокирующие записи в БД

**Решения:**

- сначала Redis → потом Postgres асинхронно;
    
- write-behind;
    
- отдельные воркеры для записи.
    

---

## 2. Leaderboard (Redis)

### Проблема: горячий ключ (один огромный ZSET)

**Решения:**

- шардинг лидерборда:
    
    - по регионам,
        
    - по времени,
        
    - по группам игроков;
        
- хранить только топ-N в Redis, остальное в БД;
    
- батч-обновления очков, не на каждый тик.
    

---

### Проблема: память Redis

**Решения:**

- TTL на старые кампании;
    
- отдельный Redis для лидерборда;
    
- компрессия / хранение только нужных полей;
    
- Redis Cluster.
    

---

### Проблема: CPU Redis

**Решения:**

- ограничение частоты обновлений очков (debounce);
    
- не делать ZADD на каждое движение;
    
- агрегация очков раз в N секунд.
    

---

## 3. WebSocket слой

### Проблема: слишком много соединений

**Решения:**

- горизонтальное масштабирование WebSocket-сервиса;
    
- sticky sessions через LB;
    
- лимиты на соединения с IP;
    
- heartbeat + auto-disconnect.
    

---

### Проблема: утечки соединений

**Решения:**

- ping/pong каждые 20–30 секунд;
    
- таймауты неактивности;
    
- cleanup goroutines.
    

---

### Проблема: broadcast-шторм

**Решения:**

- не пушить каждый апдейт;
    
- обновление топа раз в 1–3 секунды;
    
- диффы вместо полного списка;
    
- комнаты / каналы вместо «всем всё».
    

---

### Проблема: несколько инстансов

**Решения:**

- Redis Pub/Sub или Kafka для синхронизации;
    
- event bus между нодами;
    
- user routing по shard key.
    

---

## 4. Redis как SPOF

### Решения:

- master-replica;
    
- Redis Sentinel / Cluster;
    
- snapshot + AOF;
    
- fallback на Postgres.
    

---

## 5. PostgreSQL

### Проблема: рост таблиц

**Решения:**

- партиционирование по дате;
    
- архивирование старых данных;
    
- отдельная аналитическая БД.
    

---

### Проблема: медленные записи

**Решения:**

- батчи;
    
- минимальное количество индексов;
    
- async workers.
    

---

### Проблема: тяжёлая аналитика

**Решения:**

- ClickHouse / отдельный warehouse;
    
- реплика только для чтения;
    
- materialized views.
    

---

## 6. Авторизация

### Проблемы и решения

- brute-force → rate limit, captcha;
    
- утёкший JWT → короткий TTL + refresh token;
    
- нагрузка → кеш публичных ключей и user data.
    

---

## Короткая формулировка для интервью

Если нужно ужать до 3–4 предложений:

> Основные узкие места были в WebSocket-соединениях, Redis-лидерборде и записи игровых сессий. Решалось горизонтальным масштабированием сервисов, шардингом лидерборда, батч-обработкой результатов и асинхронной записью в БД через очередь. Для WebSocket использовались heartbeat, лимиты соединений и агрегация обновлений, чтобы избежать broadcast-штормов. Redis работал в master-replica конфигурации, а тяжёлая аналитика выносилась из Postgres.

Это звучит как опыт продакшена, а не учебный проект.