
## Дигит пермутэйшен

### Задача

```js
/*
Дан массив целых неотрицательных чисел, нужно сгруппировать друг с другом числа,
которые можно получить путём перестановки цифр их составляющих,
нули при этом игнорируем, т. к. нет числа 011.
Решение должно быть максимально эффективно по памяти и времени.
*/

function digitPermutation(arr) {
  // your code here
}

console.clear();
console.log("start test");
console.log(
  digitPermutation([1230, 99, 23001, 123, 111, 300021, 101010, 90000009, 9])
);
// [[99, 90000009], [111, 101010], [1230, 23001, 123, 300021], [9]]
console.log(digitPermutation([11, 22])); // [[11], [22]]
console.log(digitPermutation([11111111112, 122222222222])); // [[11111111112], [122222222222]]
console.log("end test");
```

### Решение

```js

function digitPermutation(arr) {
  const map = {}

	for (let digit of arr) {
		const key = String(digit).split("")
			.filter(i => i !== "0")
			.sort()
			.join("")

		if (!(key in map)) map[key] = []

		map[key].push(digit)
	}
	
	return Object.values(map)
}

```

### Объяснение

1. Создаем объект, в котором будем группировать числа
2. Проходимся по всем числам и каждое число превращаем в ключ
    - Превращаем в строку
    - Удаляем все нули
    - Превращаем в массив
    - Сортируем цифры по порядку
    - Превращаем обратно в строку
3. Если в объекте еще нет этого ключа, то создаем пустой массив по этому ключу
4. Добавляем число в объект по сформированному ключу
5. Возвращаем все сгруппированные значения объекта в виде массива

## DFS-ка

### Задача

```js
/*
Дана древовидная структура следующего формата:

const tree = {
  type: 'nested',
  children: [
    { type: 'added', value: 42 },
    {
      type: 'nested',
      children: [
        { type: 'added', value: 43 },
      ],
    },
    { type: 'added', value: 44 },
    ...
  ]
}

Необходимо написать функцию `getNodes(tree, type)`, которая возвращает все ноды в порядке следования, соответствующие переданному типу.

Глубина вложенности любая.

Пример:

const addedItems = getNodes(tree, 'added');

// Результат:
[
  { type: 'added', value: 42 },
  { type: 'added', value: 43 },
  { type: 'added', value: 44 },
  ...
]
*/
```

### Решение

```js

function getNodes(tree, type) {
	const stack = [tree]

	const res = []

	while (stack.length) {
		const node = stack.pop()
		if (node.type === type) {
			res.push(node)
		}
		if (node.children) {
			stack.push(...node.children)
		}
	}

	return res.reverse()
}

```

### Объяснение

1. Необходимо обойти дерево в глубину (DFS)
2. Рекурсию использовать нельзя, так как по условию дерево может иметь любую глубину вложенности
3. Используем stack для хранения узлов.
4. Берём последний элемент (pop()), обрабатываем.
5. Если тип совпадает — добавляем в result.
6. Если есть children, добавляем их в stack (push(...children), LIFO).
7. При возвращении result делаем reverse, так как по условию нужно вернуть узлы в порядке следования
8. Обход гарантированно работает для любых деревьев, глубина не влияет.

## Тортилла

### Задача

```js
/**
 * throttle.
 *
 * Напишите функцию throttle(fn, delay, ctx) — «тормозилку», которая возвращает обёртку,
 * вызывающую fn не чаще, чем раз в delay миллисекунд.
 * В качестве контекста исполнения используется ctx.
 * Первый вызов fn всегда должен быть синхронным.
 * Если игнорируемый вызов оказался последним, то он должен выполниться.
 */

// пример для delay === 100
// . - вызовы throttledFn
// ! - вызовы fn
// ...............!
///   !         !
///0ms 100ms   200ms
//  .    .     .
//      !     !
///0ms 100ms 200ms

function throttle(fn, delay, ctx) {
  // code here
}

function test() {
  const start = Date.now();

  function log(text) {
    const msPassed = Date.now() - start;
    console.log(`${msPassed}: ${this.name} logged ${text}`);
  }

  const throttled = throttle(log, 100, { name: "me" });

  setTimeout(() => throttled("m"), 0);
  setTimeout(() => throttled("mo"), 22);
  setTimeout(() => throttled("mos"), 33);
  setTimeout(() => throttled("mosc"), 150);
  setTimeout(() => throttled("moscow"), 400);

  // Ожидаемый вывод:
  //  0ms: me logged m
  // 100ms: me logged mos
  // 200ms: me logged mosc
  // 400ms: me logged moscow
}
```

### Решение

```js

function throttle(fn, delay, ctx) {
	let prevArgs
	let isBlocked
	
	function setTimer() {
		isBlocked = true
	
		setTimeout(() => {
			isBlocked = false
		
			if (prevArgs) {
				fn.apply(ctx, prevArgs)
				prevArgs = null
				isBlocked = true
				setTimer()
			}
		}, delay)
	}
	
	return function(...args) {
		if (isBlocked) {
			prevArgs = args
		} else {
			fn.apply(ctx, args)
			setTimer()
		}
	}
}

```

### Объяснение

1. В lastCallArgs храним последний переданные в функцию аргументы
2. В blocked храним флаг, который указывает, заблокирован ли вызов функции
3. Создаем функцию setTimer, которая блокирует потом и запускает таймер с переданным delay и вызывает fn с переданным lastCallArgs и контекстом
4. Возвращаем функцию, которая либо устанавливает новый lastCallArgs (если поток заблокирован), либо вызывает функцию и ставит таймер