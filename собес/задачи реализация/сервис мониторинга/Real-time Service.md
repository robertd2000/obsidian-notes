# Real-time Service: Мост между данными и пользователями

## Суть и предназначение сервиса

Real-time Service — это **лицо** всей системы мониторинга транспорта. Если все предыдущие сервисы работают "за кулисами", то этот сервис — тот самый "экран", на который смотрят пользователи. Его задача — взять обработанные данные от Processing Service и доставить их пользователям **мгновенно**, с задержкой не более 1-2 секунд.

Представьте себе ситуацию: диспетчер видит на карте, как грузовик въезжает на территорию клиента. В реальной жизни это происходит прямо сейчас, и система должна показывать это **в реальном времени**, а не с задержкой в 5-10 минут. Именно за это и отвечает Real-time Service.

## Архитектура сервиса: как всё устроено внутри

### Многослойная структура

Real-time Service построен по принципу **"получай-обрабатывай-отправляй"**:

```
┌─────────────────────────────────────────────────────────────┐
│                     Real-time Service                        │
├─────────────────────────────────────────────────────────────┤
│  Слой 1: Прием данных       │  Слой 2: Обработка           │
│  • Kafka Consumer           │  • Фильтрация               │
│  • WebSocket Server         │  • Агрегация                │
│  • HTTP/2 Server            │  • Кэширование              │
│                             │  • Приоритизация            │
├─────────────────────────────┼──────────────────────────────┤
│  Слой 3: Хранение состояния │  Слой 4: Отправка            │
│  • In-memory кэш           │  • WebSocket Broadcasting    │
│  • Redis для синхронизации  │  • Server-Sent Events       │
│  • Сессионные данные        │  • HTTP Streaming           │
└─────────────────────────────┴──────────────────────────────┘
```

## Подробно о каждом аспекте работы

### 1. Подключение клиентов: не просто соединение, а целая церемония

Когда пользователь открывает карту в браузере или мобильном приложении, происходит не просто установка соединения, а целый ритуал:

**Шаг 1: Установление WebSocket соединения**
Браузер подключается по защищенному протоколу wss:// (WebSocket over TLS). Сервер принимает соединение и создает для него отдельный "конвейер" обработки.

**Шаг 2: Аутентификация**
Клиент отправляет JWT-токен. Этот токен — как паспорт пользователя. В нем написано:
- Кто этот пользователь (ID, имя, роль)
- Какие у него права (что он может видеть)
- Когда токен истекает

Сервис проверяет подпись токена, его срок действия и извлекает информацию о пользователе.

**Шаг 3: Инициализация сессии**
Создается сессия пользователя. В Redis записывается:
```redis
# Сессионные данные
SET session:client_12345 {
  "user_id": "user_789",
  "role": "dispatcher",
  "permissions": ["view_all_vehicles", "send_commands"],
  "connected_at": "2024-01-15T10:00:00Z",
  "instance_id": "realtime-pod-1"
}

# Подключения пользователя
SADD user:connections:user_789 "client_12345"
```

**Шаг 4: Восстановление состояния**
Если пользователь переподключился (упал интернет, перезагрузил страницу), сервис проверяет:
- Были ли у него активные подписки?
- Какие фильтры он использовал?
- Какая область карты была открыта?

И восстанавливает всё как было.

### 2. Подписка на данные: что именно хочет видеть пользователь

После подключения клиент сообщает, что именно его интересует. Это делается через сообщение подписки:

```json
{
  "type": "subscribe",
  "subscriptions": {
    "vehicles": ["truck_123", "truck_456", "van_789"],
    "groups": ["north_fleet", "refrigerated"],
    "geographic": {
      "bounds": {
        "north": 55.8,
        "south": 55.7,
        "east": 37.7,
        "west": 37.6
      },
      "zoom": 12
    }
  },
  "filters": {
    "status": ["moving", "idle"],
    "vehicle_types": ["truck", "van"],
    "show_alerts": true
  }
}
```

Сервис обрабатывает эту подписку:

**В Redis сохраняется информация о подписках:**
```redis
# Какие клиенты подписаны на конкретную машину
SADD subscribers:vehicle:truck_123 "client_12345"
SADD subscribers:vehicle:truck_456 "client_12345"

# На какие машины подписан конкретный клиент
SADD subscriptions:client:client_12345 "truck_123"
SADD subscriptions:client:client_12345 "truck_456"

# Географические подписки
GEOADD clients:geofilter:55.7:37.6:55.8:37.7 "client_12345"
```

**Важный момент:** Сервис не просто запоминает подписки, он **интеллектуально их обрабатывает**. Например:
- Если пользователь подписался на группу "северный флот", сервис находит все машины в этой группе
- Если указаны географические границы, сервис будет отправлять только машины в этой области
- Фильтры применяются динамически: если машина остановилась, а фильтр говорит "показывать только движущиеся", то обновления по этой машине не отправляются

### 3. Получение данных от Processing Service: постоянный поток обновлений

Real-time Service получает данные двумя способами:

**Способ 1: Потребление из Kafka (основной канал)**
Сервис подписывается на топик `vehicle.updates.enriched` и постоянно получает поток обновлений:

```json
// Сообщение из Kafka
{
  "vehicle_id": "truck_123",
  "timestamp": "2024-01-15T10:30:00.123Z",
  "position": {"lat": 55.7558, "lon": 37.6176},
  "speed": 65.2,
  "status": "moving",
  "driver": {"name": "Иванов И.И.", "phone": "+79161234567"},
  "assignment": {"client": "ООО Ромашка", "eta": "11:15"},
  "alerts": ["overspeed:65/60 км/ч"]
}
```

**Способ 2: Подписка на Redis Pub/Sub (для мгновенных событий)**
Для критически важных событий используется дополнительный канал:
```redis
# Processing Service публикует событие
PUBLISH vehicle:events:truck_123 '{"type": "geofence_enter", "zone": "loading_dock"}'

# Real-time Service подписан на этот канал и получает мгновенно
```

**Способ 3: Периодический опрос Redis (для восстановления состояния)**
Каждые 5 секунд сервис проверяет в Redis, не появились ли обновления, которые он мог пропустить.

### 4. Хранение данных: многоуровневая система

#### Уровень 1: In-memory кэш (самый быстрый)

В оперативной памяти каждого экземпляра Real-time Service хранится:

**Текущие состояния машин:**
```go
// Concurrent map для безопасного доступа из многих горутин
var vehicleStates = struct {
    sync.RWMutex
    m map[string]VehicleState
}{
    m: make(map[string]VehicleState),
}

// Структура состояния
type VehicleState struct {
    Position      GeoPoint
    Speed         float64
    Status        string
    LastUpdate    time.Time
    // Другие поля...
}
```

**Состояния клиентских соединений:**
```go
type ClientConnection struct {
    ID           string
    WSConnection *websocket.Conn
    Subscriptions []string
    LastActivity time.Time
    UserID       string
}
```

**Преимущества in-memory хранения:**
- Мгновенный доступ (наносекунды)
- Нет сетевых задержек
- Минимальная нагрузка на CPU

**Недостатки:**
- Данные теряются при перезапуске
- Каждый экземпляр имеет свою копию
- Ограничено размером оперативной памяти

#### Уровень 2: Redis (общая память всех экземпляров)

Redis используется для синхронизации между экземплярами и хранения данных, которые должны сохраняться при перезапуске:

**Текущие позиции машин (кэш):**
```redis
# Хэш-таблица с последними позициями
HSET vehicle:current:truck_123 
  "lat" "55.7558"
  "lon" "37.6176" 
  "speed" "65.2"
  "timestamp" "1705314600"
  "status" "moving"
EXPIRE 7200  # Удалить через 2 часа, если нет обновлений
```

**Геопространственный индекс:**
```redis
# Добавление машины в географический индекс
GEOADD vehicles:geoindex 37.6176 55.7558 "truck_123"

# Поиск машин в радиусе 10 км
GEORADIUS vehicles:geoindex 37.6 55.7 10000 km WITHDIST
```

**Подписки клиентов:**
```redis
# Множество клиентов, подписанных на машину
SADD subscribers:vehicle:truck_123 "client_1" "client_2" "client_3"

# Множество машин, на которые подписан клиент
SADD subscriptions:client:client_1 "truck_123" "truck_456" "van_789"
```

**Сессионные данные:**
```redis
SET session:client_1 {
  "user_id": "user_123",
  "connected_at": "2024-01-15T10:00:00Z",
  "last_ping": "2024-01-15T10:30:00Z",
  "instance": "realtime-pod-1"
}
EXPIRE 3600  # Сессия истекает через час неактивности
```

#### Уровень 3: PostgreSQL (долговременное хранение)

В PostgreSQL хранится информация, которая нужна для анализа и восстановления:

**Таблица подключений клиентов:**
```sql
CREATE TABLE client_connections (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    client_id VARCHAR(100),
    instance_id VARCHAR(50),
    connected_at TIMESTAMPTZ,
    disconnected_at TIMESTAMPTZ,
    reason VARCHAR(100),
    messages_sent INTEGER,
    bytes_sent BIGINT
);
```

**Таблица подписок пользователей:**
```sql
CREATE TABLE user_subscriptions (
    user_id UUID REFERENCES users(id),
    vehicle_id UUID REFERENCES vehicles(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, vehicle_id)
);
```

**Логи событий:**
```sql
CREATE TABLE realtime_events (
    id UUID PRIMARY KEY,
    event_type VARCHAR(50),
    client_id VARCHAR(100),
    vehicle_id UUID,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 5. Обработка и оптимизация данных: умная подготовка к отправке

Когда Real-time Service получает обновление о машине, он не просто пересылает его клиентам. Он **интеллектуально обрабатывает** данные:

**Шаг 1: Фильтрация по подпискам**
Сервис проверяет: какие клиенты подписаны на эту машину? Список берется из Redis:
```redis
SMEMBERS subscribers:vehicle:truck_123
→ ["client_1", "client_2", "client_3"]
```

**Шаг 2: Географическая фильтрация**
Для каждого клиента проверяется: находится ли машина в его области просмотра?
```go
func isInViewport(vehiclePos, clientViewport) bool {
    // Если клиент не указал viewport, показываем всё
    if clientViewport == nil {
        return true
    }
    
    // Проверка попадания в bounding box
    return vehiclePos.Lat >= clientViewport.South &&
           vehiclePos.Lat <= clientViewport.North &&
           vehiclePos.Lon >= clientViewport.West &&
           vehiclePos.Lon <= clientViewport.East
}
```

**Шаг 3: Применение фильтров клиента**
Клиент мог указать:
- Показывать только движущиеся машины
- Показывать только грузовики
- Не показывать машины без заданий
- И т.д.

**Шаг 4: Оптимизация payload**
Сервис создает разные версии данных для разных целей:

**Минимальная версия (для частых обновлений позиций):**
```json
{
  "t": "pos",           // type = position
  "v": "truck_123",     // vehicle_id
  "p": [55.7558, 37.6176],  // position [lat, lon]
  "s": 65,              // speed
  "c": 180,             // course
  "ts": 1705314600      // timestamp
}
```

**Полная версия (при первом отображении или по запросу):**
```json
{
  "type": "vehicle_update",
  "vehicle_id": "truck_123",
  "position": {"lat": 55.7558, "lon": 37.6176},
  "speed": 65.2,
  "status": "moving",
  "driver": {"name": "Иванов И.И."},
  "assignment": {"client": "ООО Ромашка"},
  "alerts": ["Превышение скорости"]
}
```

**Шаг 5: Батчинг (группировка сообщений)**
Вместо отправки каждого обновления отдельно, сервис группирует их:

```json
{
  "type": "batch",
  "messages": [
    {"t": "pos", "v": "truck_123", "p": [55.7558, 37.6176]},
    {"t": "pos", "v": "truck_456", "p": [55.7500, 37.6200]},
    {"t": "event", "v": "van_789", "e": "arrival"}
  ],
  "batch_id": "batch_1705314600"
}
```

**Шаг 6: Приоритизация**
Не все сообщения одинаково важны:
- **Высокий приоритет:** Тревоги, аварии, критичные события
- **Средний приоритет:** Изменение позиции движущейся машины
- **Низкий приоритет:** Обновление позиции стоящей машины, служебная информация

### 6. Отправка данных клиентам: искусство быстрой доставки

#### WebSocket: основной протокол

**Установка соединения:**
```javascript
// Клиентская сторона
const ws = new WebSocket('wss://realtime.example.com/ws?token=jwt_token');
```

**Отправка сообщений:**
Сервис использует несколько техник для эффективной отправки:

**Техника 1: Дельта-кодирование**
Вместо отправки полного состояния каждый раз, отправляются только изменения:
```json
// Первое сообщение: полное состояние
{"type": "full", "vehicle": "truck_123", "position": [55.7558, 37.6176], ...}

// Последующие сообщения: только изменения
{"type": "delta", "vehicle": "truck_123", "changes": {"position": [55.7559, 37.6177]}}
```

**Техника 2: Адаптивная частота обновлений**
Сервис подстраивается под поведение машины:
- Движущаяся машина: обновления каждые 5-10 секунд
- Стоящая машина: обновления каждые 30-60 секунд
- Оффлайн машина: проверка статуса каждые 5 минут

**Техника 3: Сжатие данных**
Используется бинарное кодирование и сжатие:
```go
// Вместо JSON используется Protocol Buffers или MessagePack
message VehicleUpdate {
  string vehicle_id = 1;
  double latitude = 2;
  double longitude = 3;
  float speed = 4;
  // ...
}

// И включается сжатие WebSocket
conn.EnableWriteCompression(true)
```

#### Альтернативные протоколы (fallback)

Не все клиенты поддерживают WebSocket. Поэтому Real-time Service предоставляет альтернативы:

**HTTP/2 Server-Sent Events (SSE):**
```javascript
// Клиентская сторона
const eventSource = new EventSource('/api/realtime/stream?token=jwt_token');
eventSource.onmessage = (event) => {
  console.log(JSON.parse(event.data));
};
```

**HTTP Long Polling:**
```javascript
// Клиент периодически опрашивает сервер
async function longPoll() {
  const response = await fetch('/api/realtime/poll?token=jwt_token&timeout=30');
  const data = await response.json();
  // Обработка данных
  longPoll(); // Следующий запрос
}
```

**GRPC Streaming:**
Для мобильных приложений и интеграций.

### 7. Управление соединениями: слежка за здоровьем клиентов

Real-time Service постоянно мониторит состояние соединений:

**Heartbeat (ping/pong):**
Каждые 30 секунд сервер отправляет ping, клиент должен ответить pong:
```javascript
// Сервер
ws.ping();

// Клиент
ws.on('pong', () => {
  // Соединение живо
});
```

**Обнаружение разорванных соединений:**
Если клиент не отвечает на ping в течение 60 секунд, соединение считается разорванным.

**Graceful shutdown:**
При перезапуске сервиса он:
1. Перестает принимать новые соединения
2. Оповещает клиентов о предстоящем отключении
3. Дает время завершить текущие операции
4. Корректно закрывает соединения

**Восстановление соединений:**
При переподключении клиента:
1. Сервис проверяет сессию в Redis
2. Восстанавливает подписки
3. Отправляет текущее состояние всех подписанных машин
4. Отправляет пропущенные события (из буфера)

### 8. Масштабирование: обслуживание тысяч клиентов

#### Горизонтальное масштабирование

**Балансировка соединений:**
```
                   ┌─────────────────┐
                   │   Load Balancer  │
                   │   (nginx/haproxy)│
                   └─────────┬───────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
┌───────▼──────┐    ┌───────▼──────┐    ┌───────▼──────┐
│ Real-time    │    │ Real-time    │    │ Real-time    │
│ Service #1   │    │ Service #2   │    │ Service #3   │
│ (500 clients)│    │ (500 clients)│    │ (500 clients)│
└───────┬──────┘    └───────┬──────┘    └───────┬──────┘
        │                    │                    │
        └────────────────────┼────────────────────┘
                             │
                   ┌─────────▼───────┐
                   │     Redis       │
                   │    Cluster      │
                   │ (синхронизация) │
                   └─────────────────┘
```

**Распределение нагрузки:**
- Каждый экземпляр обслуживает определенный диапазон client_id
- Информация о том, какой клиент на каком экземпляре, хранится в Redis
- При отказе экземпляра клиенты переподключаются к другим

#### Вертикальная оптимизация

**Оптимизация памяти:**
- Object pooling для часто создаваемых объектов
- Сборка мусора с настройкой GOGC
- Использование []byte вместо string где возможно

**Оптимизация CPU:**
- Worker pool для обработки сообщений
- Batch processing для операций с Redis
- Использование efficient data structures

**Оптимизация сети:**
- TCP tuning (увеличение buffer sizes)
- Nagle's algorithm отключен для WebSocket
- Keep-alive connections для внешних вызовов

### 9. Интеграция с другими сервисами

#### С Processing Service
**Основной канал:** Kafka топик `vehicle.updates.enriched`
**Дополнительный канал:** Redis Pub/Sub для мгновенных событий
**Служебные вызовы:** GRPC для запросов дополнительной информации

#### С Vehicle Registry Service
**Для проверки прав доступа:** "Может ли пользователь X видеть машину Y?"
**Для получения детальной информации:** Когда клиент кликает на машину

#### С системой аутентификации
**Проверка JWT токенов**
**Обновление прав доступа в реальном времени**

#### С Analytics Service
**Отправка метрик:** Сколько сообщений отправлено, задержки и т.д.
**Получение аналитики:** Для отображения статистики в реальном времени

### 10. Мониторинг и диагностика

#### Ключевые метрики
```
websocket_connections_active 500
messages_sent_per_second 1500
message_delivery_latency_ms{p99=150}
subscriptions_per_user_avg 25
redis_operations_per_second 5000
```

#### Логирование
- Все подключения/отключения клиентов
- Ошибки отправки сообщений
- Медленные операции
- Нарушения безопасности

#### Health checks
- Проверка соединения с Kafka
- Проверка соединения с Redis
- Проверка нагрузки (CPU, memory)
- Проверка задержек (ping до клиентов)

### 11. Безопасность

#### Защита соединений
- TLS 1.3 для всех соединений
- Сертификаты от Let's Encrypt
- Регулярная ротация ключей

#### Аутентификация и авторизация
- JWT с коротким сроком жизни (1 час)
- Refresh tokens для продления сессий
- Проверка прав для каждого сообщения

#### Защита от атак
- Rate limiting: максимум 100 сообщений/сек от клиента
- Максимальный размер сообщения: 64KB
- Валидация всех входящих данных
- Защита от DDoS: Cloudflare или аналоги

## Пример полного цикла работы

**Сценарий:** Диспетчер Иванов следит за 50 грузовиками в Московском регионе.

1. **09:00** - Иванов открывает карту в браузере
2. **09:00:01** - Устанавливается WebSocket соединение с Real-time Service
3. **09:00:02** - Отправляется JWT токен, сервис проверяет права
4. **09:00:03** - Клиент отправляет подписку: "все грузовики в Москве"
5. **09:00:04** - Сервис загружает текущие позиции 50 грузовиков из Redis
6. **09:00:05** - Отправляется initial batch с позициями всех машин
7. **09:00:10** - Приходит обновление по грузовику А123БВ: новые координаты
8. **09:00:11** - Сервис проверяет: Иванов подписан на этот грузовик? Да
9. **09:00:12** - Проверяется: грузовик в Московском регионе? Да
10. **09:00:13** - Формируется дельта-сообщение с новыми координатами
11. **09:00:14** - Сообщение добавляется в очередь отправки
12. **09:00:15** - Отправляется batch из нескольких обновлений
13. **09:00:16** - Браузер Иванова получает обновление, точка на карте перемещается

**Весь цикл занял 16 секунд, но реальные обновления позиций приходят каждые 5-10 секунд.**

## Проблемы и решения

### Проблема 1: Очень много клиентов подписано на одну машину
**Решение:** Использовать broadcast группы в Redis, а не отправлять каждому клиенту отдельно.

### Проблема 2: Клиент с медленным интернетом
**Решение:** Адаптивная частота обновлений, сжатие данных, приоритизация важных сообщений.

### Проблема 3: Пиковые нагрузки (все машины начали двигаться одновременно)
**Решение:** Rate limiting, батчинг, очередь с приоритетами.

### Проблема 4: Географическое распределение клиентов
**Решение:** CDN для статики, edge-сервера для WebSocket, гео-балансировка.

## Заключение

Real-time Service — это сложный, высоконагруженный сервис, который должен обеспечивать **миллисекундные задержки** при обслуживании **тысяч одновременных соединений**. Он сочетает в себе:

- **Высокую производительность** (in-memory обработка, оптимизированные протоколы)
- **Надежность** (репликация, failover, восстановление сессий)
- **Масштабируемость** (горизонтальное масштабирование, геораспределение)
- **Безопасность** (шифрование, аутентификация, авторизация)

Этот сервис — тот самый волшебный ингредиент, который превращает сырые данные GPS-трекеров в живую, дышащую карту, на которой диспетчеры, водители и клиенты видят актуальную информацию в реальном времени.

Без Real-time Service вся система была бы просто "отчетной системой" — показывала бы, где машины были, но не где они есть сейчас. А с ним — это живой организм, который помогает принимать решения здесь и сейчас.