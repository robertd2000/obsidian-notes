### Когда использовать `getServerSideProps` и `getStaticProps` в Next.js

Выбор между `getServerSideProps` (SSR) и `getStaticProps` (SSG) зависит от требований вашего приложения к данным, производительности и частоте их обновления. Давайте разберем подробно, когда и зачем использовать каждый из этих методов.

---

### **`getStaticProps` (Static Site Generation - SSG)**

#### Когда использовать:
1. **Данные не изменяются часто**:
   - Если данные на странице обновляются редко (например, раз в день или реже), SSG — это идеальный выбор.
   - Примеры: блоги, документация, каталоги товаров с редкими обновлениями.

2. **Высокая производительность**:
   - Страницы, сгенерированные статически, загружаются быстрее, так как они предварительно рендерятся и кэшируются.
   - Это особенно полезно для страниц, которые должны быть доступны мгновенно (например, главная страница, страницы продуктов).

3. **SEO-оптимизация**:
   - Статические страницы легко индексируются поисковыми системами, так как HTML генерируется на этапе сборки.

4. **Incremental Static Regeneration (ISR)**:
   - Если данные могут изменяться, но не требуют мгновенного обновления, используйте ISR с параметром `revalidate` в `getStaticProps`.
   - Пример: страница блога, которая обновляется каждые 10 минут.

#### Пример использования:
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 600, // Перегенерировать страницу каждые 10 минут
  };
}
```

#### Преимущества:
- Высокая производительность.
- Упрощенное кэширование (CDN, браузеры).
- Лучшая SEO-оптимизация.

#### Недостатки:
- Не подходит для данных, которые изменяются часто или зависят от запроса пользователя.

---

### **`getServerSideProps` (Server-Side Rendering - SSR)**

#### Когда использовать:
1. **Данные изменяются часто**:
   - Если данные на странице обновляются часто (например, каждую секунду), SSR — это правильный выбор.
   - Примеры: панели управления, аналитика, персонализированные данные.

2. **Зависимость от запроса пользователя**:
   - Если данные зависят от запроса пользователя (например, куки, заголовки, параметры URL), используйте SSR.
   - Пример: страница профиля пользователя, где данные зависят от авторизации.

3. **Динамический контент**:
   - Если контент страницы должен быть уникальным для каждого пользователя или запроса, SSR подходит лучше всего.
   - Пример: страница с персонализированными рекомендациями.

4. **Нет возможности предварительной генерации**:
   - Если данные нельзя предварительно загрузить на этапе сборки (например, они генерируются в реальном времени), используйте SSR.

#### Пример использования:
```javascript
export async function getServerSideProps(context) {
  const { req, res, query } = context;
  const userId = req.cookies.userId; // Пример использования куки

  const response = await fetch(`https://api.example.com/user/${userId}`);
  const userData = await response.json();

  return {
    props: {
      userData,
    },
  };
}
```

#### Преимущества:
- Актуальные данные при каждом запросе.
- Подходит для персонализированных данных.
- Гибкость в работе с запросами пользователя.

#### Недостатки:
- Меньшая производительность по сравнению с SSG, так как страница рендерится на сервере при каждом запросе.
- Сложнее кэшировать (требуется настройка на уровне сервера или CDN).

---

### **Сравнение `getStaticProps` и `getServerSideProps`**

| Характеристика               | `getStaticProps` (SSG)                     | `getServerSideProps` (SSR)                |
|------------------------------|--------------------------------------------|-------------------------------------------|
| **Когда вызывается**         | На этапе сборки (build time) или с ISR.    | На сервере при каждом запросе пользователя. |
| **Производительность**       | Высокая (предварительно сгенерированный HTML). | Ниже (рендеринг при каждом запросе).      |
| **Актуальность данных**      | Данные могут быть устаревшими (если не используется ISR). | Данные всегда актуальные.                 |
| **Зависимость от запроса**   | Не зависит от запроса пользователя.        | Зависит от запроса пользователя (куки, заголовки и т.д.). |
| **SEO**                      | Отлично подходит для SEO.                  | Подходит для SEO, но медленнее, чем SSG.  |
| **Использование**            | Блоги, каталоги, документация.             | Панели управления, персонализированные данные. |

---

### **Когда использовать ISR (Incremental Static Regeneration)**

ISR — это гибридный подход, который сочетает преимущества SSG и SSR. Используйте ISR, если:
- Данные изменяются, но не требуют мгновенного обновления.
- Вы хотите сохранить высокую производительность SSG, но с возможностью обновления данных.

#### Пример:
```javascript
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 60, // Перегенерировать страницу каждые 60 секунд
  };
}
```

---

### **Практические примеры**

1. **Блог**:
   - Используйте `getStaticProps` для генерации статических страниц постов.
   - Если данные обновляются, добавьте `revalidate` для ISR.

2. **Панель управления**:
   - Используйте `getServerSideProps` для загрузки данных, специфичных для пользователя (например, статистика, уведомления).

3. **Каталог товаров**:
   - Используйте `getStaticProps` для генерации страниц товаров.
   - Если цены или наличие товаров изменяются, используйте ISR с `revalidate`.

---

### **Итог**

- **`getStaticProps`**:
  - Используйте для статических страниц с редко изменяющимися данными.
  - Подходит для SEO и высокой производительности.
  - Добавьте `revalidate` для ISR, если данные могут обновляться.

- **`getServerSideProps`**:
  - Используйте для страниц с часто изменяющимися или персонализированными данными.
  - Подходит для данных, зависящих от запроса пользователя.

Выбор между этими методами зависит от требований вашего приложения к данным и производительности. В некоторых случаях можно комбинировать оба подхода для разных страниц.