
# Filter
```go

func Filter[T any](slice []T, condition func(T) bool) []T {
    var result []T
    for _, v := range slice {
        if condition(v) {
            result = append(result, v)
        }
    }
    return result
}

// Пример использования
names := []string{"Alice", "Bob", "Charlie"}
longNames := Filter(names, func(s string) bool {
    return len(s) > 4
})
fmt.Println(longNames) // ["Alice", "Charlie"]


```

### 3. Фильтрация "на месте" (изменение исходного слайса)


```go

func filterInPlace(slice *[]int, condition func(int) bool) {
    filtered := (*slice)[:0]
    for _, v := range *slice {
        if condition(v) {
            filtered = append(filtered, v)
        }
    }
    *slice = filtered
}

// Пример использования
numbers := []int{1, 2, 3, 4, 5}
filterInPlace(&numbers, func(n int) bool {
    return n > 3
})
fmt.Println(numbers) // [4 5]
```
### 4. Фильтрация с сохранением исходного слайса

```go

func filterInPlaceCopy(slice []int, condition func(int) bool) []int {
    result := make([]int, 0, len(slice))
    for _, v := range slice {
        if condition(v) {
            result = append(result, v)
        }
    }
    return result
}
```

```go
func FilterWithError[T any](slice []T, condition func(T) (bool, error)) ([]T, error) {
    var result []T
    for _, v := range slice {
        if ok, err := condition(v); err != nil {
            return nil, err
        } else if ok {
            result = append(result, v)
        }
    }
    return result, nil
}

```

