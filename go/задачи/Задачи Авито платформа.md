
## 1. Что будет в консоли?

```go

package main

import "fmt"

type Person struct {
	Name string
}

func changeName(person *Person) {
	person = &Person{
		Name: "Alice",
	}
}

func main() {
	person := &Person{
		Name: "Bob",
	}
	fmt.Println(person.Name)
	changeName(person)
	fmt.Println(person.Name)
}

// вывод
// Bob
// Bob

``` 



Как сделать чтоб было


// Bob
// Alice
```go

package main

import "fmt"

type Person struct {
	Name string
}

func changeName(person *Person) {
	*person = Person{
		Name: "Alice",
	}
}

func main() {
	person := Person{
		Name: "Bob",
	}
	fmt.Println(person.Name)
	changeName(&person)
	fmt.Println(person.Name)
}

```

```go

package main

import "fmt"

type Person struct {
	Name string
}

func changeName(person **Person) {
	*person = &Person{
		Name: "Alice",
	}
}

func main() {
	person := &Person{
		Name: "Bob",
	}
	fmt.Println(person.Name)
	changeName(&person)
	fmt.Println(person.Name)
}

```

## 2

```go

package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// Есть функция, работающая неопределённо долго и возвращающая число.
// Её тело нельзя изменять (представим, что внутри сетевой запрос).
func unpredictableFunc() int64 {
	rnd := rand.Int63n(5000) // случайное число до 5 секунд
	time.Sleep(time.Duration(rnd) * time.Millisecond)
	return rnd
}

func predictableFunc(ctx context.Context) (int64, error) {
	res := make(chan int64, 1)
	
	go func() {
		defer close(res)
		res <- unpredictableFunc()
	}()
	
	select {
		case <- ctx.Done():
			return 0, fmt.Errorf("Timeout)
		case ans := <- res:
			return ans, nil
	}
}
```


```go

package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// Есть функция, работающая неопределённо долго и возвращающая число.
// Её тело нельзя изменять (представим, что внутри сетевой запрос).
func unpredictableFunc() int64 {
	rnd := rand.Int63n(5000) // случайное число до 5 секунд
	time.Sleep(time.Duration(rnd) * time.Millisecond)
	return rnd
}

// Обёртка с таймаутом
func predictableFunc(timeout time.Duration) (int64, error) {
	start := time.Now()
	
	// Создаем контекст с таймаутом
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	
	// Канал для результата
	resultChan := make(chan int64, 1)
	
	// Запускаем unpredictableFunc в горутине
	go func() {
		result := unpredictableFunc()
		resultChan <- result
	}()
	
	// Ждем результат или таймаут
	select {
	case result := <-resultChan:
		// Функция завершилась вовремя
		elapsed := time.Since(start)
		log.Printf("Функция выполнилась за: %v", elapsed)
		return result, nil
	case <-ctx.Done():
		// Таймаут
		elapsed := time.Since(start)
		log.Printf("Функция прервана по таймауту после: %v", elapsed)
		return 0, fmt.Errorf("таймаут %v превышен", timeout)
	}
}

func main() {
	// Пример использования с таймаутом 1 секунда
	timeout := 1 * time.Second
	
	result, err := predictableFunc(timeout)
	if err != nil {
		fmt.Printf("Ошибка: %v\n", err)
	} else {
		fmt.Printf("Результат: %d\n", result)
	}
}

```