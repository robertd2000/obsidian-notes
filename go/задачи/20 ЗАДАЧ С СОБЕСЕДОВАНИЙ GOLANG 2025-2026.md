https://www.youtube.com/watch?v=6Q-Vc7J_d5Y
# 1

```go

type impl struct{}

type I interface {
	C()
}

func (*impl) C() {}

func A() I {
	return nil // T: nil, val: nil
}

func B() I {
	var ret *impl // T: *impl, val: nil
	return ret
}

func main() {
	a := A()
	b := B()
	
	fmt.Println(a == b) // false
}
```

# 2

```go

func main() {
	var foo []int
	var bar []int
	
	foo = append(foo, 1)
	foo = append(foo, 2)
	foo = append(foo, 3)
	bar = append(foo, 4)
	foo = append(foo, 5)
	fmt.Println(foo, bar) // [1, 2, 3, 5], [1, 2, 3, 5]
}

```

# 3

```sql

select country, count(id) from students
where country != 'China' 
group by country having count(id) > 10

```

# 4 

```go
// почему горутины заблокированы
func main() {
	ch := make(chan int)
	ch <- 1 // тут заблокирруется main (основной поток), и будет ждать пока кто то не прочитает из канала, но до чтения код не дойдет т.к. основной поток заблокирровался
	
	go func() {
		fmt.Prinln(<-ch)
	}()
}
```


# 5

```go

func main() {
	c := []string{"A", "B", "D", "E"} // len = 4, cap = 4
	b := c[1:2] // len = 1, cap = 3
	b = append(b, "TT") 
	fmt.Println(b) // {"B", "TT"}
	fmt.Println(c) // {"A", "B", "TT", "E"}
}


```

# 6

```go

x := 2.0
y := 3.0

res := math.Pow(x, y)

fmt.Println("%f ^ %f = %f\n", x, y, res)

// не будет форматирвания, т.к это не Printf

```

# 7 

```go

func printType(x interface{}) {
	fmt.Prinf("%T\n", x)
}


func main() {
	printType(42)
	printType("str)
	printType(true)
}
```

# 8

```go

func main() {
	fmt.Println("start")
	
	for i := 1; i < 4; i+ {
		defer Println(i)
	}
	fmt.Println("end")
}

// start end 3 2 1  
```

# 9

```go

func main() {
	ch := make(chan bool) // добавить буффер 
	// make(chan bool, 1)
	ch <- true // тут dedlock
	
	go func() {
		<-ch
	}()
	
	ch<-true
}
```

# 10

```go

func main() {
	ch := make(chan bool)
	ch2 := make(chan bool)
	ch3 := make(chan bool)

	go func() {
		ch <- true
	}()
	
	go func() {
		ch2 <- true
	}()
	
	go func() {
		ch3 <- true
	}()
	
	select {
	case <-ch:
		fmt.Println("ch")
	case <-ch2:
		fmt.Println("ch2")
	case <-ch3:
		fmt.Println("ch3")
	}
}

// рандомно будет выводиться
// если 2 горутины одноврременно выполнятся 
// то select случайно выберет одну
```

# 11

```go

func main() {
	var m map[string]int // make(map[string]int)
	
	for _, w := range []string{"hello", "world", "hello"} {
		m[w]++ // паника при попытке записи в неинициализированную мапу
	}
	
	for k, v := range m {
		fmt.Println(k, v)
	} // а тут обход будет случайным
}
```

# 12

```go

var globalMap = map[string]int{"test": make([]int, 0), "test2": make([]int, 0), "test3": make([]int, 0)}

var a = 0
// проблема с data race
func main() {
	wg := sync.WaitGroup{}
	wg.Add(3)
	
	go func() {
		wg.Done() // defer, а то wg.Wait может выйти раньше времени
		a = 10
		globalMap["test"] = append(globalMap["test"], a)
	}()
		
	go func() {
		wg.Done() // defer
		a = 11
		globalMap["test"] = append(globalMap["test2"], a)
	}()
		
	go func() {
		wg.Done() // defer
		a = 12
		globalMap["test"] = append(globalMap["test3"], a)
	}()
	
	wg.Wait()
	fmt.Printf("%x", globalMap) // data race
	fmt.Printf("%d", a) // random
}
```

```go

var globalMap = map[string]int{"test": make([]int, 0), "test2": make([]int, 0), "test3": make([]int, 0)}
var mu = sync.Mutex{}

var a = 0
// проблема с data race
func main() {
	wg := sync.WaitGroup{}
	wg.Add(3)
	
	go func() {
		defer wg.Done() // defer, а то wg.Wait может выйти раньше времени
		mu.Lock()
		a = 10
		globalMap["test"] = append(globalMap["test"], a)
		mu.Unlock()
	}()
		
	go func() {
		defer wg.Done() // defer
		mu.Lock()
		a = 11
		globalMap["test"] = append(globalMap["test2"], a)
		mu.Unlock()
	}()
		
	go func() {
		defer wg.Done() // defer
		mu.Lock()
		a = 12
		globalMap["test"] = append(globalMap["test3"], a)
		mu.Unlock()
	}()
	
	wg.Wait()
	fmt.Printf("%x", globalMap) // будет правильно
	fmt.Printf("%d", a) // random
}
```

# 13

```go

type Result struct{}

type SearchFunc func(ctx context.Context, query string) (Result, error)

// MultiSearch - выполняет поиск
// query в SearchFunc
// веррнуть первый успешный результат
// если все упали с ошибкой - отдать последнюю ошибку
func MultiSearch(ctx context.Context, query string, sfs []SearchFunc) (Result, error) {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	
	resCh := make(chan Result, 1)
	errCh := make(chan error, len(sfs))
	wg := sync.WaitGroup{}
	
	for _, sf := range sfs {
		wg.Add(1)
		go func() {
			defer wg.Done()
			v, err := sf(ctx, query)
			if err != nil {
				errCh <- err
				return
			}
			select {
			case resCh <- v:
				cancel()
			default:
			}
		}() 
	}
	wg.Wait()
	
	close(errCh)
	
	select {
	case r := <- resCh:
		return r, nil
	case <- ctx.Done():
	}
	
	var lastErr error
	
	for e := range errCh {
		lastErr = e
	}
	
	
	return Result{}, lastErr
}
```


# 14
![[Pasted image 20251221170914.png]]

```sql
select * from departments 
left join employees 
on departments.department_id = employees.department_id
where employee_id is NULL

```

# 14_1

```go
// init
func  printNumber(ptrToNumber interface{}) {
	if ptrToNumber != nil {
		fmt.Println(*ptr.(*int))
	} else {
		fmt.Println("nil")
	}
}
// fixed version
func printNumber(ptrToNumber interface{}) {
	if ptr, ok := ptrToNumber.(*int); ok {
	  	if ptr != nil {
		  	fmt.Println(*ptr)
	  	} else {
			fmt.Println("nil")
	  	}
	} else {
		fmt.Println("not int")
	}
}

func main() {
	v := 10
	printNumber(&v) // 10
	var pv *int
	printNumber(pv) // interface не nil, поэтому он попадет в первую ветку и попытается разименовать указатель на nil и будет ошибка
	pv = &v
	printNumber(pv)
}

```

# 15

```go

func main() {
	mutate := func(a []int) {
		a[0] = 0
		a = append(a, 1)
		fmt.Println(a) // 0, 2, 3, 4, 1
	}
	
	a := []int{1, 2, 3, 4}
	mutate(a)
	fmt.Println(a)// 0, 2, 3, 4 - так как len у а не поменялся - мы передали в mutate а по значению и так поменялся len, а у оригинала нет - также у копии произойдет переалокация так как cap превысится и после append они перрестанут делить общий базовый массив
}

```

# 16

```go

type MyError struct {}

func (e *MyError) Error() string {
	return "my error"
}

func CheckEror(err error) {
	if err != nil {
		panic(err)
	}
	
	fmt.Println("ok")
}

func TestCollect(t *testing.T) {
	var err *MyError // T: *MyError, v: nil - т.к. значение не nil (его тип не nil), а error это интеррфейс, а они сравниваются и по типу, и по значению, то попадет в первую ветку
	CheckEror(err) // panic: "my error"
}

```

# 17

```go

func main() {
	var c int
	// data race
	for i := 0; i < 1000; i++ {
		go func() {
			c++
		}
	}
	
	fmt.Println(c) // рандом, не все горутины успевают выполниться
}
// решение
func main() {
	mu := sync.Mutex{}
	wg := sync.WaitGroup{}
	var c int
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			mu.Lock()
			defer mu.Unlock()
			c++
		}
	}
	
	wg.Wait()
	fmt.Println(c)
}

```

# 18

```go

type User struct {
	Valid bool // 1
	Id int64 // 8
	Number int32 // 4
}

type CUser struct {
	Id int64 // 8
	Number int32 // 4
	Valid bool // 1
}

func TestSize(t *testing.T) {
	user := User{} // 24
	cuser := CUser{} // 16
	
	if unsafe.Sizeof(user) == unsafe.Sizeof(cuser) {
		t.Log("same")
	} else {
		t.Log("diff")
	}
	// diff
}

```

# 19

```go

func mod(a []int) {
	a = append(a, 125) // cap становится 10
	
	for i := range a {
		a[i] = 5
	}
	
	fmt.Println(a) // {5, 5, 5, 5, 5, 5}
}

func main() {
	s := []int{1, 2, 3, 4, 5} // cap = 5
	mod(s)
	fmt.Println(s) // {1, 2, 3, 4, 5} 
	
}

```

# 20

```go

func main() {
	m := make(chan string, 3)
	c := 5
	wg := &sync.WaitGroup{}
	
	for i := range c {
		wg.Add(1)	
		go func() {
			defer wg.Done()
			m <- fmt.Sprintf("Go %d", i)
		}()
	}
	
	for i := range c {
		wg.Add(1)	
		go ReceiveFromCh(m, wg)
	}
	
	wg.Wait()
}

func ReceiveFromCh(ch chan string, wg *sync.WaitGroup){
	defer wg.Done()
	fmt.Println(<-ch)
}
```