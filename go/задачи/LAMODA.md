
# 1

```go

package main

import "fmt"

func foo(arr []int) {
    arr = append(arr, 9, 9)
}

func main() {
    src := []int{1, 2, 3, 4, 5}
    arr := src[:3] 

    foo(arr)

    fmt.Println(src) // 1, 2, 3, 9, 9
    fmt.Println(arr) // 1, 2, 3
}
```

1. **Исходный массив**: `src` имеет длину 5 и емкость 5
    
2. **Создание среза**: `arr := src[:3]` создает срез:
    
    - Данные: `[1, 2, 3]`
        
    - Длина: 3
        
    - **Емкость: 5** (потому что берется из исходного массива)
        
3. **В функции foo**:
    
    - `append(arr, 9, 9)` пытается добавить два элемента
        
    - Поскольку емкость (5) > текущей длины (3) + новые элементы (2),  
        **не происходит переаллокации памяти**
        
    - Новые элементы записываются в исходный массив `src` на позиции 4 и 5
        
4. **Но почему arr не изменился?**
    
    - В Go срезы передаются по значению (копируется заголовок среза)
        
    - Функция `foo` получает копию заголовка среза
        
    - `append` изменяет локальную копию, но не оригинальный срез `arr` в main
        
    - Однако данные записываются в общий базовый массив

## как не мутирровать изначальный слайс?

1.
```go

	arr := src[:3:3]

```

если сделать так, то у arr cap будет 3 по формуле 

```
For slice[i:j:k] or [2:3:4]
Length: j - i or 3 - 2 = 1
Capacity: k - i or 4 - 2 = 2
```

и значит при append т.к. capacity переполнится создастся новый массив

2.
можно изменить foo, чтобы возвращал слайс

3 можно копию сделать
