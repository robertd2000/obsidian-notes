

```go

a := []int{0, 1, 2, 3}
b := a // b и a теперь указывают на один и тот же базовый массив

b[1] = b[len(b)-1]    // b становится [0, 3, 2, 3], следовательно, a тоже [0, 3, 2, 3]
b[len(b)-1] = 0       // b становится [0, 3, 2, 0], следовательно, a тоже [0, 3, 2, 0]
b = b[:len(b)-1]      // b теперь указывает на первые 3 элемента: [0, 3, 2] (длина 3, capacity 4)
b[0] = 4              // b становится [4, 3, 2], а так как a всё ещё видит весь массив, a становится [4, 3, 2, 0]

fmt.Println(a, b) // Вывод: [4 3 2 0] [4 3 2]
fmt.Println(len(a), len(b), cap(a), cap(b)) // Вывод: 4 3 4 4

b = append(b, 20)

fmt.Println(a, b) // Вывод: [4 3 2 20] [4 3 2 20]

```

```go

func main() {
	foo := 5
	bar := &foo
	fmt.Println(*bar) // 5
	changePointer(bar)
	fmt.Println(*bar) // 5
}

func changePointer(p *int) {
	newP := 3
	p = &newP
}

```

чтобы изменить bar нужно сделать так

```go

func main() {
	foo := 5
	bar := &foo
	fmt.Println(*bar) // 5
	changePointer(bar)
	fmt.Println(*bar) // 3
}

func changePointer(p *int) {
	newP := 3
	*p = &newP
}

```


```go

// есть сотрудники делающие бургеры, код учитывает сколько они сделали бургеров
// по жалобе клиента, у них могут уменьшать счетчик бургеров

var workers map[string]uint

func makeBurger(workerName string) {
    workers[workerName] = workers[workerName] + 1
}

func rejectBurger(workerName string) {
    work ers[workerName] = workers[workerName] - 1
}

func currentCount(workerName string) {
    fmt.Printf("Worker: `%s` made %d burgers\n", workerName, workers[workerName])
}

```

```go

var (
    workers = make(map[string]uint)
    mu      sync.RWMutex
)

func makeBurger(workerName string) {
    mu.Lock()
    defer mu.Unlock()
    workers[workerName]++
}

func rejectBurger(workerName string) {
    mu.Lock()
    defer mu.Unlock()
    if workers[workerName] > 0 {
        workers[workerName]--
    }
}

func currentCount(workerName string) {
    mu.RLock()
    defer mu.RUnlock()
    count, exists := workers[workerName]
    if !exists {
        fmt.Printf("Worker: `%s` not found\n", workerName)
        return
    }
    fmt.Printf("Worker: `%s` made %d burgers\n", workerName, count)
}

```

```go

func doSmt() chan int {
    ch := make(chan int)
    
    go func() {
        time.Sleep(2 * time.Second)
        ch <- 111
    }()
    
    return ch
}

func main() {
    timeStart := time.Now()
    
    a, b := <-doSmt(), <-doSmt()
    fmt.Println(int(time.Since(timeStart).Seconds()))
}
// 4 секунды
```

Решение чтобы было 2 сек

```go

func main() {
	timeStart := time.Now()

	a, b := doSmt(), doSmt()

	fmt.Println(<-a)
	fmt.Println(<-b)

	fmt.Println(int(time.Since(timeStart).Seconds()))

}

```

