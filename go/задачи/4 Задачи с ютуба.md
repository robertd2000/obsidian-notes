https://www.youtube.com/watch?v=cigtNB3T-wk

# 1

```go

package main

import "fmt"

func callCallbacks(a, b func()) {
	go a()
	go b()
}

func main() {
	example()
}

func example() {
	firstDone := make(chan struct{})
	secondDone := make(chan struct{})

	callCallbacks(func() {
		fmt.Println(("a"))
		close(firstDone)
	},
		func() {
			fmt.Println(("b"))
			close(secondDone)
		})

	count := 0

	for count < 2 {
		select {
		case <-firstDone:
			count++
		case <-secondDone:
			count++
		}
	}

	fmt.Printf("%d", count)

	// 1. a b 2
	// 2. b a 2
	// 3. a 2
	// 4. b 2
	// 5. a 2 b 
	// 6. b 2 a 
	//
}
```

```go

package main

import "fmt"

func callCallbacks(a, b func()) {
	go a()
	go b()
}

func main() {
	example()
}

func example() {
	firstDone := make(chan struct{})
	secondDone := make(chan struct{})

	callCallbacks(func() {
		fmt.Println(("a"))
		close(firstDone)
	},
		func() {
			fmt.Println(("b"))
			close(secondDone)
		})

	count := 0

	for count < 2 {
		select {
		case <-firstDone:
			count++
			firstDone = nil
		case <-secondDone:
			count++
			secondDone = nil
		}
	}

	fmt.Printf("%d", count)

	// 1. a b 2
	// 2. b a 2
	// 3. a 2
	// 4. b 2
	// 5. a 2 b 
	// 6. b 2 a 
	//
}
```

# 2

```go

package main

import (
	"fmt"
	"sync"
	"time"
)

func gen(data []int, delay time.Duration) <-chan int {
	out := make(chan int)

	go func() {
		defer close(out)

		for _, v := range data {
			time.Sleep(delay)
			out <- v
		}
	}()

	return out
}

func merge(cs ...<-chan int) <-chan int {
	out := make(chan int)
	wg := &sync.WaitGroup{}

	for _, ch := range cs {
		wg.Add(1)
		go func() {
			defer wg.Done()

			for v := range ch {
				out <- v
			}
		}()
	}

	go func() {
		wg.Wait()
		close(out)
	}()

	return out
}

func main() {
	c1 := gen([]int{1, 2, 3}, 100*time.Millisecond)
	c2 := gen([]int{4, 5, 6}, 150*time.Millisecond)
	c3 := gen([]int{7, 8, 9}, 50*time.Millisecond)

	merged := merge(c1, c2, c3)

	for v := range merged {
		fmt.Println(v)
	}
}

```

# 3 

```go

package main

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strings"
)

type Order struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
	User   User   `json:"user"`
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func main() {
	http.HandleFunc("/orders", OrderHandler)
	// лучше сделать объект сервака, прокинуть порт, таймауты, корсы, рейт лимитеры
	http.ListenAndServe(":8080", nil) // порт в константы или конфиг
	// можно обработать ошибку
}

// ручки и сервисы вынести на отдельные слои
// тесты добавить
// контекст прокинуть
// gracefull shutdown
func OrderHandler(w http.ResponseWriter, r *http.Request) {
	ids := r.URL.Query().Get("ids")
	orderIDs := strings.Split(ids, ",") // добавить трим,  чтобы пробелы не влезли

	orders := FetchOrders(orderIDs)

	for i := range orders { // можно батчами запрашивать
		user := FetchUserDetails(orders[i].UserID) // лучше не по i деалть
		orders[i].User = user
	}

	resp, _ := json.Marshal(orders) // ошибки
	w.Write(resp)                   // обработать ошибку
}

func FetchOrders(orderIDs []string) []Order {
	var orders []Order // можно память выделить
	for _, id := range orderIDs {
		orders = append(orders, Order{ID: id, UserID: "user" + id}) // строки так неэффективно клеить
	}
	return orders
}

// FetchUserDetails кнтекст добавить
func FetchUserDetails(userID string) User { // тут лучше ошибку тоже возвращать
	resp, _ := http.Get("http://user-service:8081/user?id=" + userID) // путь лучше в конфиг\константы
	// ошибки не обработаны
	// тут тож лучше http объект создать
	// можно кэшировать ответы
	body, _ := ioutil.ReadAll(resp.Body) // обраьотать ошибки и пакет этот устарел, лучше io использовать
	var user User
	json.Unmarshal(body, &user) // ошибки
	return user
}

```
# 4

```go

package main

import (
	"context"
	"fmt"
	"log"
	"time"
)

// Эта функция лезет по сети в старый монолит и может тупить.
func getDiscount() float64 {
	time.Sleep(2 * time.Second)
	return 12.0
}

func wrapper(ctx context.Context) (float64, error) {
	res := make(chan float64)

	go func() {
		res <- getDiscount()
	}()

	select {
	case val := <-res:
		return val, nil
	case <-ctx.Done():
		return 0, ctx.Err()
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()

	discount, err := wrapper(ctx)
	if err != nil {
		log.Fatal(err)
		return
	}

	fmt.Printf("Ваша скидка: %v", discount)
}

```