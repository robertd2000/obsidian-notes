https://www.youtube.com/watch?v=kyF7d_xRZEU

```go
// Условие задачи

// Мы в Авито любим проводить соревнования, — недавно мы устроили чемпионат по шагам. И вот настало время подводить итоги!

// Необходимо определить userIds участников, которые прошли наибольшее количество шагов steps за все дни, не пропустив ни одного дня соревнований.

// Пример

// # Пример 1
// # ввод

// statistics = [
//     [{ userId: 1, steps: 1000 }, { userId: 2, steps: 1500 }],
//     [{ userId: 2, steps: 1000 }]
// ]

// # вывод
// champions = { userIds: [2], steps: 2500 }

// # Пример 2
// statistics = [
//     [{ userId: 1, steps: 2000 }, { userId: 2, steps: 1500 }],
//     [{ userId: 2, steps: 4000 }, { userId: 1, steps: 3500 }]
// ]

// # вывод
// champions = { userIds: [1, 2], steps: 5500 }
package main

import "fmt"

type Record struct {
    UserID int
    Steps int
}

type Champions struct {
    UserIDs []int
    Steps int
}

type UserType struct {
    Steps int
    Count int
}

func findChampions(statistics [][]Record) Champions {
    if len(statistics) == 0 {
        return Champions{
            UserIDs: []int{},
            Steps: 0,
        }
    }

    usersMap := make(map[int]*UserType)

    for _, records := range statistics {
        for _, record := range records {
            if _, ok := usersMap[record.UserID]; !ok {
                usersMap[record.UserID] = &UserType{
                    Steps: record.Steps,
                    Count: 1,
                }
            } else {
                usersMap[record.UserID].Steps += record.Steps
                usersMap[record.UserID].Count += 1
            }
        }
    }
    maxSteps := 0

    for _, v := range usersMap {
        if v.Count == len(statistics) {
            maxSteps = max(maxSteps, v.Steps)
        }
    }
    
    champions := make([]int, 0)

    for k, v := range usersMap {
        if v.Steps == maxSteps && v.Count == len(statistics)  {
            champions = append(champions, k)
        }
    }

    return Champions{
        UserIDs: champions,
        Steps: maxSteps,
    }
}

  

func main() {

    // Пример 1
    statistics1 := [][]Record{
        {
            {UserID: 1, Steps: 1000},
            {UserID: 2, Steps: 1500},
        },
        {
           {UserID: 2, Steps: 1000},
        },
    }

    // Пример 2

    statistics2 := [][]Record{
        {
            {UserID: 1, Steps: 2000},
            {UserID: 2, Steps: 1500},
        },
        {
            {UserID: 2, Steps: 4000},
            {UserID: 1, Steps: 3500},
        },
    }

    fmt.Println("Пример 1:")
    result1 := findChampions(statistics1)
    fmt.Printf("champions = { userIds: %v, steps: %d }\n", result1.UserIDs, result1.Steps)
    fmt.Println("\nПример 2:")
    result2 := findChampions(statistics2)
    fmt.Printf("champions = { userIds: %v, steps: %d }\n", result2.UserIDs, result2.Steps)
}

type UserStats struct {
    Steps int
    Days  map[int]bool // Отслеживаем уникальные дни
} 

func findChampions2(statistics [][]Record) Champions {
    if len(statistics) == 0 {
        return Champions{UserIDs: []int{}, Steps: 0}
    }

    usersMap := make(map[int]*UserStats)

    // Собираем статистику по дням
    for dayIndex, dayRecords := range statistics {
        for _, record := range dayRecords {
            if _, exists := usersMap[record.UserID]; !exists {
                usersMap[record.UserID] = &UserStats{
                    Steps: 0,
                    Days:  make(map[int]bool),
                }
            }

            usersMap[record.UserID].Steps += record.Steps
            usersMap[record.UserID].Days[dayIndex] = true
        }
    }

    // Находим максимальное количество шагов среди участников всех дней
    maxSteps := 0
    champions := make([]int, 0)
    
    for userID, stats := range usersMap {
        // Проверяем, что пользователь участвовал во всех днях
        if len(stats.Days) == len(statistics) {
            if stats.Steps > maxSteps {
                // Новый максимум - очищаем предыдущих чемпионов
                maxSteps = stats.Steps
                champions = []int{userID}
            } else if stats.Steps == maxSteps {
                // Равный результат - добавляем к чемпионам
                champions = append(champions, userID)
            }
        }
    }

    return Champions{
        UserIDs: champions,
        Steps:   maxSteps,
    }
}
```

# 2 

```go

// Условие задачи:
// На Авито размещено множество товаров, каждый из которых
// представлен числом. У каждого покупателя есть потребность
// в товаре, также выраженная числом. Если точного товара нет,
// покупатель выбирает ближайший по значению товар, что вызывает
// неудовлетворённость, равную разнице между его потребностью и
// купленным товаром. Количество каждого товара не ограничено, и
// один товар могут купить несколько покупателей. Рассчитайте
// суммарную неудовлетворённость всех покупателей.

// Нужно написать функцию, которая примет на вход два массива:
// массив товаров и массив потребностей покупателей, вычислит
// сумму неудовлетворённостей всех покупателей и вернет резултат
// в виде числа.

// Пример:
// Ввод:
// goods = [8, 3, 5] - len = n
// buyerNeeds = [5, 6] - len = m
// Вывод:
// res = 1
// Пояснение:
// - первый покупатель (потребность 5) покупает товар 5, неудовлетворённость = 0
// - второй покупатель (потребность 6) покупает товар 5 (ближайший), неудовлетворённость = |6-5| = 1

// Функция для расчета суммарной неудовлетворённости
package main

import (
	"sort"
)

func calculateDissatisfaction(goods []int, needs []int) int {
	if len(goods) == 0 {
		return 0
	}

	sort.Ints(goods)

	dissatisfaction := 0

	for _, need := range needs {
		dissatisfaction += calcDiff(goods, need)
	}

	return dissatisfaction
}

func calcDiff(a []int, val int) int {
	l, r := 0, len(a)-1

	for l <= r {
		m := l + (r-l)/2

		if a[m] == val {
			return 0
		} else if a[m] < val {
			l = m + 1
		} else {
			r = m - 1
		}
	}

	diff := 1<<31 - 1

	if l < len(a) {
		diff = min(diff, abs(val-a[l]))
	}

	if r >= 0 {
		diff = min(diff, abs(val-a[r]))
	}

	return diff
}

func findMinDiff(sortedArr []int, target int) int {
	idx := sort.SearchInts(sortedArr, target)

	if idx < len(sortedArr) && sortedArr[idx] == target {
		return 0
	}

	minDiff := 1<<31 - 1 // Max int

	if idx < len(sortedArr) {
		diff := abs(target - sortedArr[idx])
		if diff < minDiff {
			minDiff = diff
		}
	}

	// Проверяем элемент перед idx (если он существует)
	if idx > 0 {
		diff := abs(target - sortedArr[idx-1])
		if diff < minDiff {
			minDiff = diff
		}
	}

	return minDiff
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	// Тест из условия задачи
	goods := []int{8, 3, 5}
	buyerNeeds := []int{5, 6}

	result := calculateDissatisfaction(goods, buyerNeeds)
	println("Тест из условия: товары [8,3,5], потребности [5,6]")
	println("Ожидаем: 1")
	println("Получили:", result)
	println()

	// Дополнительные тесты
	goods2 := []int{1, 2, 3}
	buyerNeeds2 := []int{2, 2, 2}
	result2 := calculateDissatisfaction(goods2, buyerNeeds2)
	println("Тест 2: товары [1,2,3], потребности [2,2,2]")
	println("Ожидаем: 0 (все покупатели нашли точный товар)")
	println("Получили:", result2)
	println()

	goods3 := []int{1, 4, 6}
	buyerNeeds3 := []int{2, 5, 7}
	result3 := calculateDissatisfaction(goods3, buyerNeeds3)
	println("Тест 3: товары [1,4,6], потребности [2,5,7]")
	println("Ожидаем: 3 (|2-1| + |5-4| + |7-6| = 1+1+1 = 3)")
	println("Получили:", result3)
	println()

	goods4 := []int{10, 20, 30}
	buyerNeeds4 := []int{5, 15, 25, 35}
	result4 := calculateDissatisfaction(goods4, buyerNeeds4)
	println("Тест 4: товары [10,20,30], потребности [5,15,25,35]")
	println("Ожидаем: |5-10| + |15-10| + |25-30| + |35-30| = 5+5+5+5 = 20")
	println("Получили:", result4)
}

```