https://tour.ardanlabs.com/tour/rus/maps/1

Карта - это структура данных, которая обеспечивает поддержку хранения и доступа к данным по ключу. В основе карт лежат хэш-карты и системы корзин, позволяющие использовать непрерывный блок памяти.

## Обзор кода

- **Пример** **1:** Объявление, запись, чтение и удаление
- **Пример** **2:** Отсутствующие ключи
- **Пример** **3:** Ограничения ключа карты
- **Пример** **4:** Литералы карты и итерирование
- **Пример** **5:** Сортировка карты по ключу
- **Пример** **6:** Получение адреса элемента
- **Пример** **7:** Карты - ссылочные типы

## Объявление и создание карт

Объявить и создать карту можно несколькими способами.

```go

type user struct {
    name     string
    username string
}

// Создать карту, установленную в нулевое значение,
// которая может хранить значения типа `user` по ключу типа string.
// Попытка использовать эту карту приведет к ошибке во время выполнения (панике).
var users map[string]user

// Создать карту, инициализированную с помощью функции `make`,
// которая может хранить значения типа `user` по ключу типа string.
users := make(map[string]user)

// Создать карту, инициализированную пустым литералом,
// которая может хранить значения типа `user` по ключу типа string.
users := map[string]user{}

```

Карта, установленная в своё нулевое значение, не может быть использована и приведет к аварийному завершению программы. Использование встроенной функции `make` и литеральной конструкции создает карту, готовую к использованию.

```go

func main() {
    users := make(map[string]user)

    users["Roy"] = user{"Rob", "Roy"}
    users["Ford"] = user{"Henry", "Ford"}
    users["Mouse"] = user{"Mickey", "Mouse"}
    users["Jackson"] = user{"Michael", "Jackson"}

    for key, value := range users {
        fmt.Println(key, value)
    }
}

```

Вывод:

```
Roy {Rob Roy}
Ford {Henry Ford}
Mouse {Mickey Mouse}
Jackson {Michael Jackson}
```


Если встроенная функция make используется для создания карты, оператор присваивания может использоваться для добавления и изменения значений в карте. Порядок возврата ключей/значений при итерировании по карте не определён спецификацией и зависит от компилятора.

```go

func main() {
    users := map[string]user{
        "Roy":     {"Rob", "Roy"},
        "Ford":    {"Henry", "Ford"},
        "Mouse":   {"Mickey", "Mouse"},
        "Jackson": {"Michael", "Jackson"},
    }

    for key, value := range users {
        fmt.Println(key, value)
    }
}

```

Вывод:

```
Ford {Henry Ford}
Jackson {Michael Jackson}
Roy {Rob Roy}
Mouse {Mickey Mouse}
```


В этом случае результат был возвращён в порядке отличном от объявления при инициализации. Текущий алгоритм для версии 1.16 вернет результаты в случайном порядке, как только количество значений достигнет определенного предела. Опять же, это реализация компилятора, которая может измениться. На неё нельзя полагаться.

## Поиск и удаление ключей карты

Для данных хранящихся в карте, извлечение значений выполняется поиском по ключу.

```go

user1, exists1 := users["Bill"]
user2, exists2 := users["Ford"]

fmt.Println("Bill:", exists1, user1)
fmt.Println("Ford:", exists2, user2)

```

Вывод:

```
Bill: false { }
Ford: true {Henry Ford}
```


Для поиска по ключу, используются квадратные скобки следующие за переменной карты. Операция поиска по карте может вернуть два значения: значение и булево значение, указывающее нашлось значение или нет. Если вам этого не нужно знать, вы можете опустить переменную "exists".

Когда ключ в карте не найден, операция возвращает нулевое значение типа карты. В этом можно убедиться при поиске ключа "Bill". Не используйте нулевое значение для определения того, существует ли ключ в карте или нет, поскольку нулевое значение может быть допустимым и фактически храниться в карте для данного ключа.

```go
delete(users, "Roy")
```

Существует встроенная функция delete, которая позволяет удалять данные из карты по ключу.

## Ограничения ключа карты

Не все типы могут использоваться в качестве ключа.

```go
type slice []user
Users := make(map[slice]user)
```


Ошибка компиляции:

```
invalid map key type users
```

Срез является хорошим примером типа, который нельзя использовать в качестве ключа. В качестве ключа могут быть использованы только значения, которые могут пройти через хеш-функцию. Удобный способ для определения типов, которые могут быть ключом - ответить на вопрос, можно ли использовать тип в операции сравнения. Вы не можете сравнивать два значения среза.

## Заметки

- Карты используются для хранения и извлечения пар ключ/значение.
- Чтение отсутствующего ключа возвращает нулевое значение для типа значения карты.
- Итерация по карте всегда происходит в случайном порядке.
- Ключ карты должен быть значением, которое можно сравнивать.
- Элементы в карте не могут быть адресованы.
- Карты - это ссылочный тип.

## Ссылки

- [Карты Go в действии](https://blog.golang.org/go-maps-in-action) - Эндрю Герранд
- [Макро-вид на карты в Go](https://www.ardanlabs.com/blog/2013/12/macro-view-of-map-internals-in-go.html) - Уильям Кеннеди
- [Внутренняя реализация карт](https://www.youtube.com/watch?v=Tl7mi9QmLns) - Кит Рэндалл
- [Как среда выполнения Go эффективно реализует карты (без дженериков)](https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics) - Дейв Чени


```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to initialize a map, write to
// it, then read and delete from it.
package main

import "fmt"

// user represents someone using the program.
type user struct {
	name    string
	surname string
}

func main() {

	// Declare and make a map that stores values
	// of type user with a key of type string.
	users := make(map[string]user)

	// Add key/value pairs to the map.
	users["Roy"] = user{"Rob", "Roy"}
	users["Ford"] = user{"Henry", "Ford"}
	users["Mouse"] = user{"Mickey", "Mouse"}
	users["Jackson"] = user{"Michael", "Jackson"}

	// Read the value at a specific key.
	mouse := users["Mouse"]

	fmt.Printf("%+v\n", mouse)

	// Replace the value at the Mouse key.
	users["Mouse"] = user{"Jerry", "Mouse"}

	// Read the Mouse key again.
	fmt.Printf("%+v\n", users["Mouse"])

	// Delete the value at a specific key.
	delete(users, "Roy")

	// Check the length of the map. There are only 3 elements.
	fmt.Println(len(users))

	// It is safe to delete an absent key.
	delete(users, "Roy")

	fmt.Println("Goodbye.")
}

```


```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how maps behave when you read an
// absent key.
package main

import "fmt"

func main() {

	// Create a map to track scores for players in a game.
	scores := make(map[string]int)

	// Read the element at key "anna". It is absent so we get
	// the zero-value for this map's value type.
	score := scores["anna"]

	fmt.Println("Score:", score)

	// If we need to check for the presence of a key we use
	// a 2 variable assignment. The 2nd variable is a bool.
	score, ok := scores["anna"]

	fmt.Println("Score:", score, "Present:", ok)

	// We can leverage the zero-value behavior to write
	// convenient code like this:
	scores["anna"]++

	// Without this behavior we would have to code in a
	// defensive way like this:
	if n, ok := scores["anna"]; ok {
		scores["anna"] = n + 1
	} else {
		scores["anna"] = 1
	}

	score, ok = scores["anna"]
	fmt.Println("Score:", score, "Present:", ok)
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how only types that can have
// equality defined on them can be a map key.
package main

import "fmt"

// user represents someone using the program.
type user struct {
	name    string
	surname string
}

// users defines a set of users.
type users []user

func main() {

	// Declare and make a map that uses a slice as the key.
	u := make(map[users]int)

	// ./example3.go:22: invalid map key type users

	// Iterate over the map.
	for key, value := range u {
		fmt.Println(key, value)
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to declare, initialize and iterate
// over a map. Shows how iterating over a map is random.
package main

import "fmt"

// user represents someone using the program.
type user struct {
	name    string
	surname string
}

func main() {

	// Declare and initialize the map with values.
	users := map[string]user{
		"Roy":     {"Rob", "Roy"},
		"Ford":    {"Henry", "Ford"},
		"Mouse":   {"Mickey", "Mouse"},
		"Jackson": {"Michael", "Jackson"},
	}

	// Iterate over the map printing each key and value.
	for key, value := range users {
		fmt.Println(key, value)
	}

	fmt.Println()

	// Iterate over the map printing just the keys.
	// Notice the results are different.
	for key := range users {
		fmt.Println(key)
	}
}

```


```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to walk through a map by
// alphabetical key order.
package main

import (
	"fmt"
	"sort"
)

// user represents someone using the program.
type user struct {
	name    string
	surname string
}

func main() {

	// Declare and initialize the map with values.
	users := map[string]user{
		"Roy":     {"Rob", "Roy"},
		"Ford":    {"Henry", "Ford"},
		"Mouse":   {"Mickey", "Mouse"},
		"Jackson": {"Michael", "Jackson"},
	}

	// Pull the keys from the map.
	var keys []string
	for key := range users {
		keys = append(keys, key)
	}

	// Sort the keys alphabetically.
	sort.Strings(keys)

	// Walk through the keys and pull each value from the map.
	for _, key := range keys {
		fmt.Println(key, users[key])
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show that you cannot take the address
// of an element in a map.
package main

// player represents someone playing our game.
type player struct {
	name  string
	score int
}

func main() {

	// Declare a map with initial values using a map literal.
	players := map[string]player{
		"anna":  {"Anna", 42},
		"jacob": {"Jacob", 21},
	}

	// Trying to take the address of a map element fails.
	anna := &players["anna"]
	anna.score++

	// ./example4.go:23:10: cannot take the address of players["anna"]

	// Instead take the element, modify it, and put it back.
	player := players["anna"]
	player.score++
	players["anna"] = player
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how maps are reference types.
package main

import "fmt"

func main() {

	// Initialize a map with values.
	scores := map[string]int{
		"anna":  21,
		"jacob": 12,
	}

	// Pass the map to a function to perform some mutation.
	double(scores, "anna")

	// See the change is visible in our map.
	fmt.Println("Score:", scores["anna"])
}

// double finds the score for a specific player and
// multiplies it by 2.
func double(scores map[string]int, player string) {
	scores[player] = scores[player] * 2
}

```