https://tour.ardanlabs.com/tour/rus/interfaces/1

Интерфейсы придают программам структуру и поощряют дизайн на основе композиции. Они дают возможность провести аккуратную разделительную черту между различными компонентами. Стандартизация интерфейсов позволяет объявлять чёткие структурированные ожидания. Разделение ведёт к уменьшению взаимозависимостей между компонентами и типами данных, которые эти компоненты используют. Это ведёт к корректности, повышению качества и улучшению поддерживаемости ПО.

## Обзор кода

- **Пример** **1:** Повторяющийся код, требующий полиморфизма
- **Пример** **2:** Полиморфизм
- **Пример** **3:** Наборы методов
- **Пример** **4:** Адрес значения
- **Пример** **5:** Хранение по значению
- **Пример** **6:** Декларации типов
- **Пример** **7:** Условные декларации типов
- **Пример** **8:** Пустой интерфейс и выбор типа
- **Пример** **9:** Хранение значений

## Семантика интерфейса

Интерфейсы позволяют группировать конкретные данные вместе по тому общему, что эти данные могут делать. Т.е. мы фокусируемся на том, что данные могут делать, а не на том, что это данные из себя представляют. Интерфейсы также помогают снизить связанность кода, работая с данными на основе того что они могут делать. Это не ограничивается одним единственным типом данных.

Вам нужно постараться понять, какие ожидаются изменения данных, и с помощью интерфейсов снизить связанность программного код с этими изменений. Интерфейсы должны описывать поведение, а не состояние. Они должны быть глаголами, а не существительными.

Наилучший выбор - это обобщённые интерфейсы, которые фокусируются на поведении. Интерфейсы с более чем одним методом имеют больше причин для изменения. Интерфейсы, основанные на существительных, обычно сложнее использовать повторно, они больше подвержены изменениям и противоречат основному назначению интерфейсов. Неопределенность в части ожидаемых изменений - это не повод строить догадки, а указатель на необходимость остановиться и узнать больше. Вам следует различать код защищающий от мошенничества, и код, защищающий от несчастных случаев.

Используйте интерфейс, когда:

- Пользователи API должны предоставить подробности реализации.
- У API есть несколько реализаций, которые необходимо поддерживать внутренее.
- Вы обнаружили части API, которые могут измениться, и хотите их развязать.

Не используйте интерфейс:

- Просто ради использования интерфейса.
- Для обобщения алгоритма.
- Когда пользователи могут объявить свои собственные интерфейсы.
- Если не ясно, как интерфейс улучшает код.

## Интерфейсы не работают со значениям

Первый важный момент который необходимо понять - это то, что интерфейсы объявляют тип, который не работает со значением.

```go
type reader interface {
    read(b []byte) (int, error)
}
```


Тип reader является не типом struct, а типом interface. Его объявление основано не на состоянии, а на поведении. Интерфейсы объявляют набор методов поведения, которое конкретные данные должны продемонстрировать для удовлетворения интерфейса. В типах interface нет ничего конкретного, поэтому они сами по себе не работают со значениями.

```go
var r reader
```

Поскольку они не работают со значениями, создание переменной (такой как r) несколько необычно, потому что в нашей модели программирования r не существует, она не представляет собой значение. В r нет ничего, чем вы можете манипулировать или преобразовать. Это критическая концепция, которую следует понять. Я никогда не работаю со значениями интерфейса, только с конкретными значениями. Интерфейс имеет представление для компилятора (внутренний тип), но с точки зрения нашей модели программирования интерфейсы не содержат значения.

## Реализация интерфейсов

Go - это язык, в котором конвенции более важны чем конфигурация. Это остаётся верным и в случае когда конкретный тип реализует интерфейс.

```go
type reader interface {
    read(b []byte) (int, error)
}

type file struct {
    name string
}

func (file) read(b []byte) (int, error) {
    s := "<rss><channel><title>Going Go</title></channel></rss>"
    copy(b, s)
    return len(s), nil
}
```

Этот код объявляет тип с именем file, а затем объявляет метод с именем read. На основе этих двух объявлений можно сказать следующее:

"Теперь конкретный тип file реализует интерфейс reader с использованием семантики значения"

Каждое сказанное выше слово важно. В Go все, что вам нужно сделать - это объявить полный набор методов поведения, определенных интерфейсом, чтобы реализовать этот интерфейс. В данном случае именно это я сделал, так как интерфейс reader объявляет только одно действие поведения с именем read.

```go
type reader interface {
    read(b []byte) (int, error)
}

type pipe struct {
    name string
}

func (pipe) read(b []byte) (int, error) {
    s := `{name: "Bill", title: "developer"}`
    copy(b, s)
    return len(s), nil
}
```


Этот код объявляет тип с именем pipe, а затем объявляет метод с именем read. Основываясь на этих двух объявлениях можно сказать следующее:

"Теперь конкретный тип pipe реализует интерфейс reader с использованием семантики значения"

Теперь у вас есть два конкретных типа, реализующих интерфейс reader. Два конкретных типа, каждый со своей уникальной реализацией. Один тип читает файловые системы, а другой - сети.

## Полиморфизм

Полиморфизм означает, что фрагмент кода изменяет свое поведение в зависимости от конкретных данных, с которыми он работает. Это было сказано Томом Курцем, изобретателем BASIC. Это определение мы будем использовать впредь.

```go
// retrieve может читать любое устройство и обрабатывать данные.
func retrieve(r reader) error {
    data := make([]byte, 100)

    len, err := r.read(data)
    if err != nil {
        return err
    }

    fmt.Println(string(data[:len]))
    return nil
}
```


Посмотрите на тип данных, который принимает эта функция. Она ожидает значение типа reader. Это невозможно, так как reader - это интерфейс, а интерфейсы - это типы не содержащие данных. Невозможно запросить значения reader, так как его не существует.

Если функция не запрашивает значения reader, то что она запрашивает? Она запрашивает единственное, что она может запросить - конкретные данные.

Функция retrieve - полиморфная функция, потому что она запрашивает конкретные данные не на основе того, что это за данные (конкретный тип), а на основе того, что эти данные могут делать (тип интерфейса).

```go
f := file{"data.json"}
p := pipe{"cfg_service"}

retrieve(f)
retrieve(p)
```


Мы можем создать два конкретных значения, одно типа file, а другое - типа pipe. Затем можно передать копию каждого значения в полиморфную функцию. Это возможно, поскольку каждое из этих значений реализует полный набор методов поведения, определенных интерфейсом reader.

Когда конкретное значение file передается в retrieve, значение сохраняется во внутреннем типе состоящем из 2х слов и представляющем значением интерфейса.

[![](https://tour.ardanlabs.com/tour/rus/static/img/i1.png)](https://tour.ardanlabs.com/tour/rus/static/img/i1.png)

Второе слово интерфейса указывает на хранимое значение. В данном случае это копия значения file, поскольку используются семантики значения. Первое слово указывает на особую структуру данных, которая называется iTable.

iTable выполняет 2 функции:

- Она описывает тип хранимого значения. В нашем случае это значение file.
- Она даёт доступ к указателям на набор методов реализованные для типа хранимого значения.

Когда вызывается метод read для значения интерфейса, выполняется поиск по iTable, чтобы найти конкретную реализацию метода read, связанную с типом. Затем вызывается метод принадлежащий значению, хранящемуся во втором слове.

Можно сказать, что retrieve - это полиморфная функция, потому что конкретное значение pipe может быть передано в retrieve, после чего вызов метода read для значения интерфейса изменяет свое поведение. Теперь вызов read читает сеть вместо чтения файла.

## Правила набора методов

Реализация интерфейса с использованием семантики указателя накладывает некоторые требования связанные с соблюдением интерфейса.

```go
type notifier interface {
    notify()
}

type user struct {
    name  string
    email string
}

func (u *user) notify() {
    fmt.Printf("Sending User Email To %s<%s>\n", u.name, u.email)
}

func sendNotification(n notifier) {
    n.notify()
}

func main() {
    u := user{"Bill", "bill@email.com"}
    sendNotification(u)
}

```

Интерфейс "notifier" реализован типом "user" с использованием семантики указателя. Когда для создания полиморфного вызова используются семантики значения, компилятор выдает следующее сообщение об ошибке:

```
"cannot use u (type user) as type notifier in argument to sendNotification:
user does not implement notifier (notify method has pointer receiver)"
```


Это связано с тем, что в спецификации есть особые правила относительно наборов методов. Эти правила определяют, какие методы присоединены к значениям, а какие - к указателям типа, и они существуют для поддержания высшего уровня целостности в программе.

Вот правила, определенные в спецификации:

- Для любого **значения** типа T в набор методов этого значения входят только те методы, которые реализованы с **получаетелем-значением** для этого типа.
- Для любого **адреса** типа T в набор методов этого значения входят *все методы*, реализованные для этого типа.

Другими словами, при работе с адресом (указателем) все реализованные методы присоединены и доступны для вызова. При работе со значением присоединены и доступны только те методы, которые реализованы с получателем-значением.

В предыдущем уроке о методах мы могли вызывать метод для конкретных данных, независимо от семантики данных, объявленной получателем. Это потому, что компилятор может адаптироваться для выполнения вызова. В этом случае значение хранится внутри интерфейса, и методы должны существовать. Никаких адаптаций делать нельзя.

Теперь встает вопрос: почему нельзя присоединять методы с получателем-указателем к значениям типа T? В чем заключается проблема с целостностью?

Одна из причин заключается в том, что нельзя гарантировать, что каждое значение типа T будет иметь адрес. Если у значения нет адреса, его нельзя передавать по ссылке.

```go
type duration int

func (d *duration) notify() {
        fmt.Println("Sending Notification in", *d)
}

func main() {
    duration(42).notify()
}
```


Ошибка компилятора:

cannot call pointer method on duration(42)
cannot take the address of duration(42)

В этом примере значение 42 является константой типа int. Несмотря на то, что значение преобразуется в значение типа duration, оно не хранится в переменной. Это означает, что значение никогда не находится в стеке или куче, и у него нет адреса. Константы существуют только на этапе компиляции.

Вторая причина - ещё более важная. Компилятор говорит вам, что вы не можете использовать семантику значения, если вы выбрали семантику указателя. Другими словами, вас заставляют совместно использовать значение с интерфейсом, поскольку создать копию значения, на которое указывает указатель, не безопасно. Если вы выбрали реализацию метода с семантикой указателя, вы показываете, что значение этого типа не безопасно копировать.

```go
func main() {
    u := user{"Bill", "bill@email.com"}
    sendNotification(&u)
}
```


Чтобы устранить сообщение компилятора, необходимо при вызове полиморфной функции использовать семантику указателя и передавать указатель на u. Ответ не заключается в изменении метода для использования семантики значения.

## Срез Интерфейсов

При объявлении среза типа interface мы можем группировать разные конкретные значения основываясь на их поведении. Вот почему в Go не нужна концепция подтипов. Речь идет не об общем ДНК, а об общем поведении.

```go
type printer interface {
    print()
}

type canon struct {
    name string
}

func (c canon) print() {
        fmt.Printf("Printer Name: %s\n", c.name)
}

type epson struct {
    name string
}

func (e *epson) print() {
        fmt.Printf("Printer Name: %s\n", e.name)
}

func main() {
    c := canon{"PIXMA TR4520"}
    e := epson{"WorkForce Pro WF-3720"}

        printers := []printer{
        c,
        &e,
    }
    c.name = "PROGRAF PRO-1000"
    e.name = "Home XP-4100"

        for _, p := range printers {
        p.print()
    }
}
```


Output:

Printer Name: PIXMA TR4520
Printer Name: Home XP-4100

Код показывает, как срез интерфейсного типа printer позволяет создавать коллекцию различных конкретных типов printer. Это позволяет итерировать по коллекции и использовать полиморфизм, так как вызов p.print меняет свое поведение в зависимости от конкретного значения, с которым работает код.

Пример также показывает, как выбор семантики данных изменяет поведение программы. При хранении данных с использованием семантики значения, изменения в исходном значении не видны. Это потому, что копия сохраняется внутри интерфейса. При использовании семантики указателя любые изменения в исходном значении видны.

## Заметки

- Набор методов для значения включает только методы, реализованные с получателем-значением.
- Набор методов для указателя включает методы, реализованные как с получателем-указателем, так и с получателем-значением.
- Методы, объявленные с получателем-указателем, реализуют интерфейс только с указателями.
- Методы, объявленные с получателем-значением, реализуют интерфейс как с получателем-значением, так и с получателем-указателем.
- Правила наборов методов применяются к интерфейсам.
- Интерфейсы - это ссылочные типы, не используйте указатели на них.
- Интерфейсы - это то, каким образом создаётся полиморфное поведение в Go.

## Цитаты

"Полиморфизм означает, что вы пишете определённую программу, и она ведет себя по-разному в зависимости от данных, с которыми она работает." - Том Курц (изобретатель BASIC)

"Пустой интерфейс не говорит ни о чем." - Роб Пайк

"Проектирование - это искусство устройства кода таким, чтобы он работал сегодня и был изменяемым навсегда." - Санди Метц

"Правильная абстракция развязывает код, чтобы каждое изменение не разносилось эхом по всей кодовой базе." - Ронна Штейнберг

## Дополнительное чтение

- [Интерфейсы](https://golang.org/doc/effective_go.html#interfaces)
- [Законы рефлексии](https://blog.golang.org/laws-of-reflection) - Роб Пайк
- [Методы, интерфейсы и встроенные типы Go](https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html) - Уильям Кеннеди
- [Загрязнение интерфейсов](https://rakyll.org/interface-pollution/) - JBD
- [Абстракции считаются вредными](https://bravenewgeek.com/abstraction-considered-harmful/) - Тайлер Трит
- [Интерфейсы не содержат значений](https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html) - Уильям Кеннеди
- [Семантика интерфейса](https://www.ardanlabs.com/blog/2017/07/interface-semantics.html) - Уильям Кеннеди
- [Закон Хайрума](https://www.hyrumslaw.com/) - Хайрум
- [Инженерное нововведение - почему ограничения критичны](https://www.youtube.com/watch?v=Pjz9WrXeOW0) - Андре Эрикссон (ОБЯЗАТЕЛЬНО ПОСМОТРИТЕ)

1
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program that could benefit from polymorphic behavior with interfaces.
package main

import "fmt"

// file defines a system file.
type file struct {
	name string
}

// read implements the reader interface for a file.
func (file) read(b []byte) (int, error) {
	s := "<rss><channel><title>Going Go Programming</title></channel></rss>"
	copy(b, s)
	return len(s), nil
}

// pipe defines a named pipe network connection.
type pipe struct {
	name string
}

// read implements the reader interface for a network connection.
func (pipe) read(b []byte) (int, error) {
	s := `{name: "bill", title: "developer"}`
	copy(b, s)
	return len(s), nil
}

func main() {

	// Create two values one of type file and one of type pipe.
	f := file{"data.json"}
	p := pipe{"cfg_service"}

	// Call each retrieve function for each concrete type.
	retrieveFile(f)
	retrievePipe(p)
}

// retrieveFile can read from a file and process the data.
func retrieveFile(f file) error {
	data := make([]byte, 100)

	len, err := f.read(data)
	if err != nil {
		return err
	}

	fmt.Println(string(data[:len]))
	return nil
}

// retrievePipe can read from a pipe and process the data.
func retrievePipe(p pipe) error {
	data := make([]byte, 100)

	len, err := p.read(data)
	if err != nil {
		return err
	}

	fmt.Println(string(data[:len]))
	return nil
}

```

2

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how polymorphic behavior with interfaces.
package main

import "fmt"

// reader is an interface that defines the act of reading data.
type reader interface {
	read(b []byte) (int, error)
}

// file defines a system file.
type file struct {
	name string
}

// read implements the reader interface for a file.
func (file) read(b []byte) (int, error) {
	s := "<rss><channel><title>Going Go Programming</title></channel></rss>"
	copy(b, s)
	return len(s), nil
}

// pipe defines a named pipe network connection.
type pipe struct {
	name string
}

// read implements the reader interface for a network connection.
func (pipe) read(b []byte) (int, error) {
	s := `{name: "bill", title: "developer"}`
	copy(b, s)
	return len(s), nil
}

func main() {

	// Create two values one of type file and one of type pipe.
	f := file{"data.json"}
	p := pipe{"cfg_service"}

	// Call the retrieve function for each concrete type.
	retrieve(f)
	retrieve(p)
}

// retrieve can read any device and process the data.
func retrieve(r reader) error {
	data := make([]byte, 100)

	len, err := r.read(data)
	if err != nil {
		return err
	}

	fmt.Println(string(data[:len]))
	return nil
}

```

3
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to understand method sets.
package main

import "fmt"

// notifier is an interface that defines notification
// type behavior.
type notifier interface {
	notify()
}

// user defines a user in the program.
type user struct {
	name  string
	email string
}

// notify implements the notifier interface with a pointer receiver.
func (u *user) notify() {
	fmt.Printf("Sending User Email To %s<%s>\n",
		u.name,
		u.email)
}

func main() {

	// Create a value of type User and send a notification.
	u := user{"Bill", "bill@email.com"}

	// Values of type user do not implement the interface because pointer
	// receivers don't belong to the method set of a value.

	sendNotification(u)

	// ./example1.go:36: cannot use u (type user) as type notifier in argument to sendNotification:
	//   user does not implement notifier (notify method has pointer receiver)
}

// sendNotification accepts values that implement the notifier
// interface and sends notifications.
func sendNotification(n notifier) {
	n.notify()
}

```

4
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how you can't always get the address of a value.
package main

import "fmt"

// duration is a named type with a base type of int.
type duration int

// notify implements the notifier interface.
func (d *duration) notify() {
	fmt.Println("Sending Notification in", *d)
}

func main() {
	duration(42).notify()

	// ./example3.go:18: cannot call pointer method on duration(42)
	// ./example3.go:18: cannot take the address of duration(42)
}

```

5 
```GO
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how the concrete value assigned to
// the interface is what is stored inside the interface.
package main

import "fmt"

// printer displays information.
type printer interface {
	print()
}

// cannon defines a cannon printer.
type cannon struct {
	name string
}

// print displays the printer's name.
func (c cannon) print() {
	fmt.Printf("Printer Name: %s\n", c.name)
}

// epson defines a epson printer.
type epson struct {
	name string
}

// print displays the printer's name.
func (e *epson) print() {
	fmt.Printf("Printer Name: %s\n", e.name)
}

func main() {

	// Create a cannon and epson printer.
	c := cannon{"PIXMA TR4520"}
	e := epson{"WorkForce Pro WF-3720"}

	// Add the printers to the collection using both
	// value and pointer semantics.
	printers := []printer{

		// Store a copy of the cannon printer value.
		c,

		// Store a copy of the epson printer value's address.
		&e,
	}

	// Change the name field for both printers.
	c.name = "PROGRAF PRO-1000"
	e.name = "Home XP-4100"

	// Iterate over the slice of printers and call
	// print against the copied interface value.
	for _, p := range printers {
		p.print()
	}

	// When we store a value, the interface value has its own
	// copy of the value. Changes to the original value will
	// not be seen.

	// When we store a pointer, the interface value has its own
	// copy of the address. Changes to the original value will
	// be seen.
}

```

6

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the syntax of type assertions.
package main

import (
	"fmt"
	"log"
)

// user defines a user in our application.
type user struct {
	id   int
	name string
}

// finder represents the ability to find users.
type finder interface {
	find(id int) (*user, error)
}

// userSVC is a service for dealing with users.
type userSVC struct {
	host string
}

// find implements the finder interface using pointer semantics.
func (*userSVC) find(id int) (*user, error) {
	return &user{id: id, name: "Anna Walker"}, nil
}

func main() {
	svc := userSVC{
		host: "localhost:3434",
	}

	if err := run(&svc); err != nil {
		log.Fatal(err)
	}
}

// run performs the find operation against the concrete data that
// is passed into the call.
func run(f finder) error {
	u, err := f.find(1234)
	if err != nil {
		return err
	}
	fmt.Printf("Found user %+v\n", u)

	// Ideally the finder abstraction would encompass all of
	// the behavior you care about. But what if, for some reason,
	// you really need to get to the concrete value stored inside
	// the interface?

	// Can you access the "host" field from the concrete userSVC type pointer
	// that is stored inside this interface variable? No, not directly.
	// All you know is the data has a method named "find".
	// ./example5.go:61:26: f.host undefined (type finder has no field or method host)
	log.Println("queried", f.host)

	// You can use a type assertion to get a copy of the userSVC pointer
	// that is stored inside the interface.
	svc := f.(*userSVC)
	log.Println("queried", svc.host)

	return nil
}

```

7

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show type assertions using the comma-ok idiom.
package main

import (
	"fmt"
	"log"
)

// user defines a user in our application.
type user struct {
	id   int
	name string
}

// finder represents the ability to find users.
type finder interface {
	find(id int) (*user, error)
}

// userSVC is a service for dealing with users.
type userSVC struct {
	host string
}

// find implements the finder interface using pointer semantics.
func (*userSVC) find(id int) (*user, error) {
	return &user{id: id, name: "Anna Walker"}, nil
}

// mockSVC defines a mock service we will access.
type mockSVC struct{}

// find implements the finder interface using pointer semantics.
func (*mockSVC) find(id int) (*user, error) {
	return &user{id: id, name: "Jacob Walker"}, nil
}

func main() {
	var svc mockSVC

	if err := run(&svc); err != nil {
		log.Fatal(err)
	}
}

func run(f finder) error {
	u, err := f.find(1234)
	if err != nil {
		return err
	}
	fmt.Printf("Found user %+v\n", u)

	// If the concrete type value stored inside the interface value is of the
	// type *userSVC, then "ok" will be true and "svc" will be a copy of the
	// pointer stored inside the interface.
	if svc, ok := f.(*userSVC); ok {
		log.Println("queried", svc.host)
	}

	return nil
}

```

8
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the syntax and mechanics of type
// switches and the empty interface.
package main

import "fmt"

func main() {

	// fmt.Println can be called with values of any type.
	fmt.Println("Hello, world")
	fmt.Println(12345)
	fmt.Println(3.14159)
	fmt.Println(true)

	// How can we do the same?
	myPrintln("Hello, world")
	myPrintln(12345)
	myPrintln(3.14159)
	myPrintln(true)

	// - An interface is satisfied by any piece of data when the data exhibits
	// the full method set of behavior defined by the interface.
	// - The empty interface defines no method set of behavior and therefore
	// requires no method by the data being stored.

	// - The empty interface says nothing about the data stored inside
	// the interface.
	// - Checks would need to be performed at runtime to know anything about
	// the data stored in the empty interface.
	// - Decouple around well defined behavior and only use the empty
	// interface as an exception when it is reasonable and practical to do so.
}

func myPrintln(a interface{}) {
	switch v := a.(type) {
	case string:
		fmt.Printf("Is string  : type(%T) : value(%s)\n", v, v)
	case int:
		fmt.Printf("Is int     : type(%T) : value(%d)\n", v, v)
	case float64:
		fmt.Printf("Is float64 : type(%T) : value(%f)\n", v, v)
	default:
		fmt.Printf("Is unknown : type(%T) : value(%v)\n", v, v)
	}
}

```