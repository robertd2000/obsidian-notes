https://tour.ardanlabs.com/tour/rus/arrays/1

Массив - это специальная структура данных в Go, позволяющая выделить непрерывный блок памяти фиксированного размера. У Go массивов есть особенности в том как они объявляются и как рассматривается их тип.

## Обзор Кода

- **Пример** **1:** Объявление, инициализация и итерация
- **Пример** **2:** Массивы разных типов
- **Пример** **3:** Выделение непрерывной памяти
- **Пример** **4:** Механика инструкции `range`

## Объявление и инициализация значений

Объявите массив из пяти строк, инициализированный в состоянии нулевого значения.

var strings [5]string

Строка - это неизменяемая структура данных состоящая из двух частей (слов) - указатель на буфер байтов и количество байтов в этом буфере. Поскольку этот массив установлен в состояние нулевого значения, каждый его элемент устанавливается в состояние нулевого значения. Это означает, что каждая строка имеет первое слово, установленное в nil, и второе слово, установленное в 0.

[![](https://tour.ardanlabs.com/tour/eng/static/img/a1.png)](https://tour.ardanlabs.com/tour/eng/static/img/a1.png)

## Присваивание строк

Что происходит, когда одной строке присваивается другая строка?

strings[0] = "Apple"

Когда одной строке присваивается другая строка, копируются два слова, что приводит к двум разным строковым значениям, использующим один и тот же буфер байтов.

[![](https://tour.ardanlabs.com/tour/eng/static/img/a2.png)](https://tour.ardanlabs.com/tour/eng/static/img/a2.png)

Стоимость копирования строки одинакова вне независимости от размера строки - это копирование двух слов.

## Итерация по коллекциям

Go предоставляет две разные семантики для итерации по коллекции. Можно итерировать, используя семантику значений или семантику указателей.

// Итерация с семантикой значений
for i, fruit := range strings {
    println(i, fruit)
}


// Итерация с семантикой указателей
for i := range strings {
    println(i, strings[i])
}

При использовании итерации с семантикой значений происходят две вещи. Во-первых, коллекция, по которой производится итерация, копируется, и вы итерируете по этой копии. В случае массива - копирование может быть дорогостоящим, так как копируется весь массив. В случае среза, реальной стоимости нет, так как копируется только внутреннее значение среза, а не базовый массив. Во-вторых, вы получаете копию каждого элемента, по которому выполняется итерация.

При использовании итерации с семантикой указателей вы итерируете по исходной коллекции, и вы можете получить доступ к каждому элементу этой коллекции напрямую.

## Итерация с семантикой значений

Рассмотрите следующий код и вывод.

strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
for i, fruit := range strings {
    println(i, fruit)
}

Вывод:

0 Apple
1 Orange
2 Banana
3 Grape
4 Plum

Переменная strings - это массив из 5 строк. Цикл выполняет итерацию по каждой строке в коллекции и отображает позицию индекса и значение строки. Поскольку это итерация с семантикой значений, цикл for range выполняет итерацию по своей собственной поверхностной копии массива, и на каждой итерации переменная fruit - это копия каждой строки (структуры данных из двух слов).

Обратите внимание, что переменная fruit передается в функцию печати, используя семантику значений. Функция print также получает свою собственную копию строки. К моменту передачи строки в функцию печати существуют 4 копии значения строки (массив, поверхностная копия, переменная fruit и собственная копия функции печати). Все 4 копии ссылаются на один и тот же базовый массив байтов.

[![](https://tour.ardanlabs.com/tour/eng/static/img/a3.png)](https://tour.ardanlabs.com/tour/eng/static/img/a3.png)

Создание копий значений строки важно, потому что это предотвращает утечку значения строки в кучу. Это устраняет не продуктивное выделение памяти в куче.

## Итерация с семантикой указателей

Рассмотрите следующий код и вывод.

strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
for i := range strings {
    println(i, strings[i])
}

Вывод:

0 Apple
1 Orange
2 Banana
3 Grape
4 Plum

Опять же, переменная strings - это массив из 5 строк. Цикл выполняет итерацию по каждой строке в коллекции, по ходу отображая позицию индекса и значение строки. Поскольку это итерация с семантикой указателей, цикл for range выполняет итерацию по массиву напрямую, и на каждой итерации значение строки для индекса извлекается непосредственно при вызове функции печати.

## Массивы разных типов

Обратите внимание какую ошибку выдаёт компилятор при попытке присвоения массивов одного и того же типа элементов, но разной длины.

var five [5]int
four := [4]int{10, 20, 30, 40}

five = four

Ошибка компиляции:

cannot use four (type [4]int) as type [5]int in assignment

Здесь вы объявляете массивы из 4 и 5 целых чисел, инициализированные своими нулевыми значениями. Затем пытаетесь присвоить их друг другу, и компилятор говорит: "нельзя использовать четыре (type [4]int) в качестве [5]int при присваивании".

Важно понимать, что говорит компилятор. Он говорит, что массив из 4 целых чисел и массив из 5 целых чисел представляют данные разных типов. Размер массива - это часть информации о его типе. В Go размер массива должен быть известен на этапе компиляции.

## Выделение непрерывной памяти

Давайте убедимся, что под массив выделяется непрерывный фрагмент памяти.

five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

for i, v := range five {
    fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
        v, &v, &five[i])
}

Вывод:

Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

Здесь вы объявляете массив из 5 строк, инициализированный значениями. Затем, используя итерацию с семантикой значений, отображаете информации о каждой строке. Вывод показывает каждое индивидуальное строковое значение, адрес переменной v и адрес каждого элемента массива.

Вы можете убедиться, что массив представляет собой непрерывный блок памяти, и строка - это структура данных из двух слов или 16 байтов на 64-битной архитектуре. Адрес каждого элемента находится на расстоянии 16 байт от предыдущего.

Тот факт, что переменная v имеет одинаковый адрес на каждой итерации, доказывает, что v - это локальная переменная типа string, которая содержит копию значения каждой строки во время итерации.

## Кэши ЦП

В конструкции различных процессоров существует множество отличий. В этом разделе мы, с высоты птичьего полёта, поговорим о процессорах и семантике, которая относительно одинакова между ними. Это понимание семантики даст вам хорошую картину того, как работает процессор, и какую механическую симпатию вы можете использовать.

Каждое ядро внутри процессора имеет свой собственный локальный кэш памяти (L1 и L2) и общий кэш памяти (L3), используемый для хранения и доступа к данным и инструкциям. Аппаратные потоки в каждом ядре могут получать доступ к своим локальным кэшам L1 и L2. Данные из L3 или основной памяти должны быть предварительно скопированы в кэш L1 или L2.

[![](https://tour.ardanlabs.com/tour/eng/static/img/a4.png)](https://tour.ardanlabs.com/tour/eng/static/img/a4.png)

Задержки доступа к данным, которые находятся в разных кэшах, меняются от наименьших к наибольшим: L1 -> L2 -> L3 -> основная память. Как сказал Скотт Мейерс: "Если производительность имеет значение, то общее количество памяти в вашем распоряжении - это общее количество кэша. Доступ к основной памяти так медленен, что её, фактически, можно не рассматривать."

Производительность сегодня зависит от того, насколько эффективно данные перемещаются через аппаратуру. Если каждый фрагмент данных, нужный для работы (в любой момент времени), существует только в основной памяти, мои программы будут выполняться медленнее по сравнению с тем, когда данные уже присутствуют в кэшах L1 или L2.

3 ГГц (3 такта/нс) * 4 инструкции за такт = 12 инструкций/нс!

1 нс .............. 1 нс .............. 12 инструкций (одна)
1 мкс ......... 1,000 нс .......... 12,000 инструкций (тысяча)
1 мс ...... 1,000,000 нс ...... 12,000,000 инструкций (миллион)
1 с ... 1,000,000,000 нс .. 12,000,000,000 инструкций (миллиард)

Уровни задержек принятые в индустрии
Ссылка L1-кэша ......................... 0,5 нс ...................  6 инс
Ссылка L2-кэша ........................... 7 нс ................... 84 инс
Ссылка на основную память .............. 100 нс ................. 1200 инс

Как написать код, который гарантирует, что данные, необходимые для выполнения инструкции, всегда присутствуют в кэшах L1 или L2? Вам нужно написать код, который механически симпатичен предварительной подгрузке данных процессора. Предварительная подгрузка данных пытается предсказать, какие данные потребуются для инструкций, до того как они запросят данные, так чтобы они уже присутствовали в кэшах L1 или L2.

Существуют разные гранулярности доступа к памяти в зависимости от того, где происходит доступ. Мой код может читать/записывать байт памяти как минимальную единицу доступа к памяти. Однако с точки зрения систем кэширования, гранулярность составляет 64 байта. Этот блок памяти в 64 байта называется кэш-строкой.

Предварительная подгрузка данных работает лучше, когда выполняемые инструкции создают предсказуемые шаблоны доступа к памяти. Один из способов создания предсказуемого доступа к памяти - это создание непрерывного блока памяти и последующая итерация по этой памяти, выполняя линейное обращение с предсказуемым шагом.

Массив - это наиболее важная структура данных для аппаратуры, потому что он поддерживает предсказуемые шаблоны доступа к памяти. Однако срез - наиболее важная структура данных в Go. Срезы в Go построены на основании массивов.

После создания массива, каждый элемент равноудален от следующего или предыдущего элемента. При итерации по массиву начинается обход кэш-строка за кэш-строкой с предсказуемым шагом. Предварительная подгрузка данных будет вылавливать этот предсказуемый шаблон доступа к данным и начнет эффективно копировать данные в процессор, тем самым снижая задержку доступа к данным.

Представьте себе большую квадратную матрицу памяти и связный список элементов, которые соответствуют количеству элементов в матрице. Если вы выполняете обход связного списка, а затем обход матрицы в обоих направлениях (по колонкам и строкам), какова будет производительность разных способов обхода?

func RowTraverse() int {
    var ctr int
    for row := 0; row < rows; row++ {
        for col := 0; col < cols; col++ {
            if matrix[row][col] == 0xFF {
                ctr++
            }
        }
    }
    return ctr
}

Обход строк будет иметь наилучшую производительность, потому что он проходит через память, кэш-строка за кэш-строкой, что создает предсказуемый шаблон доступа к памяти. Кэш-строки могут быть предварительно загружены и скопированы в кэш L1 или L2, прежде чем данные потребуются.

func ColumnTraverse() int {
    var ctr int
    for col := 0; col < cols; col++ {
        for row := 0; row < rows; row++ {
            if matrix[row][col] == 0xFF {
                ctr++
            }
        }
    }
    return ctr
}

Производительность при обходе по столбцам будет на порядок хуже, потому что этот шаблон доступа пересекает границы страниц ОС при каждом доступе к памяти. Это приводит к непредсказуемости загрузки кэш-строк и фактически приравнивается к случайному доступу к памяти.

func LinkedListTraverse() int {
    var ctr int
    d := list
    for d != nil {
        if d.v == 0xFF {
            ctr++
        }
        d = d.p
    }
    return ctr
}

Связный список вдвое медленнее по сравнению с обходом по строкам в основном из-за промахов кэш-строк, но с меньшим числом промахов БДТ (буфера динамической трансляции). Большая часть узлов в связном списке, находится в одних и тех же страницах операционной системы.

BenchmarkLinkListTraverse-16    128      28738407 нс/оп
BenchmarkColumnTraverse-16       30     126878630 нс/оп
BenchmarkRowTraverse-16         310      11060883 нс/оп

## Буфер Динамической Трансляции (БДТ)

Каждой работающей программе предоставляется полная карта виртуальной памяти операционной системы, и эта работающая программа думает, что в её распоряжении находится вся физическая память компьютера. Однако физическая память должна быть разделена между всеми работающими программами. Операционная система распределяет физическую память, посредством разделения физической памяти на страницы и сопоставления этих страниц с виртуальной памятью выделенной для каждой работающей программы. Каждая операционная система может выбирать размер страницы, но разумными и распространенными размерами являются 4K, 8K, 16K.

Буфер Динамической Трансляции (БДТ) - это небольшой кэш внутри процессора, который помогает уменьшить задержки при трансляции виртуального адреса в физический (в пределах страницы операционной системы и смещения внутри страницы). Промах по кэшу БДТ может привести к существенным задержкам, потому что теперь железо вынуждено ждать, пока операционная система просмотрит свою таблицу страниц, чтобы найти нужную страницу для соответствующего виртуального адреса. Если программа работает на виртуальной машине (например в облаке), то сначала нужно просмотреть таблицу страниц виртуальной машины.

Помните, что было сказано:

Связный список вдвое медленнее, чем обход по строкам, в основном из-за промахов кэш-строк, но с меньшим числом промахов БДТ (смотри ниже). Большая часть узлов в связаном списке, находится в одних и тех же страницах операционной системы.

Связный список обрабатывается на порядок быстрее столбцового обхода благодаря доступу к БДТ. Поскольку большая часть памяти узлов попадает в одну и ту же страницу, даже несмотря на промахи по кэш-строкам при обходе связного списка, задержки БДТ не сильно влияют на производительность. По этой причине для программ, которые используют большое количество памяти, например, приложений обрабатывающих ДНК, можно рассмотреть использование дистрибутива Linux, сконфигурированного под размеры страниц порядка мегабайта или двух мегабайт памяти.

Все сказанное подчеркивает важность дизайна ориентированного-на-данные. Написание эффективного алгоритма должно учитывать, как происходит доступ к данным. Помните, что сегодня производительность зависит от того, насколько эффективно вы можете передать данные в процессор.

- [Кэши процессора и почему они важны (18:50-20:30)](https://youtu.be/WDIkqP4JbkE?t=1129) - Скотт Майерс
- [Кэши процессора и почему они важны (44:36-45:40)](https://youtu.be/WDIkqP4JbkE?t=2676) - Скотт Майерс
- [Производительность через дружелюбность к кэшу (4:25-5:48)](https://youtu.be/jEG4Qyo_4Bc?t=266) - Дэмиан Гриски

## Заметки о кэше процессора

- Кэши процессора работают путем кэширования основной памяти в кэши-строки.
- Сегодня кэш-строки имеют ширину 32 или 64 байта в зависимости от оборудования.
- Ядра ЦП не обращаются к основной памяти напрямую. Они, как правило, обращаются только к своим локальным кэшам.
- В кэшах хранятся как данные, так и инструкции.
- Кэш-строки перемещаются с L1 в L2, а затем в L3, по мере необходимости кэширования новых кэш-строк.
- Оборудование предпочитает линейное перемещение данных и инструкций вдоль кэш-строк.
- Основная память построена на относительно быстрой и дешевой памяти. Кэши построены на очень быстрой и дорогой памяти.
    
- Доступ к основной памяти чрезвычайно медленный, поэтому нам нужен кэш.
    
    - Чтение одного байта из основной памяти приводит к чтению и кэшированию целой кэш-строки.
    - Для записи одного байта в кэш-строку требуется запись всей кэш-строки.
- Маленький размер = Быстро
    
    - Компактный, хорошо локализованный код, который помещается в кэше, работает быстрее.
    - Компактные структуры данных, которые помещаются в кэше, работают быстрее.
    - Обходы, которые затрагивают только кэшированные данные, работают быстрее.
- Предсказуемые шаблоны доступа рулят.
    
    - Всякий раз, когда это практично, отдавайте предпочтение линейному обходу массива.
    - Предоставляйте обычные шаблоны доступа к памяти.
    - Оборудование может отлично предсказать размер необходимой памяти.
- Промахи кэша могут привести к промахам БДТ.
    
    - Кэш переводов виртуального адреса в физический адрес.
    - Операционная система может сообщить нам, где находится память.

## Дополнительные диаграммы

**Задержки** **Принятые** **Индустрией**

Ссылка на L1-кэш ........................................... 0,5 нс ................. 6 тактов
Неправильное предсказание ветвления .......................... 5 нс ................ 60 тактов
Ссылка на L2-кэш ............................................. 7 нс ................ 84 тактов
Захват/освобождение мьютекса ................................ 25 нс ............... 300 тактов
Ссылка на главную память ................................... 100 нс .............. 1200 тактов
Сжатие 1К байт с помощью Zippy ........................... 3 000 нс (3 мкс) ....... 36K тактов
Отправка 2К байт по сети 1 Гбит/с ....................... 20 000 нс (20 мкс) ..... 240K тактов
Произвольное чтение с SSD .............................. 150 000 нс (150 мкс) .... 1,8M тактов
Последовательное чтение 1 МБ из памяти ................. 250 000 нс (250 мкс) ...... 3M тактов
Перемещение в одном и том же дата центре ............... 500 000 нс (0,5 мс) ....... 6M тактов
Последовательное чтение 1 МБ с SSD- .................. 1 000 000 нс (1 мс) ........ 12M тактов
Поиск на диске ...................................... 10 000 000 нс (10 мс) ...... 120M тактов
Последовательное чтение 1 МБ с диска ................ 20 000 000 нс (20 мс) ...... 240M тактов
Отправка пакета США->Нидерланды->США ............... 150 000 000 нс (150 мс) ..... 1,8B тактов

**Иллюстрация** **Латентности** **Кэша**

[![](https://tour.ardanlabs.com/tour/eng/static/img/cache_latencies_graph.png)](https://tour.ardanlabs.com/tour/eng/static/img/cache_latencies_graph.png)

## Дополнительные материалы

**Кэши** **ЦП** **/** **Памяти**

- [Кэши процессора и почему они важны - Видео](https://www.youtube.com/watch?v=WDIkqP4JbkE) - Скотт Майерс
- [Краткий курс современного оборудования - Видео](https://www.youtube.com/watch?v=OFgxAFdxYAQ) - Клифф Клик
- [Глубокий обзор NUMA](http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/) - Фрэнк Деннеман
- [Кэши процессора и почему они важны - Презентация](http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf) - Скотт Майерс
- [Раскроем мифы современного оборудования, чтобы достичь "механической симпатии"](https://www.youtube.com/watch?v=MC1EKLQ2Wmg) - Мартин Томпсон
- [Что каждый программист должен знать о памяти](http://www.akkadia.org/drepper/cpumemory.pdf) - Ульрих Дреппер
- [Как работают кэши процессора и почему именно так](http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips) - Джоэл Хруска
- [90-минутный гид о современных микропроцессорах](http://www.lighterra.com/papers/modernmicroprocessors) - Джейсон Роберт Карей Паттерсон
- [Часть 2: Кэши процессора](http://lwn.net/Articles/252125) - Ульрих Дреппер
- [Бесплатные обеды закончились](http://www.gotw.ca/publications/concurrency-ddj.htm) - Херб Саттер
- [Компьютеры в дата-центрах: современные сложности в проектировании ЦПУ](https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM) - Дик Сайтс
- [Закон Вирта](https://en.wikipedia.org/wiki/Wirth%27s_law) - Википедия
- [Устранение ложного обмена](http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206) - Херб Саттер
- [Миф о RAM](http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html) - Эмиль Эрнерфельдт
- [Понимание аппаратной памяти с транзакциями](https://www.infoq.com/presentations/hardware-transactional-memory) - Гил Гин
- [Производительность через дружелюбность кэшу (4:25-5:48)](https://youtu.be/jEG4Qyo_4Bc?t=266) - Дэмиан Гриски
- [Двигаясь быстрее в никуда](https://www.youtube.com/watch?v=2EWejmkKlxs) - Чандлер Каррут

**Ориентированный-на-данные** **Дизайн**

- [Ориентированный-на-данные дизайн и C++](https://www.youtube.com/watch?v=rX0ItVEVjHc) - Майк Актон
- [Эффективность с алгоритмами, производительность со структурами данных](https://www.youtube.com/watch?v=fHNmRkzxHWs) - Чандлер Каррут
- [Обуздать производительность](https://www.youtube.com/watch?v=LrVi9LHP8Bk) - Клаус Игльбергер
- [Подводные камни ООП](http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf) - Тони Альбрехт
- [Почему стоит избегать связных списков](https://www.youtube.com/watch?v=YQs6IC-vgmo) - Бьярне Страуструп
- [Ориентированный-на-данные дизайн (или почему ООП может навредить)](http://gamesfromwithin.com/data-oriented-design) - Ноэль
- [Было ли объектно-ориентированное программирование ошибкой?](https://www.quora.com/Was-object-oriented-programming-a-failure) - Quora

## Заметки

- Если вы не понимаете данные, вы не понимаете проблему.
- Если вы не понимаете стоимость решения проблемы, вы не можете рассуждать о проблеме.
- Если вы не понимаете аппаратное обеспечение, вы не можете рассуждать о стоимости решения проблемы.
- Массивы - это структуры данных фиксированной длины, которые не могут изменяться.
- Массивы разных размеров считаются разными типами.
- Память выделяется как непрерывный блок.
- Go даёт вам контроль над пространственной локальностью.

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to declare and iterate over
// arrays of different types.
package main

import "fmt"

func main() {

	// Declare an array of five strings that is initialized
	// to its zero value.
	var fruits [5]string
	fruits[0] = "Apple"
	fruits[1] = "Orange"
	fruits[2] = "Banana"
	fruits[3] = "Grape"
	fruits[4] = "Plum"

	// Iterate over the array of strings.
	for i, fruit := range fruits {
		fmt.Println(i, fruit)
	}

	// Declare an array of 4 integers that is initialized
	// with some values.
	numbers := [4]int{10, 20, 30, 40}

	// Iterate over the array of numbers.
	for i := 0; i < len(numbers); i++ {
		fmt.Println(i, numbers[i])
	}
}

```

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how arrays of different sizes are
// not of the same type.
package main

import "fmt"

func main() {

	// Declare an array of 5 integers that is initialized
	// to its zero value.
	var five [5]int

	// Declare an array of 4 integers that is initialized
	// with some values.
	four := [4]int{10, 20, 30, 40}

	// Assign one array to the other
	five = four

	// ./example2.go:21: cannot use four (type [4]int) as type [5]int in assignment

	fmt.Println(four)
	fmt.Println(five)
}

```


```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how the behavior of the for range and
// how memory for an array is contiguous.
package main

import "fmt"

func main() {

	// Declare an array of 5 strings initialized with values.
	friends := [5]string{"Annie", "Betty", "Charley", "Doug", "Edward"}

	// Iterate over the array displaying the value and
	// address of each element.
	for i, v := range friends {
		fmt.Printf("Value[%s]\tAddress[%p] IndexAddr[%p]\n", v, &v, &friends[i])
	}
}


```


```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how the for range has both value and pointer semantics.
package main

import "fmt"

func main() {

	// Using the pointer semantic form of the for range.
	friends := [5]string{"Annie", "Betty", "Charley", "Doug", "Edward"}
	fmt.Printf("Bfr[%s] : ", friends[1])

	for i := range friends {
		friends[1] = "Jack"

		if i == 1 {
			fmt.Printf("Aft[%s]\n", friends[1])
		}
	}

	// Using the value semantic form of the for range.
	friends = [5]string{"Annie", "Betty", "Charley", "Doug", "Edward"}
	fmt.Printf("Bfr[%s] : ", friends[1])

	for i, v := range friends {
		friends[1] = "Jack"

		if i == 1 {
			fmt.Printf("v[%s]\n", v)
		}
	}

	// Using the value semantic form of the for range but with pointer
	// semantic access. DON'T DO THIS.
	friends = [5]string{"Annie", "Betty", "Charley", "Doug", "Edward"}
	fmt.Printf("Bfr[%s] : ", friends[1])

	for i, v := range &friends {
		friends[1] = "Jack"

		if i == 1 {
			fmt.Printf("v[%s]\n", v)
		}
	}
}

```