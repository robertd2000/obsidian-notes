https://tour.ardanlabs.com/tour/rus/slices/1

Срезы - чрезвычайно важная структура данных в Go. Они лежат в основе гибкого, эффективного и динамичного управления и манипулирования данными. Всем программистам Go очень полезно знать, как работают срезы и как ими пользоваться.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl1.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl1.png)

## Обзор кода

- **Пример** **1:** Объявление и Длина
- **Пример** **2:** Ссылочные типы
- **Пример** **3:** Добавление к срезам
- **Пример** **4:** Создание срезов из срезов
- **Пример** **5:** Срезы и ссылки
- **Пример** **6:** Строки и срезы
- **Пример** **7:** Функции с переменным числом параметров (вариативные функции)
- **Пример** **8:** Механика инструкции `range`
- **Пример** **9:** Эффективные Обходы
- **Пример** **10:** Трёх-индексовые срезы

## Создание среза

Создание среза можно выполнить несколькими способами.

// Срез строк, установленный в состояние нулевого значения.
var slice []string

// Пустой срез строк.
slice := []string{}

// Срез строк длиной и ёмкостью 5.
slice := make([]string, 5)

// Срез строк, длиной 5 и ёмкостью 8.
slice := make([]string, 5, 8)

// Срез строк со значениями - длиной и ёмкостью 5.
slice := []string{"A", "B", "C", "D", "E"}

Как вы видите, встроенная функция make позволяет предварительно выделить как длину, так и ёмкость базового массива. Если компилятор знает размер на этапе компиляции, базовый массив может быть создан в стеке.

## Длина среза по сравнению с ёмкостью

Длина среза представляет количество элементов, которые можно читать и записывать. Ёмкость представляет общее количество элементов, которые существуют в базовом массиве с определённой позиции указателя.

Благодаря синтаксическому сахару срезы выглядят и ощущаются как массивы.

slice := make([]string, 5)
slice[0] = "Яблоко"
slice[1] = "Апельсин"
slice[2] = "Банан"
slice[3] = "Виноград"
slice[4] = "Слива"

Вы можете отличить конструкцию среза и массива, так как размер массива должен быть известен на этапе компиляции, в то время как для срезов это не обязательно.

Если вы попытаетесь получить доступ к элементу за пределами длины среза, вы получите ошибку во время выполнения.

slice := make([]string, 5)
slice[5] = "Raspberry"

Ошибка компилятора:

Error: panic: runtime error: index out of range slice[5] = "Runtime error"

В этом примере длина среза составляет 5, и я пытаюсь получить доступ к 6-му элементу, который не существует.

## Семантическое руководство по данным для срезов

Если данные, с которыми вы работаете, являются срезом, руководствуйтесь семантикой значений для перемещения данных внутри программы. Эта рекомендация включает объявление полей в структурах.

func Foo(data []byte) []byte

type Foo struct {
    X []int
    Y []string
    Z []bool
}

Это относится ко всем внутренним структурам данных Go (срезам, картам, каналам, интерфейсам и функциям).

Одна из причин перехода к семантике указателей - это необходимость передачи среза для декодирования или десериализации. Использование указателей для этих типов операций допустимо, но если это не очевидно, то такие вещи необходимо документировать.

## Непрерывное расположение в памяти

Идея среза заключается в использовании массива, который является наиболее эффективной структурой данных с точки зрения аппаратного обеспечения. Однако вам нужно сохранять динамичность и эффективность, учитывая количество обрабатываемых данных и принимая во внимание будущий рост.

func main() {
    slice := make([]string, 5, 8)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

    inspectSlice(slice)
}

func inspectSlice(slice []string) {
    fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
    for i := range slice {
        fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
    }
}

Вывод:

Length[5] Capacity[8]
[0] 0xc00007e000 Apple
[1] 0xc00007e010 Orange
[2] 0xc00007e020 Banana
[3] 0xc00007e030 Grape
[4] 0xc00007e040 Plum

Функция inspectSlice показывает, что у среза есть базовый массив с предсказуемым шагом. Она также показывает, что длина и ёмкость среза могут быть разными. Обратите внимание, как функция печати проходит только по длине среза.

## Добавление к срезам

Язык Go предоставляет встроенную функцию под названием append для добавления значений к существующему срезу.

var data []string

for record := 1; record <= 102400; record++ {
    data = append(data, fmt.Sprintf("Rec: %d", record))
}

Функция append работает со срезом, даже когда срез инициализирован в состояние нулевого значения. Интересным является дизайн API append, потому что для мутации он использует семантику значений. Append получает копию значения среза, он модифицирует свою собственную копию, а затем возвращает эту копию вызывающей стороне.

Почему API разработан таким образом? Дело в том, что идиоматичный подход состоит в использовании семантики значений для передачи значения среза внутри программы. Это необходимо иметь в виду даже при операции мутации. Кроме того, мутация на основе семантики значений является самым безопасным способом выполнения мутации, поскольку мутация выполняется на собственной копии данных функции в изоляции.

Append всегда сохраняет непрерывный блок памяти для базового массива среза, даже после увеличения. Это важно для аппаратного обеспечения.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl2.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl2.png)

Каждый раз, когда вызывается функция append, функция проверяет, совпадают длина и ёмкость среза или нет. Если они одинаковы, это означает, что для нового значения нет места в базовом массиве. В этом случае append создает новый базовый массив (удваивая или увеличивая на 25%), а затем копирует значения из старого в новый. После этого новое значение может быть добавлено.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl3.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl3.png)

Если они не совпадают, это означает, что в массиве есть достаточно ёмкости для добавления дополнительного элемента. Одно место из резервной ёмкости используется для добавления значения к длине среза. Это делает операцию append очень эффективной.

Пока ёмкость базового массива не превышает 1024 элементов, новые базовые массивы конструируются, удваивая размер существующего массива. После того как базовый массив превысит 1024 элемента, увеличение происходит на 25%.

**ЗАМЕЧАНИЕ:** **То** **как** **функция** **append** **изменяет** **ёмкость** **исходного** **массива,** **изменилось** **с** **версии** **Go** **1.18.**

- [https://tip.golang.org/doc/go1.18#runtime](https://tip.golang.org/doc/go1.18#runtime)

## Создание срезов из срезов

Срезы дают возможность избежать дополнительного копирования и выделения памяти на куче для базового массива, когда нужно выделить определенные элементы этого базового массива для различных операций.

Синтаксис срезов можно записать следующим образом [a:b), что означает включить элементы с индекса a до b, но не включая b.

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4]

Переменная slice2 - это новое значение среза, которое сейчас разделяет тот же базовый массив, что и slice1. Однако slice2 позволяет обращаться только к элементам с индексами 2 и 3 (C и D) исходного базового массива среза. Длина slice2 равна 2, а не 5, как в slice1, а ёмкость равна 3, так как сейчас есть 3 элемента с этой позиции указателя.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl4.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl4.png)

Лучше всего думать о срезе, фокусируясь на длине с помощью следующей нотации [a:a+len] - индекс `a` плюс длина. Это уменьшит ошибки при вычислении новых срезов.

Используя функцию inspect:

func inspectSlice(slice []string) {
    fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
    for i, s := range slice {
        fmt.Printf("[%d] %p %s\n",
            i,
            &slice[i],
            s)
    }
}

Вы можете увидеть это в действии:

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4]
inspectSlice(slice1)
inspectSlice(slice2)

Вывод:

Length[5] Capacity[5]
[0] 0xc00007e000 A
[1] 0xc00007e010 B
[2] 0xc00007e020 C
[3] 0xc00007e030 D
[4] 0xc00007e040 E
Length[2] Capacity[3]
[0] 0xc00007e020 C     <-- ТОТ ЖЕ ИНДЕКС, ЧТО И 2 В СРЕЗЕ 1
[1] 0xc00007e030 D     <-- ТОТ ЖЕ ИНДЕКС, ЧТО И 3 В СРЕЗЕ 1

Обратите внимание, что два разных среза используют один и тот же базовый массив. В этом можно убедиться, сравнив адреса.

Здесь хорошо то, что не происходит выделения памяти на куче. Компилятор знает размер исходного массива для slice1 на этапе компиляции. Передача копии значения среза в функцию inspectSlice позволяет хранить все значения на стеке.

## Изменения базового массива

Когда вы используете slice2 для изменения значения строки по индексу 0, любое значение среза, которое использует тот же базовый массив (где адрес для этого индекса является частью длины среза), увидит изменение.

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4]
slice2[0] = "CHANGED"
inspectSlice(slice1)
inspectSlice(slice2)

Вывод:

Length[5] Capacity[5]
[0] 0xc00007e000 A
[1] 0xc00007e010 B
[2] 0xc00007e020 CHANGED
[3] 0xc00007e030 D
[4] 0xc00007e040 E
Length[2] Capacity[3]
[0] 0xc00007e020 CHANGED
[1] 0xc00007e030 D

Важно всегда сохранять бдительность, при изменении значений с помощью индексов, в ситуациях когда базовый массив используется другим срезом.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl5.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl5.png)

Что если вы вместо этого используете встроенную функцию append?

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4]
slice2 = append(slice2, "CHANGED")
inspectSlice(slice1)
inspectSlice(slice2)

Вывод:

Length[5] Capacity[5]
[0] 0xc00007e000 A
[1] 0xc00007e010 B
[2] 0xc00007e020 C
[3] 0xc00007e030 D
[4] 0xc00007e040 CHANGED
Length[3] Capacity[3]
[0] 0xc00007e020 C
[1] 0xc00007e030 D
[2] 0xc00007e040 CHANGED

Функция append создает тот же побочный эффект, но он скрыт. В этом случае, увеличение длины slice2 за счёт ёмкости привело к изменению значения по адресу 0xc00007e040. К сожалению, slice1 уже использовал этот адрес в своей длине.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl6.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl6.png)

Один из способов избежать побочного эффекта - создании slice2 используя нотацию среза с тремя индексами, чтобы длина и ёмкость имели одинаковое значение 2.

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4:4]
inspectSlice(slice1)
inspectSlice(slice2)

Вывод:

Length[5] Capacity[5]
[0] 0xc00007e000 A
[1] 0xc00007e010 B
[2] 0xc00007e020 C
[3] 0xc00007e030 D
[4] 0xc00007e040 E
Length[2] Capacity[2]
[0] 0xc00007e020 C
[1] 0xc00007e030 D

Трёх-индексовый синтаксис для создания среза [a:b:c], когда b и c должны быть одинаковы, так как [a-b] задает длину и [a-c] задает ёмкость. Теперь длина и ёмкость slice2 одинаковы.

Теперь снова используйте встроенную функцию append:

slice1 := []string{"A", "B", "C", "D", "E"}
slice2 := slice1[2:4:4]
slice2 = append(slice2, "CHANGED")
inspectSlice(slice1)
inspectSlice(slice2)

Вывод:

Length[5] Capacity[5]
[0] 0xc00007e000 A
[1] 0xc00007e010 B
[2] 0xc00007e020 C
[3] 0xc00007e030 D
[4] 0xc00007e040 E
Length[3] Capacity[4]
[0] 0xc000016080 C
[1] 0xc000016090 D
[2] 0xc0000160a0 CHANGED

Обратите внимание, после вызова append, у slice2 появился новый базовый массив.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl7.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl7.png)

Это видно при сравнении адресов срезов. В этом случае изменение значений в slice2 не вызвало побочного эффекта для slice1.

## Ручное копирование срезов

Есть встроенная функция copy, которая позволяет выполнять поверхностное копирование срезов. Так как строка имеет базовый массив байтов, которые неизменны, она может использоваться в качестве источника, но не приёмника.

slice1 := []string{"A", "B", "C", "D", "E"}
slice3 := make([]string, len(slice1))
copy(slice3, slice1)

inspectSlice(slice1)
inspectSlice(slice3)

Вывод:

Length[5] Capacity[5]
[0] 0xc00005c050 A
[1] 0xc00005c060 B
[2] 0xc00005c070 C
[3] 0xc00005c080 D
[4] 0xc00005c090 E
Length[5] Capacity[5]
[0] 0xc00005c0a0 A
[1] 0xc00005c0b0 B
[2] 0xc00005c0c0 C
[3] 0xc00005c0d0 D
[4] 0xc00005c0e0 E

Пока у приёмника есть правильные тип и длина, встроенная функция copy может выполнить поверхностное копирование.

## Срезы используют мутацию семантики указателя

Важно помнить, что даже если вы используете семантику значения для передачи среза по программе, при чтении и записи среза вы используете семантику указателя. Совместное использование отдельных элементов среза различными частями программы может привести к нежелательным побочным эффектам.

// Создаём срез для 1 user, устанавливаем указатель на этого пользователя,
// используем указатель для обновления лайков.

users := make([]user, 1)
ptrUsr0 := &users[0]
ptrUsr0.likes++

for i := range users {
    fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
}

Output:

User: 0 Likes: 1

Срез используется для хранения коллекции пользователей. Затем указатель устанавливается на первого пользователя и используется для обновления лайков. Результат показывает, что использование указателя работает.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl8.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl8.png)

Затем к коллекции добавляется новый пользователь, и указатель снова используется для добавления лайка первому пользователю.

// Добавить нового пользователя в коллекцию. Снова используйте указатель
// для обновления лайков.

users = append(users, user{})
ptrUsr0.likes++

for i := range users {
    fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
}

Output:

User: 0 Likes: 1
User: 1 Likes: 0

Однако, поскольку функция append заменила базовый массив на новый, указатель обновляет старый базовый массив, и лайки теряются. Результат показывает, что лайки первого пользователя не увеличились.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl9.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl9.png)

Нужно быть осторожным с тем, будет ли срез использоваться в операции добавления (append) во время работы программы. Необходимо обдумать, как вы делитесь срезом. Делиться отдельными индексами может быть не лучшей идеей. Даже делиться значением целого среза может не работать, при добавлении элементов. Вероятно, лучший способ - использовать срез как поле в структуре и делиться значением структуры.

## Эффективность линейного обхода

Прелесть среза заключается в его способности выполнять линейные обходы, которые механически симпатичны при использовании семантики значений для минимизации выделения памяти на куче.

x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

a := x[0]
b := binary.LittleEndian.Uint16(x[1:3])
c := binary.LittleEndian.Uint16(x[3:5])
d := binary.LittleEndian.Uint32(x[5:9])

println(a, b, c, d)

Код выполняет линейный обход, создавая значения срезов, которые считывают разные секции байтового массива от начала до конца.

[![](https://tour.ardanlabs.com/tour/rus/static/img/sl10.png)](https://tour.ardanlabs.com/tour/rus/static/img/sl10.png)

Все значения в этом примере остаются в стеке. Дополнительные копии данных внутри байтового среза не создаются.

## Примечания

- Срезы похожи на динамические массивы с особым встроенным функционалом.
- Есть разница между длиной и ёмкостью среза, и каждый из них выполняет свою функцию.
- Срезы позволяют создавать несколько "представлений" одного базового массива.
- Срезы могут увеличиваться с помощью встроенной функции append.

## Дополнительное чтение

- [Использование и внутренности срезов в Go](https://blog.golang.org/go-slices-usage-and-internals) - Эндрю Герранд
- [Строки, байты, руны и символы в Go](https://blog.golang.org/strings) - Роб Пайк
- [Механика функции 'append': массивы, срезы (и строки) в Go](https://blog.golang.org/slices) - Роб Пайк
- [Понимание срезов в программировании на Go](https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html) - Уильям Кеннеди
- [Коллекции неизвестной длины в Go](https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html) - Уильям Кеннеди
- [Итерирование по срезам в Go](https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html) - Уильям Кеннеди
- [Срезы срезов в Go](https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html) - Уильям Кеннеди
- [Трёх-индексные срезы в Go 1.2](https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html) - Уильям Кеннеди
- [Фокусы со Срезами](https://github.com/golang/go/wiki/SliceTricks)
- [Среда выполнения: Сглаживание формулы роста срезов](https://go-review.googlesource.com/c/go/+/347917) - Команда Go

```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how the capacity of the slice
// is not available for use.
package main

import "fmt"

func main() {

	// Create a slice with a length of 5 elements.
	fruits := make([]string, 5)
	fruits[0] = "Apple"
	fruits[1] = "Orange"
	fruits[2] = "Banana"
	fruits[3] = "Grape"
	fruits[4] = "Plum"

	// You can't access an index of a slice beyond its length.
	fruits[5] = "Runtime error"

	// Error: panic: runtime error: index out of range

	fmt.Println(fruits)
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the components of a slice. It has a
// length, capacity and the underlying array.
package main

import "fmt"

func main() {

	// Create a slice with a length of 5 elements and a capacity of 8.
	fruits := make([]string, 5, 8)
	fruits[0] = "Apple"
	fruits[1] = "Orange"
	fruits[2] = "Banana"
	fruits[3] = "Grape"
	fruits[4] = "Plum"

	inspectSlice(fruits)
}

// inspectSlice exposes the slice header for review.
func inspectSlice(slice []string) {
	fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
	for i, s := range slice {
		fmt.Printf("[%d] %p %s\n",
			i,
			&slice[i],
			s)
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to grow a slice using the built-in function append
// and how append grows the capacity of the underlying array.
package main

import "fmt"

func main() {

	// Declare a nil slice of strings.
	var data []string

	// Capture the capacity of the slice.
	lastCap := cap(data)

	// Append ~100k strings to the slice.
	for record := 1; record <= 1e5; record++ {

		// Use the built-in function append to add to the slice.
		value := fmt.Sprintf("Rec: %d", record)
		data = append(data, value)

		// When the capacity of the slice changes, display the changes.
		if lastCap != cap(data) {

			// Calculate the percent of change.
			capChg := float64(cap(data)-lastCap) / float64(lastCap) * 100

			// Save the new values for capacity.
			lastCap = cap(data)

			// Display the results.
			fmt.Printf("Addr[%p]\tIndex[%d]\t\tCap[%d - %2.f%%]\n",
				&data[0],
				record,
				cap(data),
				capChg)
		}
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to takes slices of slices to create different
// views of and make changes to the underlying array.
package main

import "fmt"

func main() {

	// Create a slice with a length of 5 elements and a capacity of 8.
	slice1 := make([]string, 5, 8)
	slice1[0] = "Apple"
	slice1[1] = "Orange"
	slice1[2] = "Banana"
	slice1[3] = "Grape"
	slice1[4] = "Plum"

	inspectSlice(slice1)

	// Take a slice of slice1. We want just indexes 2 and 3.
	// Parameters are [starting_index : (starting_index + length)]
	slice2 := slice1[2:4]
	inspectSlice(slice2)

	fmt.Println("*************************")

	// Change the value of the index 0 of slice2.
	slice2[0] = "CHANGED"

	// Display the change across all existing slices.
	inspectSlice(slice1)
	inspectSlice(slice2)

	fmt.Println("*************************")

	// Make a new slice big enough to hold elements of slice 1 and copy the
	// values over using the builtin copy function.
	slice3 := make([]string, len(slice1))
	copy(slice3, slice1)
	inspectSlice(slice3)
}

// inspectSlice exposes the slice header for review.
func inspectSlice(slice []string) {
	fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
	for i, s := range slice {
		fmt.Printf("[%d] %p %s\n",
			i,
			&slice[i],
			s)
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how one needs to be careful when appending
// to a slice when you have a reference to an element.
package main

import "fmt"

type user struct {
	likes int
}

func main() {

	// Declare a slice of 3 users.
	users := make([]user, 3)

	// Share the user at index 1.
	shareUser := &users[1]

	// Add a like for the user that was shared.
	shareUser.likes++

	// Display the number of likes for all users.
	for i := range users {
		fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
	}

	// Add a new user.
	users = append(users, user{})

	// Add another like for the user that was shared.
	shareUser.likes++

	// Display the number of likes for all users.
	fmt.Println("*************************")
	for i := range users {
		fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
	}

	// Notice the last like has not been recorded.
}

```

```go


// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

/*
	https://blog.golang.org/strings

	Go source code is always UTF-8.
	A string holds arbitrary bytes.
	A string literal, absent byte-level escapes, always holds valid UTF-8 sequences.
	Those sequences represent Unicode code points, called runes.
	No guarantee is made in Go that characters in strings are normalized.

	----------------------------------------------------------------------------

	Multiple runes can represent different characters:

	The lower case grave-accented letter à is a character, and it's also a code
	point (U+00E0), but it has other representations.

	We can use the "combining" grave accent code point, U+0300, and attach it to
	the lower case letter a, U+0061, to create the same character à.

	In general, a character may be represented by a number of different sequences
	of code points (runes), and therefore different sequences of UTF-8 bytes.
*/

// Sample program to show how strings have a UTF-8 encoded byte array.
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {

	// Declare a string with both chinese and english characters.
	s := "世界 means world"

	// UTFMax is 4 -- up to 4 bytes per encoded rune.
	var buf [utf8.UTFMax]byte

	// Iterate over the string.
	for i, r := range s {

		// Capture the number of bytes for this rune.
		rl := utf8.RuneLen(r)

		// Calculate the slice offset for the bytes associated
		// with this rune.
		si := i + rl

		// Copy of rune from the string to our buffer.
		copy(buf[:], s[i:si])

		// Display the details.
		fmt.Printf("%2d: %q; codepoint: %#6x; encoded bytes: %#v\n", i, r, r, buf[:rl])
	}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how to declare and use variadic functions.
package main

import "fmt"

// user is a struct type that declares user information.
type user struct {
	id   int
	name string
}

func main() {

	// Declare and initialize a value of type user.
	u1 := user{
		id:   1432,
		name: "Betty",
	}

	// Declare and initialize a value of type user.
	u2 := user{
		id:   4367,
		name: "Janet",
	}

	// Display both user values.
	display(u1, u2)

	// Create a slice of user values.
	u3 := []user{
		{24, "Bill"},
		{32, "Joan"},
	}

	// Display all the user values from the slice.
	display(u3...)

	change(u3...)
	fmt.Println("**************************")
	for _, u := range u3 {
		fmt.Printf("%+v\n", u)
	}
}

// display can accept and display multiple values of user types.
func display(users ...user) {
	fmt.Println("**************************")
	for _, u := range users {
		fmt.Printf("%+v\n", u)
	}
}

// change shows how the backing array is shared.
func change(users ...user) {
	users[1] = user{99, "Same Backing Array"}
}

```

```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how the for range has both value and pointer semantics.
package main

import "fmt"

func main() {

	// Using the value semantic form of the for range.
	friends := []string{"Annie", "Betty", "Charley", "Doug", "Edward"}
	for _, v := range friends {
		friends = friends[:2]
		fmt.Printf("v[%s]\n", v)
	}

	// Using the pointer semantic form of the for range.
	friends = []string{"Annie", "Betty", "Charley", "Doug", "Edward"}
	for i := range friends {
		friends = friends[:2]
		fmt.Printf("v[%s]\n", friends[i])
	}
}

```