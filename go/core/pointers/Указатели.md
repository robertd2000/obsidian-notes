https://tour.ardanlabs.com/tour/rus/pointers/1

Указатели служат для передачи значений через границы внутри программы. Существует несколько типов программных границ. Наиболее распространенная - между вызовами функций. Существует также граница между горутинами, которые мы обсудим позже.

## Обзор кода

- **Пример** **1:** Передача по значению
- **Пример** **2:** Совместное использование данных (часть 1)
- **Пример** **3:** Совместное использование данных (часть 2)
- **Пример** **4:** Aнализ утечек (из стэка на кучу)
- **Пример** **5:** Рост стека

При запуске Go-программы среда выполнения Go создает горутину. Горутины - это облегченные потоки на уровне приложения во многом схожие с потоками операционной системы. Их задача - управлять выполнением отдельного набора инструкций. В каждой программе на Go есть как минимум одна горутина, которую мы называем главной горутиной.

Каждой горутине отводится свой блок памяти, называемый стеком. При создании, под стек выделяется 2048 байт (2k) памяти. Это очень немного, но со временем стек может увеличиваться в размерах.

[![](https://tour.ardanlabs.com/tour/eng/static/img/p1.png)](https://tour.ardanlabs.com/tour/eng/static/img/p1.png)

Каждый раз, при вызове функции, под выполнение инструкций связанных с этой функцией, горутине на стэке выделяется блок памяти. Каждый такой блок называется фреймом.

Размер фрейма для каждой функции определяется при компиляции. Значение не может быть создано на стеке, если на этапе компиляции компилятор не знает размера этого значения. Если компилятор не знает размера значения на этапе компиляции, значение вынужденно создается на куче.

Стеки являются самоочищающимися, и нулевые значения облегчают инициализацию стека. Каждый раз, при вызове функции, под фрейм выделяется блок памяти; память этого фрейма инициализируется, что позволяет самоочищение стека. При возврате из функции память фрейма остается нетронутой, поскольку неизвестно, потребуется ли эта память снова. Инициализация памяти при возврате была бы неэффективной.

**Передача** **по** **значению**

По ходу выполнения программы, все данные передаются по значению. Это означает, что при передаче данных через границы программы, каждая функция или горутина получают свою собственную копию данных. Существуют два типа данных, с которыми вы будете работать: само значение (int, string, user) или адрес значения. Адреса - это данные, которые необходимо копировать и сохранять при передаче через границы программы.

Следующий код пытается это более подробно продемонстрировать.
```go

func main() {

    // Объявление переменной типа int со значением 10.
    count := 10

    // Чтобы получить адрес значения, используйте оператор &.
    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

    // Передача копии "значения" `count` (то, что находится в коробке)
    // функции increment1.
    increment1(count)

    // Вывод "значения" и "адреса" переменной счет.
    // Значение count не изменится после вызова функции.
    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

    // Передача копии "адреса" переменной count (где находится коробка)
    // функции increment2. Это все равно считается передачей по значению,
    // а не передачей по ссылке, потому что адреса - это значения.
    increment2(&count)

    // Вывод "значения" и "адреса" переменной count.
    // Значение переменной count изменилось после вызова функции.
    println(
        "count:\tValue Of[",
        count, "]\tAddr Of[", &count, "]")

}

// increment1 объявляет функцию, создающую свою собственной копию
// целочисленного значения.
func increment1(inc int) {

    // Увеличить локальную копию целочисленного значения из вызывающей функции.
    inc++
    println("inc1:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
}

// increment2 объявляет функцию, принимающую копию адреса,
// указывающего на целочисленное значение.
// Переменные-указатели - это литеральные типы которые объявляются с помощью *.
func increment2(inc *int) {

    // Увеличить целочисленное значение в вызывающей функции через указатель.
    *inc++
    println(
        "inc2:\tValue Of[",
        inc, "]\tAddr Of[", &inc,
        "]\tPoints To[", *inc, "]")
}
```

Результат:

```
count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
inc1:   Value Of[ 11 ]  Addr Of[ 0xc000050730 ]
count:  Value Of[ 10 ]  Addr Of[ 0xc000050738 ]
inc2:   Value Of[ 0xc000050738 ] Addr Of[ 0xc000050748 ] Points To[ 11 ]
count:  Value Of[ 11 ]  Addr Of[ 0xc000050738 ]
```


## Заметки

- Используйте указатели для совместного использования данных.
- Значения в Go всегда передаются по значению.
- "Значение"- это то, что находится в коробке. "Адрес" ( & )- это то, где находится коробка.
- Оператор ( * ) объявляет переменную-указатель и "Значение, на которое указывает указатель".

## Aнализ утечек (памяти со стэка на кучу)

Алгоритм, который компилятор использует для определения, следует ли создавать значение на стеке или куче, называется "анализом утечек". Название алгоритма может создать впечатление, будто значения сначала создаются на стеке, а затем "убегают" (или перемещаются) на кучу, когда это необходимо. Это НЕ так. Создание значения происходит только один раз, и алгоритм анализа утечек решает, где это произойдет (стек или куча). Только создание на куче называется выделением памяти в Go.

Aнализ утечек требует понимания того кто владеет значением. Идея заключается в том, что когда значение создается внутри функции, то эта функция владеет значением. Затем возникает вопрос, должно ли значение, которое создается, все еще существовать когда после завершения работы функция-владелец возвращает значение? Если ответ - нет, то значение может быть создано на стеке. Если ответ - да, значение должно быть создано на куче.

Примечание: Правило владения - это хорошее базовое правило для идентификации кода, который приводит к выделению памяти. Однако нужно понимать, что анализ утечек имеет недостатки, которые могут привести к неочевидным выделениям. Кроме того, алгоритм использует оптимизации компилятора для уменьшения количества выделений памяти.

```go
// user представляет собой пользователя в системе.
type user struct {
    name  string
    email string
}

func stayOnStack() user {
    u := user{
        name:  "Bill",
        email: "bill@email.com",
    }

    return u
}
```


Функция stayOnStack использует семантику значения для возврата значения user вызывающему. Другими словами, вызывающий получает собственную копию значения user, созданного функцией stayOnStack.

Когда функция stayOnStack завершает работу, значение user, которое она создает, больше не должно существовать, так как вызывающий получает собственную копию. Поэтому создание значения user в рамках stayOnStack может происходить на стеке. Выделения памяти на куче не происходит.

```go
type user struct {
    name  string
    email string
}

func escapeToHeap() *user {
    u := user{
        name:  "Bill",
        email: "bill@email.com",
    }

    return &u
}
```


Функция escapeToHeap использует семантику указателя для возврата значения user в вызывающую функцию. Другими словами, вызывающая функция получает доступ (адрес) к создаваемому значению user.

Когда функция escapeToHeap вызывается и завершает выполнение, значение user, которое она создает, все равно должно существовать, так как вызывающая функция получает общий доступ к значению. Поэтому создание значения внутри функции escapeToHeap не может происходить в стеке, оно должно происходить в куче. Да, это выделение памяти в куче.

Подумайте о том, что произойдет, если значение user в последнем примере будет выделено на стеке используя семантику указателя при возврате.

[![](https://tour.ardanlabs.com/tour/eng/static/img/p2.png)](https://tour.ardanlabs.com/tour/eng/static/img/p2.png)

Вызывающая функция получит копию адреса стека из предыдущего фрейма, и целостность будет потеряна. Как только управление возвращается в вызывающую функцию, память на стеке, где находится значение user, становится снова доступной для использования. В момент, когда вызывающая функция выполняет очередной вызов функции, создается новый фрейм, и память будет перезаписана, уничтожив общее значение.

Вот почему стоит думать о стеке как о самоочищающемся. Инициализация нулевым значением помогает очищать каждый стековый фрейм, без использования сборщика мусора (GC). Стек самоочищающийся, так как для выполнения каждого вызова функции берется и инициализируется фрейм. Очистка стека происходит во время вызова функций, а не при возвратах, потому что компилятор не знает, потребуется ли в будущем эта память на стеке.

Aнализ утечек определяет, создается ли значение на стеке (по умолчанию) или в куче (при утечке). С функцией stayOnStack мы передаем копию значения обратно вызывающей функции, поэтому безопасно оставить значение на стеке. С функцией escapeToHeap мы передаем копию адреса значения обратно вызывающей функции (давая общий доступ к стеку), поэтому небезопасно оставлять значение на стеке.

Существует множество мелких деталей, связанных с анализом утечек. Чтобы лучше разобраться в этой теме читайте пост в главе 14 под названием "Механика анализа утечек".

Примечание: Начиная с версии 1.17, Go изменил ABI (бинарный интерфейс приложения), и перешел на новый способ передачи аргументов ввода и вывода функций с использованием регистров вместо памяти на стеке. Это работает на 64-разрядной архитектуре x86 Linux, MacOS и Windows. Это означает, что некоторые аргументы функций не будут копироваться в стек, но некоторые (в зависимости от возможности использования регистров) могут. Это не изменяет семантики, описанной в этой главе.

## Примечания

- Когда значение может быть использовано после возврата функции, которая его создает.
- Когда компилятор определяет, что размер значения слишком велик для размещения на стеке.
- Когда компилятор не знает размера значения на этапе компиляции.
- Когда значение отделяется посредством использованием функций или интерфейсов.

## Семантика сборки мусора:

Как только значение создано в куче, включается механизм сборки мусора (GC). Самая важная часть GC - это алгоритм планирования. Он определяет частоту/темп, с которым GC должен выполняться, чтобы поддерживать наименьший объем кучи в сочетании с наилучшей производительностью приложения.

- [Семантика сборки мусора, часть I](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html) - Уильям Кеннеди

## Стек против Кучи

"Стек предназначен для данных, которые должны существовать только в течение времени выполнения функции, которая их создает, и он освобождаются без каких-либо затрат при выходе из функции. Куча предназначена для данных, которые должны существовать после завершения функции, которая их создала, и ее освобождение требует (иной раз дорогостоящей), сборки мусора." - Айян Джордж

## Рост стека

Размер фрейма для каждой функции вычисляется на этапе компиляции. Это означает, что если компилятор не знает размер значения на этапе компиляции, значение должно быть создано в куче. Примером может послужить использование встроенной функции make для создания среза, размер которого зависит от переменной.

```go
b := make([]byte, size) // Массив для среза создается в куче.

```

Go использует реализацию непрерывного стека, чтобы определить, как стеки растут и уменьшаются. Одна из альтернатив, которую мог бы использовать Go - реализация сегментированного стека, которая используется в некоторых операционных системах.

Каждый вызов функции сопровождается небольшой преамбулой, которая спрашивает: "Достаточно ли места на стеке для этого нового фрейма?". Если да, то проблем нет, и фрейм инициализируется. Если нет, то должен быть создан новый, более крупный стек, и память на существующем стеке должна быть скопирована в новый. Это требует изменения указателей, которые ссылаются на память на стеке. Преимущества непрерывной памяти и линейного обхода современного оборудования являются компромиссом ценой которого являются затраты на копирование.

Из-за использования непрерывных стеков, ни одна горутина не может иметь указателя на стек другой горутины. Затраты среды выполнения, по отслеживанию каждого указателя на каждый стек и корректировки этих указателей для нового местоположения, были бы слишком велики.

## Дополнительное чтение

**Механика** **Указателей**

- [Указатели против Значений](https://golang.org/doc/effective_go.html#pointers_vs_values)
- [Механика языка по стекам и указателям](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html) - Уильям Кеннеди
- [Использование указателей в Go](https://www.ardanlabs.com/blog/2014/12/using-pointers-in-go.html) - Уильям Кеннеди
- [Понимание указателей и выделения памяти](https://www.ardanlabs.com/blog/2013/07/understanding-pointers-and-memory.html) - Уильям Кеннеди

**Стеки**

- [Предложение о непрерывном стеке](https://docs.google.com/document/d/1wAaf1rYoM4S4gtnPh0zOlGzWtrZFQ5suE8qr2sD8uWQ/pub)

**Анализ** **Утечек** **и** **Встраивание**

- [Недостатки анализа утечек Go](https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw)
- [Оптимизации компилятора](https://github.com/golang/go/wiki/CompilerOptimizations)

**Сборка** **Мусора**

- [Справочник по Сборке Мусора](http://gchandbook.org/)
- [Пересмотр сборки мусора - 2021](https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md) - Майкл Книсзек
- [Сборка мусора с отслеживанием](https://en.wikipedia.org/wiki/Tracing_garbage_collection)
- [Блог Go - Сборка мусора версии 1.5](https://blog.golang.org/go15gc)
- [Сборка мусора в Go: решение проблемы латентности](https://www.youtube.com/watch?v=aiv1JOfMjm0&index=16&list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm)
- [Параллельная сборка мусора](http://rubinius.com/2013/06/22/concurrent-garbage-collection)
- [Планирование сборки мусора в Go 1.5](https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit)
- [Ликвидация повторного сканирования стека](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)
- [Почему сборщик мусора Go не реализует компактную сборку мусора?](https://groups.google.com/forum/m/#!topic/golang-nuts/KJiyv2mV2pU) - Иэн Ланс Тейлор
- [Достигая Go: Путешествие сборщика мусора Go](https://blog.golang.org/ismmkeynote) - Рик Хадсон
- [Сборка мусора в Go, часть I - Семантика](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html) - Уильям Кеннеди
- [Сборка мусора в Go, часть II - Трассировки GC](https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html) - Уильям Кеннеди
- [Сборка мусора в Go, часть III - Регулировка GC](https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html) - Уильям Кеннеди
- [Балласт памяти Go: Как я научился не волноваться и полюбил кучу](https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap-26c2462549a2/) - Росс Энгерс

**Оптимизации** **Статического** **Единичного** **Присваивания**

- [GopherCon 2015: Бен Джонсон - Статический анализ кода с использованием SSA](https://www.youtube.com/watch?v=D2-gaMvWfQY)
- [Пакет SSA](https://godoc.org/golang.org/x/tools/go/ssa)
- [Понимание оптимизации компилятора](https://www.youtube.com/watch?v=FnGCDLhaxKU)

- **Пример** **1:** Передача по значению
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the basic concept of pass by value.
package main

func main() {

	// Declare variable of type int with a value of 10.
	count := 10

	// Display the "value of" and "address of" count.
	println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")

	// Pass the "value of" the count.
	increment(count)

	println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
}

// increment declares count as a pointer variable whose value is
// always an address and points to values of type int.
//
//go:noinline
func increment(inc int) {

	// Increment the "value of" inc.
	inc++
	println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
}

```
- **Пример** **2:** Совместное использование данных (часть 1)
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the basic concept of using a pointer
// to share data.
package main

func main() {

	// Declare variable of type int with a value of 10.
	count := 10

	// Display the "value of" and "address of" count.
	println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")

	// Pass the "address of" count.
	increment(&count)

	println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")
}

// increment declares count as a pointer variable whose value is
// always an address and points to values of type int.
//
//go:noinline
func increment(inc *int) {

	// Increment the "value of" count that the "pointer points to".
	*inc++

	println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]\tValue Points To[", *inc, "]")
}

```

- **Пример** **3:** Совместное использование данных (часть 2)
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show the basic concept of using a pointer
// to share data.
package main

import "fmt"

// user represents a user in the system.
type user struct {
	name   string
	email  string
	logins int
}

func main() {

	// Declare and initialize a variable named bill of type user.
	bill := user{
		name:  "Bill",
		email: "bill@ardanlabs.com",
	}

	//** We don't need to include all the fields when specifying field
	// names with a struct literal.

	// Pass the "address of" the bill value.
	display(&bill)

	// Pass the "address of" the logins field from within the bill value.
	increment(&bill.logins)

	// Pass the "address of" the bill value.
	display(&bill)
}

// increment declares logins as a pointer variable whose value is
// always an address and points to values of type int.
func increment(logins *int) {
	*logins++
	fmt.Printf("&logins[%p] logins[%p] *logins[%d]\n\n", &logins, logins, *logins)
}

// display declares u as user pointer variable whose value is always an address
// and points to values of type user.
func display(u *user) {
	fmt.Printf("%p\t%+v\n", u, *u)
	fmt.Printf("Name: %q Email: %q Logins: %d\n\n", u.name, u.email, u.logins)
}

```

- **Пример** **4:** Aнализ утечек (из стэка на кучу)
```go
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to teach the mechanics of escape analysis.
package main

// user represents a user in the system.
type user struct {
	name  string
	email string
}

// main is the entry point for the application.
func main() {
	u1 := createUserV1()
	u2 := createUserV2()

	println("u1", &u1, "u2", u2)
}

// createUserV1 creates a user value and passed
// a copy back to the caller.
//
//go:noinline
func createUserV1() user {
	u := user{
		name:  "Bill",
		email: "bill@ardanlabs.com",
	}

	println("V1", &u)

	return u
}

// createUserV2 creates a user value and shares
// the value with the caller.
//
//go:noinline
func createUserV2() *user {
	u := user{
		name:  "Bill",
		email: "bill@ardanlabs.com",
	}

	println("V2", &u)

	return &u
}

/*
// See escape analysis and inlining decisions.

$ go build -gcflags -m=2
# github.com/ardanlabs/gotraining/topics/go/language/pointers/example4
./example4.go:24:6: cannot inline createUserV1: marked go:noinline
./example4.go:38:6: cannot inline createUserV2: marked go:noinline
./example4.go:14:6: cannot inline main: function too complex: cost 132 exceeds budget 80
./example4.go:39:2: u escapes to heap:
./example4.go:39:2:   flow: ~r0 = &u:
./example4.go:39:2:     from &u (address-of) at ./example4.go:46:9
./example4.go:39:2:     from return &u (return) at ./example4.go:46:2
./example4.go:39:2: moved to heap: u

// See the intermediate representation phase before
// generating the actual arch-specific assembly.

$ go build -gcflags -S
CALL	"".createUserV1(SB)
	0x0026 00038 MOVQ	(SP), AX
	0x002a 00042 MOVQ	8(SP), CX
	0x002f 00047 MOVQ	16(SP), DX
	0x0034 00052 MOVQ	24(SP), BX
	0x0039 00057 MOVQ	AX, "".u1+40(SP)
	0x003e 00062 MOVQ	CX, "".u1+48(SP)
	0x0043 00067 MOVQ	DX, "".u1+56(SP)
	0x0048 00072 MOVQ	BX, "".u1+64(SP)
	0x004d 00077 PCDATA	$1,

// See bounds checking decisions.

go build -gcflags="-d=ssa/check_bce/debug=1"

// See the actual machine representation by using
// the disassembler.

$ go tool objdump -s main.main example4
TEXT main.main(SB) github.com/ardanlabs/gotraining/topics/go/language/pointers/example4/example4.go
  example4.go:15	0x105e281		e8ba000000		CALL main.createUserV1(SB)
  example4.go:15	0x105e286		488b0424		MOVQ 0(SP), AX
  example4.go:15	0x105e28a		488b4c2408		MOVQ 0x8(SP), CX
  example4.go:15	0x105e28f		488b542410		MOVQ 0x10(SP), DX
  example4.go:15	0x105e294		488b5c2418		MOVQ 0x18(SP), BX
  example4.go:15	0x105e299		4889442428		MOVQ AX, 0x28(SP)
  example4.go:15	0x105e29e		48894c2430		MOVQ CX, 0x30(SP)
  example4.go:15	0x105e2a3		4889542438		MOVQ DX, 0x38(SP)
  example4.go:15	0x105e2a8		48895c2440		MOVQ BX, 0x40(SP)

// See a list of the symbols in an artifact with
// annotations and size.

$ go tool nm example4
 105e340 T main.createUserV1
 105e420 T main.createUserV2
 105e260 T main.main
 10cb230 B os.executablePath
*/

```
- **Пример** **5:** Рост стека
```go

// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// Sample program to show how stacks grow/change.
package main

// Number of elements to grow each stack frame.
// Run with 1 and then with 1024
const size = 1

// main is the entry point for the application.
func main() {
	s := "HELLO"
	stackCopy(&s, 0, [size]int{})
}

// stackCopy recursively runs increasing the size
// of the stack.
//
//go:noinline
func stackCopy(s *string, c int, a [size]int) {
	println(c, s, *s)

	c++
	if c == 10 {
		return
	}

	stackCopy(s, c, a)
}

```