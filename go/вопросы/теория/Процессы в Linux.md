## **Процессы в Linux - что нужно знать на собеседовании**

### **1. Что такое процесс?**

**Процесс** - это экземпляр выполняющейся программы. Каждый процесс имеет:
- Собственное виртуальное адресное пространство
- Код программы (text section)
- Данные (data section)
- Стек вызовов
- Состояние выполнения
- Ресурсы ОС (файловые дескрипторы, сокеты и т.д.)

### **2. Состояния процесса (Process States)**

```bash
# Посмотреть состояния процессов
ps aux
```

**Основные состояния:**
- **R (Running)** - выполняется или готов к выполнению
- **S (Sleeping)** - спит, ожидает события
- **D (Uninterruptible Sleep)** - глубокий сон (обычно I/O операции)
- **T (Stopped)** - остановлен сигналом (SIGSTOP)
- **Z (Zombie)** - завершился, но родитель не забрал статус

### **3. Создание процессов**

**Системные вызовы:**
- `fork()` - создает копию текущего процесса
- `exec()` - заменяет образ процесса новой программой
- `clone()` - создает новый процесс/поток с тонкой настройкой

**Пример на C:**
```c
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();  // Создаем новый процесс
    
    if (pid == 0) {
        // Дочерний процесс
        printf("Child process: PID=%d\n", getpid());
    } else {
        // Родительский процесс
        printf("Parent process: PID=%d, Child PID=%d\n", getpid(), pid);
    }
    return 0;
}
```

### **4. Иерархия процессов**

```bash
# Дерево процессов
pstree
```
- **PID 1** - процесс `init`/`systemd` (родитель всех процессов)
- Каждый процесс имеет родителя (PPID)
- Процессы образуют дерево

### **5. Сигналы (Signals)**

**Управление процессами через сигналы:**
```bash
# Отправить сигнал процессу
kill -SIGTERM 1234
kill -9 1234      # SIGKILL - принудительное завершение
kill -15 1234     # SIGTERM - корректное завершение
kill -STOP 1234   # Остановка процесса
kill -CONT 1234   # Продолжение выполнения
```

**Частые сигналы:**
- `SIGHUP` (1) - завершение терминала
- `SIGINT` (2) - Ctrl+C
- `SIGKILL` (9) - безусловное завершение
- `SIGTERM` (15) - запрос на завершение
- `SIGSTOP` (17,19,23) - приостановка выполнения

### **6. Zombie процессы**

**Zombie (зомби)** - процесс, который завершился, но его статус не был прочитан родителем.

**Причины:**
- Родитель не вызвал `wait()`/`waitpid()`
- Родитель игнорирует сигнал `SIGCHLD`

**Решение:**
```c
// В родительском процессе
signal(SIGCHLD, SIG_IGN);  // Игнорировать сигналы от дочерних процессов
```

### **7. Демоны (Daemons)**

**Демон** - фоновый процесс, не связанный с терминалом.

**Этапы создания демона:**
```c
1. fork() и завершение родителя
2. setsid() - создание новой сессии
3. chdir("/") - смена рабочей директории
4. umask(0) - смена маски прав
5. close() файловых дескрипторов
```

### **8. Планировщик процессов**

**Приоритеты процессов:**
- **Nice value**: от -20 (высокий приоритет) до 19 (низкий)
- **Real-time приоритеты**: от 1 до 99

```bash
# Изменить приоритет
nice -n 10 ./program    # Запуск с низким приоритетом
renice 5 1234          # Изменить приоритет running процесса
```

### **9. Мониторинг процессов**

**Команды для анализа:**
```bash
ps aux                 # Все процессы
top                    # Интерактивный мониторинг
htop                   # Улучшенный top
pidof program_name     # Найти PID процесса
pstree                 # Дерево процессов
lsof -p 1234           # Открытые файлы процесса
/proc/1234/            # Информация о процессе в /proc
```

### **10. Вопросы на собеседовании с ответами**

#### **"Что такое процесс в Linux?"**
**Ответ:** Это экземпляр выполняющейся программы со своим адресным пространством, состоянием и ресурсами.

#### **"Чем процесс отличается от потока?"**
**Ответ:**
- **Процесс**: изолированное адресное пространство, тяжеловесный
- **Поток**: разделяет память с процессом, легковесный
```c
// Процесс - fork()
// Поток - pthread_create()
```

#### **"Что такое zombie процесс и как с ним бороться?"**
**Ответ:** Zombie - завершившийся процесс, чей статус не прочитан родителем. Лечится:
- Родитель должен вызывать `wait()`
- Игнорировать `SIGCHLD`: `signal(SIGCHLD, SIG_IGN)`
- Убить родительский процесс

#### **"Как создать демон-процесс?"**
**Ответ:**
```c
pid_t pid = fork();
if (pid > 0) exit(0);      // Завершаем родителя
setsid();                  // Новая сессия
chdir("/");                // Корневая директория
close(STDIN_FILENO);       // Закрываем стандартные дескрипторы
close(STDOUT_FILENO);
close(STDERR_FILENO);
```

#### **"Что делает команда 'ps aux'?"**
**Ответ:** Показывает все процессы системы с детальной информацией:
- USER - владелец
- PID - идентификатор процесса
- %CPU - использование CPU
- %MEM - использование памяти
- STAT - состояние процесса
- COMMAND - команда запуска

#### **"Как найти и убить процесс?"**
**Ответ:**
```bash
# Найти процесс
ps aux | grep nginx
pidof nginx

# Убить процесс
kill 1234
kill -9 1234                    # Принудительно
pkill nginx                     # По имени
killall nginx                   # Все процессы с именем
```

#### **"Что такое nice value?"**
**Ответ:** Это приоритет планирования от -20 (высший) до 19 (низший). Определяет, как часто процесс получает CPU time.

#### **"Как посмотреть открытые файлы процесса?"**
**Ответ:**
```bash
lsof -p 1234
ls -la /proc/1234/fd/
```

### **11. Практические задачи**

**Задача 1:** Написать программу, создающую 3 дочерних процесса
```c
#include <stdio.h>
#include <unistd.h>

int main() {
    for (int i = 0; i < 3; i++) {
        if (fork() == 0) {
            printf("Child %d, PID: %d, Parent PID: %d\n", i, getpid(), getppid());
            sleep(10);  // Ждем 10 секунд
            return 0;
        }
    }
    
    // Родитель ждет всех детей
    for (int i = 0; i < 3; i++) {
        wait(NULL);
    }
    return 0;
}
```

**Задача 2:** Написать простой демон
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>

int main() {
    pid_t pid = fork();
    if (pid < 0) exit(1);
    if (pid > 0) exit(0);  // Завершаем родителя
    
    umask(0);
    setsid();
    chdir("/");
    
    // Демон работает здесь
    while (1) {
        sleep(10);
        // Фоновая работа
    }
    
    return 0;
}
```

### **Ключевые моменты для собеседования:**
1. Понимание жизненного цикла процесса
2. Умение работать с системными вызовами (fork, exec, wait)
3. Знание состояний процесса
4. Понимание zombie процессов и как их избежать
5. Умение управлять приоритетами
6. Знание команд мониторинга