**Задача сортировки:**
**Вход**: последовательность из n чисел `⟨a1,a2,...,an⟩`.
**Выход**: перестановка (изменение порядка) `⟨a′1,a′2,...,a′n⟩` входной последовательности таким образом, что для ее членов выполняется соотношение `a′1 <= a′2 <= ···<= a′n`.

То есть получаем на вход последовательность чисел, а возвращаем последовательность такой же длины, но отсортированную в соответствии с заданным правилом, например по возрастанию.

Сортируемые числа также называют **ключами**.

**Сортировка вставкой** *(insertion sort)* - работает эффективной для небольшой последовательности чисел. Сортировка вставкой напоминает способ, к которому прибегают игроки для сортировки имеющихся на руках карт. Со стола берутся карты по одной и каждый раз сравниваются с уже отсортированными картами в левой руке. В любой момент времени карты в левой руке будут рассортированы, и это будут те карты, которые первоначально лежали в стопке на столе.

Сортировка вставкой осуществляется без использования дополнительной памяти - *на месте*, то есть модифицируется *изначальный* массив. 

```python

def insertionSort(nums):
	n = len(nums)
	for i in range(1, n):
		for j in range(0, i):
			if nums[j] > nums[i]:
				nums[i], nums[j] = nums[j], nums[i]
	
```

```python

def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]

        j = i - 1
        while j >= 0 and key < arr[j]:
                arr[j + 1] = arr[j]
                j -= 1
        arr[j + 1] = key
        
```

####  Инварианты цикла и корректность сортировки вставкой

То есть на каждой итерации до тех пор, пока текущий  `key` меньше чем предыдущие элементы мы переставляем `arr[j + 1] = arr[j]`, а `key` вставляем в начало (туда где `key` стал больше либо равен текущему элементу)

![[Pasted image 20240614171414.png]]

Итак, `i` соответствует текущему элементу относительно которого будет сортироваться левая часть массива. В начале каждой итерации внешнего цикла, массив `nums` разделен на 2 части: `[0..i - 1]` - отсортированы относительно друг друга,  `[i - 1..n]` еще не отсортированы. Также необходимо отметить, что элементы `[0..i - 1]` изначально находились в этом подмассиве, но в другом  порядке, а теперь они отсортированы. Это свойство элементов `[0..i - 1]` является **инвариантом** цикла.

В начале каждой итерации внешнего цикла, подмассив `[0..i - 1]` содержит те же элементы, которые в нем были с самого начала, но в отсортированном порядке. Инварианты цикла позволяют понять, корректно ли работает алгоритм.

Свойства инвариантов циклов:
- **Инициализация** - справедливы перед инициализацией цикла
- **Сохранение** - если они справедливы перед очередной итерацией цикла, то они справедливы и  после нее
- **Завершение** - по завершении цикла инварианты позволяют убедиться в правильности алгоритма

Если выполняются первые 2 свойства, то инварианты цикла истинны перед каждой очередной итерацией цикла. Обратите внимание на сходство с математической индукцией, когда для доказательства определенного свойства для всех элементов упорядоченной последовательности нужно доказать его справедливость для начального элемента этой последовательности, а затем обосновать шаг индукции. В данном случае первой части доказательства соответствует обоснование того, что инвариант цикла выполняется перед первой итерацией, а второй части — доказательство того, что инвариант цикла выполняется после очередной итерации (шаг индукции).

Для целей алгоритма сортировки третье свойство самое главное, так как позволяет доказать правильность алгоритма. Оно также отличает рассматриваемый нами метод от обычной математической индукции, в которой шаг индукции используется в бесконечных последовательностях. В данном случае по окончании цикла “индукция” завершается.

Свойства инварианта цикла для сортировки вставкой:
**Инициализация** - инвариант цикла справедлив перед первой итерацией цикла, так как цикл начинается с 1, и подмассив `[0..i - 1]` состоит только из одного элемента, который отсортирован, так как он один. Кроме того, он сохраняет исходное положение. Все вышесказанное подтверждает, что инвариант цикла соблюдается перед первой итерацией цикла.
**Сохранение** - инвариант цикла сохраняется после каждой итерации. В теле внешнего цикла происходит сдвиг каждого элемента i - 1 вправо до тех пор, пока массив не освободится подходящее место для nums[i], куда он и помещается. 
**Завершение** - При сортировке методом включений внешний цикл for завершается, когда i превышает n, т.е. когда i = n. Подставив в формулировку инварианта цикла значение n, получим такое утверждение: в подмножестве элементов A [1..n] находятся те же элементы, которые были в нем до начала работы алгоритма, но расположенные в отсортированном порядке. Однако подмножество A[1..n] и есть сам массив A! Таким образом, весь массив отсортирован, что и подтверждает корректность алгоритма.

## Упражнения

1. 2.1-1.  Используя в качестве модели рис.2.2, проиллюстрируйте работу алгоритма  INSERTION_SORT по упорядочению массива A = ⟨31, 41, 59, 26, 41, 58⟩.
![[Pasted image 20240624102754.png]]

![[Pasted image 20240624103836.png]]

1. 2.1-2.  Перепишите процедуру INSERTION_SORT так, чтобы она выполняла сор- тировку не в невозрастающем, а в неубывающем порядке.

```python

def insertionSortReversed(arr):
	n = len(arr)
	for i in range(1, n):
		key = arr[i]
		j = i - 1

		while j >= 0 and key > arr[j]:
			arr[j + 1] = arr[j]
			j -= 1

		arr[j + 1] = key

arr = [31, 41, 59, 26, 41, 58]
print(arr)
insertionSortReversed(arr)
print(arr)

```

Input: [31, 41, 59, 26, 41, 58]
Output: [31, 41, 59, 26, 41, 58]

1. 2.1-3.  Рассмотрим задачу поиска.  
    Вход: последовательность n чисел A=⟨a1,a2,...,an⟩ и величина v.
    
    Выход: индекс i, обладающий свойством v = A[i], или значение NIL, если в массиве A отсутствует значение v.
    
    Составьте псевдокод линейного поиска, при работе которого выполняется сканирование последовательности в поиске значения v. Докажите корректность алгоритма с помощью инварианта цикла. Убедитесь, что выбранные инварианты цикла удовлетворяют трем необходимым условиям.

```python
from typing import List, Union

def linearSearch(arr: List[int], value: int) -> Union[int, None]:
	n = len(arr)
	for i in range(n):
		if arr[i] == value:
			return i

	return None
```

Инвариант цикла - все элементы массива до i не содержать искомого значения
**В элементах A с индексами до [i-1] включительно не содержится v.**

- **Инициализация** - справедливы перед инициализацией цикла - так как i равен 0, то есть первому элементу, до него нет других элементов, а значит так не может быть v
- **Сохранение** - если они справедливы перед очередной итерацией цикла, то они справедливы и  после нее - так как во время каждой итерации мы проверяем, равен ли элемент по индексу i искомому v, то значит что все элементы массива до [i-1] включительно  не содержат v, так как не прошли вышеуказанную проверку.
- **Завершение** - по завершении цикла инварианты позволяют убедиться в правильности алгоритма 
	- если искомый элемент найден, то он будет находиться по индексу i, а все элементы массива до [i-1] включительно  не содержат v, так как не прошли проверку на равенство v.
	- если искомый элемент не найден после прохода по всем элементам массива, то его там нет и соответственно в элементах A с индексами до [i-1] включительно не содержится v

2.1-4.

Рассмотрим задачу сложения двух двоичных целых чисел длиной n битов каждое, хранящихся в массивах A и B, которые состоят из n элементов. Сумму этих двух чисел необходимо занести в двоичной форме в массив C, состоящий из n + 1 элемента. Приведите строгую формулировку задачи и составьте псевдокод для сложения этих двух чисел.

Вход: массив A длинной n, состоящий из чисел 0 или 1, массив B длинной n, состоящий из чисел 0 или 1 - оба массива представляют 
Выход: массив C, состоящий из n + 1 элемента, являющийся суммой 2 предыдущих массивов двоичных целые числа

Код:

```python
def addBinaryNums(a, b):
    n = len(a)
    m = n + 1
    res = [0] * m
    
    reminder = 0
    
    for i in range(n - 1, -1, -1):
        val = a[i] + b[i]
        valR = val + reminder

        if valR > 1:
            if val > 1:
                val = reminder
            else:
                val = 0
            reminder = 1
        else:
            reminder = 0
            val = 1
            
        res[i + 1] = val 
        
    res[0] = reminder
    return res
```

