Анализ алгоритма заключается в том, чтобы предсказать требуемые для его выполнения ресурсы. Как правило анализ производится по времени выполнения, но также может производиться по памяти, пропускной способности сети и т.д. Путем анализа алгоритма можно найти наиболее эффективный для решения поставленной задачи.

#### Анализ алгоритма, работающего по методу вставок

В общем случае время работы алгоритма увеличивается с увеличением количества входных данных, поэтому общепринятая практика — представлять время работы программы как функцию, зависящую от количества входных элементов. Для этого понятия “время работы алгоритма” и “размер входных данных” нужно определить точнее.

Размер входных данных - в зависимости от задачи, в общем случае, это количество входных элементов. В некоторых случаях это общее количество битов, необходимых для представления входных данных в обычных двоичных обозначениях. Иногда размер ввода удобнее описывать с помощью не одного, а двух чисел. Например, если на вход алгоритма подается граф, размер ввода можно описывать, указывая количество вершин и ребер графа. Для каждой рассматриваемой далее задачи будет указываться способ измерения размера входных данных.

Время работы алгоритма - количество элементарных операций, "шагов", которые нужно выполнить для решения задачи. На данном этапе мы будем исходить из точки зрения, согласно которой для выполнения каждой строки псеводкода требуется фиксированное время. Время выполнения различных строк может отличаться, но мы предположим, что одна и та же i-я строка выполняется за время ci, где ci — константа.

![[Pasted image 20240704142531.png]]

Время работы алгоритма — это сумма промежутков времени, необходимых для выполнения каждой входящей в его состав исполняемой инструкции. Если выполнение инструкции длится в течение времени ci и она повторяется в алгоритме n раз, то ее вклад в полное время работы алгоритма равно cin.

Время выполнения INSERTION_SORT:

![[Pasted image 20240704142809.png]]

Время работы алгоритма может зависеть от степени упорядоченности входящих данных, например, в самом благоприятном случае, весь массив уже отсортирован:

![[Pasted image 20240704143006.png]]

Это время работы можно записать как an + b, где a и b — константы, зависящие от величин ci; т.е. это время является линейной функцией от n.

В наихудшем случае, массив отсортирован в обратном порядке, каждый элемент A [j] необходимо сравнивать со всеми элементами уже отсортированного подмножества A[1..j − 1], так что для j = 2,3,...,n значения tj = j.

![[Pasted image 20240704143141.png]]

Это время работы можно записать как an2 + bn + c, где константы a, b и c зависят от ci. Таким образом, это квадратичная функция от n.

#### Наихудшее и среднее время работы

Наиболее показательным является наихудший случай, то есть максимальное время работы алгоритма при всех возможных входных данных размера n.

- Время работы алгоритма в наихудшем случае — это верхний предел этой величины для любых входных данных. Располагая этим значением, мы точно знаем, что для выполнения алгоритма не потребуется большее количество времени.
- В некоторых алгоритмах наихудший случай встречается достаточно часто.
- Характер поведения “усредненного” времени работы часто ничем не лучше поведения времени работы для наихудшего случая.

В некоторых частных случаях нас будет интересовать среднее время работы алгоритма, или его математическое ожидание.

#### Порядок возрастания

Скорость роста (rate of growth), или порядок роста (order of growth), времени работы, который и интересует нас на самом деле. Таким образом, во внимание будет приниматься только главный член формулы (т.е. в нашем случае an2), поскольку при больших n членами меньшего порядка можно пренебречь. Кроме того, постоянные множители при главном члене также будут игнорироваться, так как для оценки вычислительной эффективности алгоритма с входными данными большого объема они менее важны, чем порядок роста.

Таким образом, время алгоритма, работающего по методу вставок, в наихудшем случае равно Θ(n2)

Обычно один алгоритм считается эффективнее другого, если время его работы в наихудшем случае имеет более низкий порядок роста. Из-за наличия постоянных множителей и второстепенных членов эта оценка может быть ошибочной, если входные данные невелики. Однако если объем входных данных значительный, то, например, алгоритм Θ􏰇n2􏰈 в наихудшем случае работает быстрее, чем алгоритм Θ 􏰇n3􏰈.

### Упражнения

2.2-1.  Выразите функцию n3/1000 − 100n2 − 100n + 3 в Θ-обозначениях.

Так как интересует главный член формулы, мы отбросим все кроме n3/1000. При этом нас также не интересуют постоянные множители, поэтому n3.

2.2-2.  Рассмотрим сортировку элементов массива A, которая производится так. Сначала определяется наименьший элемент массива A, который ставится на место элемента A [1], затем производится поиск второго наименьшего элемента массива A, который ставится на место элемента A [2]. Этот процесс продолжается для первых n − 1 элементов массива A. Запишите псевдокод этого алгоритма, известного как сортировка выбором (selection sort). Какой инвариант цикла сохраняется для этого алгоритма? Почему его достаточно выполнить для первых n − 1 элементов, а не для всех n элементов? Определите время работы алгоритма в наилучшем и наихудшем случаях и запишите его в Θ-обозначениях.

```python

def selection_sort(a):
	n = len(a)
	for i in range(n - 1):
		m = i
		for j in range(i + 1, n):
		    if a[j] < a[m]:
		        m = j
		        
		a[i], a[m] = a[m], a[i]
		
```

Этот процесс выполняется для первых n − 1 элементов массива A, так как из-за того, что мы меняем местами текущий и текущий минимальный элементы массива, последний элемент будет всегда больше предпоследнего, так как они обменяются местами и, следовательно, ненужно выполнять n итераций. 

Инвариант - все элементы до i упорядочены, так как на соотв. позицию встает текущий минимальный элемент подмассива. 

Время выполнения будет O(n^2), так как тут 2 вложенных цикла.

2.2-3.  Рассмотрим алгоритм линейного поиска (см. упражнение 2.1-3). Для скольких элементов входной последовательности в среднем нужно произвести проверку, если предполагается, что все элементы массива с равной вероятностью могут иметь искомое значение? Что происходит в наихудшем случае? Чему равно время работы алгоритма линейного поиска в среднем и в наихудшем случае (в Θ-обозначениях)? Обоснуйте ваш ответ.

В среднем для половины элементов. В наихудшем случае искомый элемент будет в конце массива или его вовсе не будет, поэтому алгоритм выполнится n раз. В любом случае, время выполнения будет O(n).

2.2-4.  Каким образом можно модифицировать почти каждый алгоритм, чтобы получить оптимальное время работы в наилучшем случае?

Добавить в начале проверку.
