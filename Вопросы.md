## HTML/ CSS

  

##### **Что такое семантика в HTML?**
Одна из важных особенностей HTML — семантика, которая буквально переводится как «обозначающий». При помощи HTML мы описываем структуру страниц и их содержимого, то есть объясняем браузерам, вспомогательным и другим технологиям и программам _значение элементов_. Это может быть параграф текста, кнопка, часть страницы с основным содержимым или ничего не значащий контейнер.

На практике семантика HTML-элементов передаётся через их [роли](https://doka.guide/a11y/aria-roles/), а ещё [состояния и свойства](https://doka.guide/a11y/aria-attrs/). Роли описывают основной смысл элемента, а состояния и свойства добавляют больше деталей: выбран или не выбран чекбокс, активно или неактивно поле в форме и так далее.
Все HTML-теги, которых больше 100, семантические. Для простоты разделим их на две группы — секционные и контентные. Полный список элементов найдёте [в HTML Living Standard](https://html.spec.whatwg.org/multipage/).

Секционные теги делят HTML-документ (страницу) на большие логические блоки или секции:

- [`<article>`](https://doka.guide/html/article/) — самостоятельный блок с содержимым вроде превью поста в блоге, карточки товара или рекламного баннера. Такой контент не потеряет смысл, если его перенести на другую страницу или сайт.
- [`<nav>`](https://doka.guide/html/nav/) — основная или дополнительная навигация со ссылками на другие страницы или отдельные разделы.
- [`<section>`](https://doka.guide/html/section/) — блок, который объединяет содержимое по смыслу.
- [`<main>`](https://doka.guide/html/main/) — основное содержимое страницы.
- [`<header>`](https://doka.guide/html/header/) — вводное содержимое или навигация. Не привязан к конкретному месту страницы и отдельной секции, но традиционно используется для создания основной навигации по сайту — шапки (хедера). Также можно использовать для оборачивания оглавления раздела, заголовка статьи с вводной информацией о ней и прочего.
- [`<footer>`](https://doka.guide/html/footer/) — дополнительная информация о сайте или части одной страницы. Тоже не привязан к части страницы или отдельной секции. Например, подвал (футер) может быть у превью поста и содержать информацию о дате публикации и авторе.
Контентные теги описывают смысл частичек и типов содержимого — контента. Перечислим несколько тегов, на самом деле их гораздо больше:

- [`<h1>`-`<h6>`](https://doka.guide/html/h1-h6/) для определения заголовков на странице. `<h1>` используют для основного заголовка документа или раздела. Остальные нужны для подзаголовков. Все заголовки описывают структуру и иерархию страниц.
- [`<button>`](https://doka.guide/html/button/) для кнопок. Используют для отправки форм и выполнения других команд.
- [`<img>`](https://doka.guide/html/img/) для картинок.
- [`<table>`](https://doka.guide/html/tables/) для таблиц. Состоят из нескольких элементов для структурирования табличных данных: строк `<tr>`, заголовочных ячеек `<th>` и ячеек с данными `<td>`.
- [`<ul>`](https://doka.guide/html/ul/) неупорядоченный маркированный список.
- [`<a>`](https://doka.guide/html/a/) для ссылок, с помощью которых пользователи переходят от одной страницы к другой.
- [`<p>`](https://doka.guide/html/p/) для абзацев текста. Это основные блоки текста в HTML; логически разграничивают части текста с общей мыслью или идеей.
###### Поддержка и читаемость кода

 Скопировать ссылку "Поддержка и читаемость кода"

Исходный код проекта с вниманием к семантике легче поддерживать. В нём проще ориентироваться, а любой член команды сразу видит логику отдельных элементов и общую структуру интерфейса. Польза семантики особенно заметна, когда проект постоянно развивается и обзаводится новыми компонентами. В такой код проще и быстрее вносить изменения.
###### UX, юзабилити и доступность

 Скопировать ссылку "UX, юзабилити и доступность"

Семантика — основа хорошего пользовательского опыта или UX (user experience). Хороший UX складывается из лёгкого и успешного взаимодействия с интерфейсами (юзабилити), полезного содержимого, доступности для пользователей с инвалидностью и общей удовлетворённости от всего процесса.
###### Браузеры, расширения и другие технологии

 Скопировать ссылку "Браузеры, расширения и другие технологии"

Семантика приносит пользу и самим браузерам. К примеру, во все браузеры встроен _режим чтения (reading mode)_. В нём со страницы удаляются все лишние элементы и остаётся самое важное: заголовки, текст, картинки и видео. Если страница, например, свёрстана без `<h1>`, `<h2>` и заголовков других уровней, пользователи получат большой кусок неструктурированного текста. Такие же проблемы будут и у сервисов для RSS (really simple syndication) и отложенного чтения и закладок вроде Pocket.
###### Поисковая оптимизация

 Скопировать ссылку "Поисковая оптимизация"

Поисковики стерпят всё и поймут вас в любом случае, даже если общаетесь с ними на языке дивов. Однако семантика упрощает им работу и позитивно влияет на поисковую оптимизацию сайтов — SEO (search engine optimization), а именно:

- улучшает точность индексации страниц;
- повышает показатели производительности сайта;
- увеличивает органический трафик и количество кликов;
- гарантирует ~~спокойную старость~~ спокойное будущее.
**Более точная индексация**. Семантика дополняет другие факторы ранжирования и раскрывает больше информации о структуре сайта, темах страниц и связях между разными видами контента. Поисковые роботы точнее определяют главную тему страницы по заголовку `<h1>` и атрибуту [`title`](https://doka.guide/html/title/).
**Лучшая производительность**. Производительность — ещё один ключевой фактор ранжирования. Браузеры лучше работают с чистым и хорошо организованным кодом. Семантическая разметка как раз избавляет от лишнего JavaScript и CSS, а это ускоряет загрузку страниц.
**Рост органического трафика**. Органический трафик (organic traffic) — это количество пользователей, которые перешли на сайт из поисковой выдачи, а не по рекламным ссылкам и баннерам.

##### Блочные и строчные элементы
Исторически HTML-элементы было принято делить на блочные и строчные. Блочные элементы занимают всю ширину своего родителя (контейнера), формально создавая «блок» (отсюда и название).

Браузеры обычно отображают блочные элементы с переводом строки до и после элемента. Блочные элементы можно представить в виде стопки коробок.
Существует несколько ключевых отличий между блочными и строчными элементами:

[Содержание](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)

Как правило, блочные элементы могут содержать строчные элементы и другие блочные элементы. Неотъемлемой частью этого структурного различия является идея, что блочные элементы создают «более крупную» структуру, чем встроенные элементы.

[Форматирование по умолчанию](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)

По умолчанию блочные элементы начинаются с новой строки, а строчные могут начинаться в любом месте строки.

Разделение элементов на блочные и строчные использовалось в спецификации HTML до версии 4.01. В HTML5 это противопоставление заменено более сложным набором [категорий контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories). Категория «строчных» элементов примерно соответствует категории [текстового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#phrasing_content), а для «блочных» элементов прямого соответствия нет, но «блочные» и «строчные» элементы вместе примерно соответствуют категории [потокового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B9_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA) в HTML5 (т.е., грубо говоря, «блочные» элементы — это потоковый контент минус текстовый контент). Кроме того, есть и другие категории, например, интерактивный контент.
Блочным называется элемент, который занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство [display](https://webref.ru/css/display) задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов. В частности, это `<address>, <blockquote>, <h1>…<h6>, <p>, <ol>, <ul>, <section>, <div> `и др.

###### Особенности блочных элементов

Для блочных элементов характерны следующие особенности.

**По ширине блочные элементы занимают всё допустимое пространство.**

Если элемент располагается непосредственно внутри `<body>`, то он будет занимать всю ширину веб-страницы. Если один элемент находится внутри другого, то он будет занимать всю ширину своего родителя. В примере 1 показано, как это получается.

**Ширина блока складывается из значений свойств width, padding, border и margin.**

В примере 1 намеренно не указано свойство width, которое определяет ширину содержимого блока. Как только мы добавляем width, то блок уже не будет занимать всё доступное пространство по ширине. При этом ширина самого блока определяется сложением значений margin-left, border-left, padding-left, width, padding-right, border-right, margin-right. Иными словами, ширина содержимого плюс значения свойств padding, border и margin слева и справа

**Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.**

Для высоты элемента работают те же принципы, что и для ширины, за исключением того, что высота блока зависит от высоты содержимого и меняется динамически, например, при изменении размера шрифта или окна браузера. Если явно установить высоту содержимого через свойство height, то высота блока складывается из height и значений margin, border, padding сверху и снизу

**Блоки располагаются по вертикали друг под другом.**

Поскольку блочные элементы занимают всё доступное пространство по ширине, то они располагаются друг под другом по вертикали.

**На блочные элементы не действуют свойства, предназначенные для строчных элементов.**

Ряд стилевых свойств, вроде vertical-align, работает только для строчных элементов и их применение к блочным элементам не даёт никакого видимого результата.

###### Строчные
Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства [display](https://webref.ru/css/display) установлено как inline. Элементы, для которых это значение задано по умолчанию, — `<span>, <a>, <q>, <code>` и др., в основном они используются для изменения вида текста или его смыслового выделения.

**Свойства, связанные с размерами (width, height), не применимы.**

Размеры строчных элементов определяются их содержимым и не могут напрямую меняться с помощью свойств width и height, которые, соответственно, задают ширину и высоту элемента. Добавление этих свойств к строчным элементам просто игнорируется.

**Размер элемента равен его содержимому плюс значения margin, border и padding.**

Несмотря на то, что явно задать размеры элемента нельзя, на него можно влиять косвенно с помощью свойств margin, border и padding, значения которых суммируются с размерами содержимого (пример 1).

Пример 1. Размеры элемента

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Размеры элемента</title>
  <style>
   h1 {
    background: #EDE6CE; /* Цвет фона */
   }
   h1 span {
    margin: 16px; /* Отступы */
    padding: 1px; /* Поля */
    border-bottom: 2px solid #D71920; /* Линия снизу */
   }
  </style>
 </head>
 <body>
  <h1><span>Заголовок</span></h1>
 </body>
</html>
```

В данном примере внутрь блочного элемента `<h1>` добавлен строчный элемент `<span>` и для него уже заданы свойства margin, padding и border. Это сделано для того, чтобы линия была строго под текстом (рис. 1), а не на всю длину блока, как получилось бы, добавь мы border для h1 напрямую.

**Перенос текста считается за пробел.**

В коде HTML любой перенос текста воспринимается браузером как пробел, это касается и размещения элементов на отдельных строках. Сравните два абзаца в примере 3. В первом абзаце каждый `<span>` располагается на отдельной строке, а во втором абзаце код идёт сплошной строкой без пробелов и переносов.

**Срочные элементы переносятся на другую строку при необходимости.**

Раз мы имеем дело со строками, то текст, естественно, переносится, чтобы строка целиком поместилась по ширине. Перенос текста, как правило, происходит в месте пробела и может разделить наш строчный элемент на две части и более. Это не страшно, пока к элементу не применяется стилевое оформление.

**Можно выравнивать по вертикали с помощью свойства vertical-align.**

Свойство [vertical-align](https://webref.ru/css/vertical-align) выравнивает элементы относительно друг друга по вертикали, что позволяет делать верхний и нижний индексы, задавать выравнивание содержимого ячеек таблицы, задавать положение блоков и др. В примере 4 показано выравнивание картинок и текста по середине друг друга.


##### Для чего нужен DOCTYPE?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-doctype "Прямая ссылка на Для чего нужен DOCTYPE?")

  

**DOCTYPE** — это сокращение от **DOCument TYPE** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег `button` может содержать в себе тег `span`, но не `div`), в то время как DOCTYPE объявляет, к какому DTD _предположительно_ относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим **no-quirks**, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим **quirks**.

DOCTYPE для стандарта HTML5 определяется как `<!DOCTYPE html>`.

  
##### Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B5%D0%B9-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%BE%D0%B9-%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D1%8C-link-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-css-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-headhead-%D0%B0-script-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-js-%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-body-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F "Прямая ссылка на почему-хорошей-практикой-считается-располагать-link-для-подключения-css-между-headhead-а-script-для-подключения-js-ставить-перед-body-знаете-ли-вы-исключения")

**Размещение `<link>` внутри `<head>`**

Размещение `<link>` внутри тега `<head>` необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

**Размещение `<script>` прямо перед `</body>`**

Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.
##### Что такое прогрессивный рендеринг[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3 "Прямая ссылка на Что такое прогрессивный рендеринг")

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события `DOMContentLoaded` или `load`, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать [в этой статье](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/).

##### Поток документа

Это принцип организации элементов на странице при отсутствии стилей: если мы напишем HTML и не напишем CSS, то отображение в браузере будет предсказуемо благодаря тому, что мы абсолютно точно знаем, как браузер располагает элементы в потоке.

Даже если к странице не подключено никаких стилей, к каждому элементу всё равно будут применяться CSS-правила, «зашитые» в движке браузера.

Правила расположения строчных и блочных элементов в нормальном потоке называются **контекстом форматирования**. Блочные элементы участвуют в формировании **блочного** контекста форматирования. Строчные элементы формируют **строчный** контекст форматирования. Расположение элементов в контексте форматирования зависит от направления письма для конкретного языка. Например, тексты на европейских языках мы читаем и пишем слева направо сверху вниз. Это означает, что по умолчанию контекст форматирования располагает блочные элементы сверху вниз, а строчные — слева направо.
###### Блочные элементы в нормальном потоке

 Скопировать ссылку "Блочные элементы в нормальном потоке"

Блочные элементы в нормальном потоке располагаются друг под другом, всегда занимая всю доступную ширину родителя. Высота блочного элемента по умолчанию равна высоте его содержимого. Три абзаца, идущие друг за другом в HTML, будут располагаться точно в таком же порядке и на странице.

Даже если ширина блочного элемента явно задана и позволяет разместить справа ещё один такой элемент, поток всё равно продолжит выстраивать их друг под другом.

###### Строчные элементы в нормальном потоке

 Скопировать ссылку "Строчные элементы в нормальном потоке"

Строчные элементы располагаются друг за другом, как слова в предложении. В зависимости от направления письма в конкретном языке элементы могут располагаться слева направо (например, в русском языке), справа налево (как, например, в иврите) и даже сверху вниз (как иероглифы и знаки слоговых азбук в японском вертикальном письме). Ширина и высота строчного элемента равна ширине и высоте содержимого. В отличие от блочного элемента, мы не можем управлять шириной и высотой строчного элемента через CSS. Несколько строчных элементов будут стремиться уместиться на одной строке, насколько хватает ширины родителя. Если ширины родителя не хватает, то лишний текст строчного элемента переносится на следующую строку.

###### Схлопывание и выпадение отступов

 Скопировать ссылку "Схлопывание и выпадение отступов"

В рамках блочного контекста форматирования вертикальные расстояния между блоками задаются CSS-свойством [`margin`](https://doka.guide/css/margin/). Если блоку задан нижний отступ, а следующему за ним — верхний, то можно ожидать, что итоговый отступ между блоками будет равен сумме этих двух отступов. Но в соответствии со спецификацией соприкасающиеся отступы «схлопываются». То есть как бы проваливаются один в другой. Итоговый отступ будет равен бо́льшему отступу из двух.

Выпадение отступов из родителя можно предотвратить несколькими способами, например:

- Задать родителю вертикальный внутренний отступ [`padding-top`](https://doka.guide/css/padding/) или [`padding-bottom`](https://doka.guide/css/padding/) в зависимости от того, с какой стороны мы хотим предотвратить выпадение.
- Задать родителю верхнюю или нижнюю [рамку](https://doka.guide/css/border/) по такой же логике. Рамка может быть прозрачной, главное, чтобы она была :)
- Задать родителю свойство [`overflow`](https://doka.guide/css/overflow/) со значением, отличным от `visible`.
- Переопределить родителю свойство [`display`](https://doka.guide/css/display/) на `flow-root`, либо на `flex` или `grid` (но в последнем случае его потомки будут раскладываться уже не по правилам нормального потока, а по правилам [флексбоксов](https://doka.guide/css/flexbox-guide/) и [грид-раскладки](https://doka.guide/css/grid-guide/) соответственно).


https://doka.guide/html/flow/

##### **Что такое селекторы в CSS?**

**Селектор** определяет, к какому элементу применять то или иное CSS-правило.

  

##### **Что такое специфичность в CSS?**

**Специфичность** - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу и, следовательно, будут применены. Специфичность основана на правилах соответствия, состоящих из [селекторов CSS](https://developer.mozilla.org/ru/docs/Web/CSS/Reference#selectors) различных типов.

Специфичность представляет собой вес, придаваемый конкретному правилу CSS. Вес правила определяется количеством каждого из [типов селекторов](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#selector_types) в данном правиле. Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS. Специфичность имеет значение только в том случае, если один элемент соответствует нескольким правилам. Согласно спецификации CSS, правило для непосредственно соответствующего элемента всегда будет иметь больший приоритет, чем правила, унаследованные от предка.

В следующем списке типы селекторов расположены по возрастанию специфичности:

1. селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
2. селекторы классов (например, `.example`), селекторы атрибутов (например, `[type="radio"]`) и псевдоклассов (например, `:hover`).
3. селекторы идентификаторов (например, `#example`).

Универсальный селектор (`*`), комбинаторы (`+`, `>`, `~`, '``') и отрицающий псевдокласс (`:not()`) не влияют на специфичность. (Однако селекторы, объявленные _внутри_ `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

###### [Важное исключение из правил - `!important`](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#%D0%B2%D0%B0%D0%B6%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB_-_!important)

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений. Хотя технически модификатор `!important` не имеет со специфичностью ничего общего, он непосредственно на неё влияет. Поскольку `!important` усложняет отладку, нарушая естественное [каскадирование](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade) ваших стилей, он **не приветствуется** и следует избегать его использования. Если к элементу применимы два взаимоисключающих стиля с модификатором `!important`, то применён будет стиль с большей специфичностью.

**Несколько практических советов:**

- **Всегда пытайтесь использовать** специфичность, а `!important` используйте только в крайних случаях
- **Используйте** `!important` **только** в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- **Никогда не используйте** `!important`, если вы пишете плагин или мэшап.
- **Никогда не используйте** `!important` в общем CSS сайта.

**Вместо `!important` можно:**

1. Лучше использовать каскадные свойства CSS
    
2. Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:
    
    htmlCopy to Clipboard
    
    ```css
    <div id="test">
      <span>Text</span>
    </div>
    ```
    
    cssCopy to Clipboard
    
    ```css
    div#test span {
      color: green;
    }
    div span {
      color: blue;
    }
    span {
      color: red;
    }
    ```
    

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

**Вам придётся использовать `!important` если:**

А) Первый сценарий:

1. У вас есть общий файл стилей, устанавливающий правила для внешнего вида сайта.
2. Вы пользуетесь (или кто-то другой пользуется) весьма сомнительным средством - объявлением стилей непосредственно в элементах

В таком случае вам придётся объявить некоторые стили в вашем общем файле CSS как `!important`, переопределяя, таким образом, стили, установленные в самих элементах.

Пример из практики: Некоторые плохо написанные **плагины jQuery**, использующие присваивание стилей самим элементам.

Б) Ещё сценарий:

cssCopy to Clipboard

```css
#someElement p {
  color: blue;
}

p.awesome {
  color: red;
}
```

Как сделать цвет текста в абзацах `awesome` красным всегда, даже если они расположены внутри `#someElement`? Без `!important` у первого правила специфичность больше и оно имеет преимущество перед вторым.

**Как преодолеть !important:**

A) Просто добавьте ещё одно правило с модификатором `!important`, у которого селектор имеет большую специфичность (благодаря добавлению типа элемента (тэга), идентификатора (атрибута id) или класса к селектору).

Пример большей специфичности:

cssCopy to Clipboard

```css
table td {
  height: 50px !important;
}
.myTable td {
  height: 50px !important;
}
#myTable td {
  height: 50px !important;
}
```

Б) Или добавьте правило с модификатором `!important` и таким же селектором, но расположенное в файле после существующего (при прочих равных выигрывает последнее объявленное правило):

cssCopy to Clipboard

```css
td {
  height: 50px !important;
}
```

В) Или перепишите первоначальное правило без использования `!important`.

Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. Правило [каскада](https://doka.guide/css/cascade/) «кто ниже, тот и выигрывает» при этом может нарушаться.

Специфичность — это одно из базовых понятий в CSS.

###### Вес селекторов

 Скопировать ссылку "Вес селекторов"

Давайте разберёмся, как браузер _взвешивает_ селектор. Ниже перечислены типы селекторов по убыванию специфичности:

1. [Селекторы по идентификатору](https://doka.guide/css/id-selector/);
2. [Селекторы по классу](https://doka.guide/css/class-selector/), [селекторы по атрибуту](https://doka.guide/css/attribute-selector/) и селекторы с [псевдоклассами](https://doka.guide/css/pseudoclasses/);
3. [Селекторы по тегу](https://doka.guide/css/tag-selector/), селекторы с [псевдоэлементами](https://doka.guide/css/pseudoelements/).

Комбинаторы `+`, `>`, `~`, [универсальный селектор `*`](https://doka.guide/css/universal-selector/) и псевдокласс [`:where()`](https://doka.guide/css/where/) веса не имеют.

Псевдоклассы [`:is()`](https://doka.guide/css/is/), [`:has()`](https://doka.guide/css/has/) и [`:not()`](https://doka.guide/css/not/) принимают вес наиболее специфичного селектора внутри скобок.

###### Система расчёта

 Скопировать ссылку "Система расчёта"

Существует удобный способ вычисления веса селектора в уме. Выше мы перечислили три группы сущностей, из которых может состоять селектор. Представим любой селектор в виде трёх нулей: 0.0.0.

- Селекторы по идентификатору увеличивают первую цифру.
- Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.
- Селектор по тегу или псевдоэлемент увеличивают третью цифру.

Один селектор равен единице.

Пока сложно понять. Давайте разберёмся на примерах.

- Селектор `#some` состоит из одного идентификатора. Один селектор = 1. Увеличиваем первую цифру на 1. В итоге вес такого селектора равен 1.0.0.
- `.class` состоит из одного класса. Увеличиваем вторую цифру на 1. Получаем вес селектора 0.1.0.
- `section` состоит из одного тега. Увеличиваем последнюю цифру на 1. Вес селектора равен 0.0.1.

Дальше аналогично можем посчитать вес комбинированных селекторов.

`div#some` состоит из одного селектора по тегу и одного идентификатора. Селектор по тегу увеличивает последнюю цифру, селектор по идентификатору — первую. Вес селектора равен 1.0.1.

`section h1` состоит из двух селекторов по тегу. Увеличиваем последнюю цифру на два и получаем вес 0.0.2.

`#block section > .list a` состоит из идентификатора (первая цифра), двух тегов (последняя цифра) и класса (вторая цифра). Вес селектора равен 1.1.2.

`* .list a` состоит из одного класса и одного тега. Итоговый вес будет 0.1.1. Универсальный селектор ничего не весит 🪶

Для наглядности расположим селекторы по убыванию веса. Сверху самый тяжёлый.

|Селектор|Вес|
|---|---|
|`#block section > .list a`|1.1.2|
|`div#some`|1.0.1|
|`#some`|1.0.0|
|`* .list a`|0.1.1|
|`.class`|0.1.0|
|`section h1`|0.0.2|
|`section`|0.0.1|

Если не очень хочется считать в уме, можно воспользоваться калькулятором специфичности [CSS Specificity calculator](https://polypane.app/css-specificity-calculator/).

###### Атрибут `style`

 Скопировать ссылку "Атрибут style"

CSS-свойства, написанные в атрибуте [`style`](https://doka.guide/html/global-attrs/) внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега [`<style>`](https://doka.guide/html/style/). Так что формально атрибут `style` самый специфичный, у него самый большой вес.

Иногда его добавляют в формулу в виде четвёртой цифры, стоящей перед всеми. Посмотрим на примере:

`<div class="element" id="this" style="color: purple; border: none">   Some smart text </div>`
Скопировать

`div.element#this {   color: green;   border: 10px solid red; }`
Скопировать

У селектора в CSS будет специфичность 1.1.1, потому что там указан один идентификатор, один класс и один селектор тега. Но в итоге текст в блоке будет пурпурным, а рамки не будет совсем. Потому что у атрибута `style` вес равен 1.0.0.0 🏋️

###### `!important`

 Скопировать ссылку "!important"

Ключевое слово [`!important`](https://doka.guide/css/important/) нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Будет так, и никак иначе.

Формально это ключевое слово не имеет отношения к концепции специфичности. Но из-за его варварских замашек нельзя не принимать его во внимание.

Тут к месту будет ещё раз напомнить, что ключевое слово `!important` всегда стоит использовать с осторожностью и не злоупотреблять им. В том числе из-за того, что оно нарушает естественную работу специфичности и [каскада](https://doka.guide/css/cascade/).

##### **Как работает свойство `position` в CSS?**

https://doka.guide/css/position/

Свойство `position` задаёт способ позиционирования элемента в документе. Совместно со свойствами `left`, `right`, `top`, `bottom` или [`inset`](https://doka.guide/css/inset/) элементу задаётся его местоположение на странице.

###### Пример

 Скопировать ссылку "Пример"

`.box {   position: absolute;   left: 0;   top: 20px; }`
Скопировать

###### Как понять

 Скопировать ссылку "Как понять"

Иногда в процессе вёрстки требуется реализовать разные сложные идеи дизайнера про расположение элементов друг относительно друга. Например, расположить один элемент поверх другого или немного сместить отображение элемента относительно своего начального положения. Бывают и более сложные случаи, когда требуется зафиксировать элемент относительно окна браузера, а не относительно страницы. Базовым свойством, которое изменяет способ позиционирования, является свойство `position`.

###### Как пишется

 Скопировать ссылку "Как пишется"

###### `static`

 Скопировать ссылку "static"

Значение по умолчанию. Статичное позиционирование. Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в [нормальном потоке](https://doka.guide/html/flow/) документа согласно контексту форматирования родительского элемента. Свойства `left`, `right`, `top`, `bottom` и [`z-index`](https://doka.guide/css/z-index/) игнорируются.

Элемент со значением `position: static` **не является** позиционированным элементом. Это важный момент, потому что элементы с любым другим значением свойства `position` создают внутри себя [контекст наложения](https://doka.guide/css/stacking-context/) и становятся **опорными**. _Опорным элементом_ будем называть такой, относительно которого позиционируются дочерние элементы.

###### `relative`

 Скопировать ссылку "relative"

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom` или `inset`. Это смещение **чисто визуальное** и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки.

На странице элемент будет занимать столько же места, как если бы он имел статичное позиционирование.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/relative/)

###### `absolute`

 Скопировать ссылку "absolute"

Способ позиционирования, кажущийся наиболее понятным. Мы просто задаём абсолютное позиционирование и при помощи свойств `left`, `right`, `top`, `bottom` или `inset` регулируем положение элемента. Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть браузер идёт вверх по дереву элементов и ищет ближайшего _опорного_ родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/absolute/)

###### `fixed`

 Скопировать ссылку "fixed"

Иногда требуется позиционировать элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности. Для решения подобной задачи подходит `position: fixed`. Свойство так же, как и предыдущее, работает с указанием смещения `left`, `right`, `top`, `bottom` или `inset`. У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера, за исключением случаев, если один из родителей имеет значения свойств [`transform`](https://doka.guide/css/transform/), [`perspective`](https://doka.guide/css/perspective/) или `filter`, отличные от `none`. В этом случае блок становится _опорным_, и позиционирование будет производиться уже относительно него, а не окна браузера.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/fixed/)

###### `sticky`

 Скопировать ссылку "sticky"

Элемент позиционируется в нормальном потоке так же, как и статичный, а затем смещается при помощи свойств `left`, `right`, `top`, `bottom` или `inset` относительно ближайшего родителя, имеющего прокрутку. Это свойство применяется, когда нам нужно зафиксировать какой-либо элемент не сразу, а при прокрутке родителя до какого-то известного положения.

Например, в следующем примере элемент будет вести себя как обычно, до тех пор, пока родитель не будет прокручен таким образом, что расстояние от верха родителя до верхней границы элемента не станет меньше 10 пикселей. Как только прокрутка достигнет такого значения, элемент зафиксируется в положении 10 пикселей от верха границы родителя:

`.block {   position: sticky;   top: 10px; }`
Скопировать

У такого позиционирования есть ряд особенностей:

- Элемент ведёт себя как элемент с относительным (`relative`) позиционированием до тех пор, пока его родитель не будет прокручен до определённой границы. Как правило, эта точка совпадает с положением верхней границы нашего элемента, но может быть изменена с использованием свойства `top`.
- Элемент остаётся «приклеенным» во время прокрутки родителя до тех пор, пока не «встретит» противоположную границу своего родителя.

##### **Что такое Box Model?** border-box/content-box
https://doka.guide/css/box-model/

Блочная модель, она же box model — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке. Чтобы точно понимать, каким в итоге получится блок и сколько места он займёт, держите в голове следующую картинку:

![Схематичное изображение блочной модели](https://doka.guide/css/box-model/images/box-model-300w.png)

Ровно такую же схему, но в других цветах можно увидеть в инструментах разработчика любого из браузеров. Например, так выглядит блочная модель элемента в Chrome:

![Скриншот блочной модели из инструментов разработчика браузера Chrome](https://doka.guide/css/box-model/images/box-model-chrome-300w.png)

Блочная модель состоит из нескольких CSS-свойств, влияющих на размеры элемента:

- `width` — ширина элемента;
- `height` — высота элемента;
- `padding` — внутренние отступы от контента до краёв элемента;
- `border` — рамка, идущая по краю элемента;
- `margin` — внешние отступы вокруг элемента.

###### Ширина и высота

 Скопировать ссылку "Ширина и высота"

При помощи свойств [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) можно задавать размеры контентной области блока.

_Контентной областью_ называется условное внутреннее пространство блока, где располагается контент. В примере ниже мы создаём блок при помощи тега [`<div>`](https://doka.guide/html/div/), а внутрь вкладываем контент — текст:

`<div>   Вместе весело шагать по просторам! </div>`
Скопировать

По умолчанию элементы с блочным отображением (`display: block`) занимают всю ширину родителя, если явно не задано другое. А вот высота элемента подстраивается под контент.

Элементы со строчным (`display: inline`) или строчно-блочным (`display: inline-block`) отображениями по умолчанию подстраивают и ширину, и высоту под вложенный контент. Однако строчно-блочному можно и произвольно задать размеры: ширину (`width`) и высоту (`height`).

Если элемент должен занимать больше места, чем вложенный в него контент, то мы меняем его ширину и высоту так, как нам захочется. Напишем стили для примера выше:

`div {   width: 200px;   height: 200px; }`
Скопировать

Теперь элемент будет размером 200 на 200 пикселей.

###### `padding`

 Скопировать ссылку "padding"

Свойство [`padding`](https://doka.guide/css/padding/) отвечает за внутренние отступы. В рамках разговора о блочной модели важно помнить, что по умолчанию внутренние отступы прибавляются к ширине и высоте элемента.

Добавим к стилям из примера выше внутренние отступы:

`div {   width: 200px;   height: 200px;   padding: 25px 15px; }`
Скопировать

Теперь ширина блока будет равна 200 + 15 + 15 = 230 пикселей. А высота будет равна 200 + 25 + 25 = 250 пикселей. Внутренние отступы прибавились к ширине и высоте.

###### `border`

 Скопировать ссылку "border"

При определении размеров элемента в расчёт берутся и рамки, за которые отвечает свойство [`border`](https://doka.guide/css/border/).

Пусть у элемента из примера выше будет рамка со всех сторон:

`div {   width: 200px;   height: 200px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

Теперь конечные размеры элемента будут:

- 200 + 15 + 15 + 5 + 5 = 240 пикселей в ширину
- 200 + 25 + 25 + 5 + 5 = 260 пикселей в высоту

###### `margin`

 Скопировать ссылку "margin"

Внешние отступы, за которые отвечает свойство [`margin`](https://doka.guide/css/margin/), не прибавляются непосредственно к размерам элемента, но влияют на то, сколько места на странице он занимает.

Если элементу из нашего примера мы зададим внешние отступы, то он будет занимать больше места, двигая при этом своих соседей:

`div {   width: 200px;   height: 200px;   margin: 50px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

###### `box-sizing`

 Скопировать ссылку "box-sizing"

По умолчанию браузеры рассчитывают размеры элемента ровно так, как описано выше, прибавляя внутренние отступы и рамки к ширине и высоте. С этим могут быть связаны неприятные сюрпризы, когда элемент в вёрстке занимает больше места, чем вы ожидаете.

Мы можем поменять стандартное поведение и указать браузеру, что ширина и высота, заданные в CSS, должны включать в себя, в том числе, внутренние отступы и рамки. Делается это при помощи свойства [`box-sizing`](https://doka.guide/css/box-sizing/).
По умолчанию размером элемента считается размер контентной области. Если кроме [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) указать ещё и [`padding`](https://doka.guide/css/padding/) с [`border`](https://doka.guide/css/border/), то браузер посчитает размер элемента как `width + padding * 2 + border * 2` и `height + padding * 2 + border * 2`.

🤖 Если задать значение `border-box` для свойства `box-sizing`, то браузер изменит принцип расчёта и `padding` с `border` уже будут включены в `width` и `height`.

https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Introduction_to_the_CSS_box_model


##### Единицы измерения  CSS


https://doka.guide/css/numeric-types/
https://learn.javascript.ru/css-units
https://www.w3.org/Style/Examples/007/units.ru.html

###### Относительные величины

 Скопировать ссылку "Относительные величины"

Используются для задания размера или расстояния относительно чего-либо. Например, `vh` считается относительно высоты вьюпорта (области просмотра страницы в окне браузера).

- [`em`](https://doka.guide/css/rem-em/) задаёт величину относительно вычисленного размера шрифта элемента. Если для элемента `font-size: 20px`, то `2em` будут эквивалентны `40px`. При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.
- [`rem`](https://doka.guide/css/rem-em/) рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/). По умолчанию размер шрифта для `<html>` равен `16px`. При таких условиях `2rem` эквивалентны `32px`.
- [`vh`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от высоты вьюпорта. `1vh` составляет 1% от высоты.
- [`vw`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от ширины вьюпорта. `1vw` составляет 1% от ширины.
- [`vmin`](https://doka.guide/css/vw-vh/) считается относительно меньшей стороны вьюпорта. Если ширина вьюпорта больше высоты, то `vmin` будет считаться относительно высоты. И наоборот. `1vmin` составляет 1% от меньшей стороны вьюпорта.
- [`vmax`](https://doka.guide/css/vw-vh/) считается относительно большей стороны вьюпорта. `1vmax` составляет 1% от большей стороны.
- `ex` задаёт величину относительно метрики шрифта `x-height`. Так называется расстояние между базовой линией шрифта и средней линией строчных букв. Обычно это высота буквы `x` в шрифте, отсюда и название `x-height`. Эту экзотическую величину можно использовать, например, при стилизации верхних или нижних индексов. В примере ниже свойство `bottom` со значением `1ex` поднимет верхний индекс на высоту строчных букв, а со значением `-1ex` опустит нижний индекс вниз

- `cap` считается относительно высоты заглавных букв шрифта.
- `ch` задаёт величину относительно ширины символа `0` (ноль) в шрифте. В моноширинных (с фиксированной шириной символа) шрифтах (Courier, Menlo, Monaco и других) указание размера `10ch` будет в точности соответствовать ширине 10 символов. В других шрифтах будет наблюдаться расхождение, ведь, например, ширина цифры 1 меньше, а ширина буквы Ш — больше ширины символа `0`.
- `ic` — это эквивалент `ch` в восточных языках (китайском, корейском, японском). Задаёт размер относительно размера иероглифа 水 (вода).
- `lh` задаёт размер относительно межстрочного интервала. Если прописано свойство `line-height: 16px`, то `2lh` эквивалентно `32px`.
- `rlh` то же, что и `lh`, но относительно `line-height` элемента `<html>`.

###### Абсолютные величины

 Скопировать ссылку "Абсолютные величины"

Абсолютные величины ни от чего не зависят и привязаны к физическим единицам измерения: дюймам или сантиметрам. Этот факт имеет исторические предпосылки. Когда появились первые программы предпечатной подготовки, возникла необходимость понимать, как картинка на экране будет соответствовать напечатанному варианту. Экраны мониторов в то время были примерно одинаковые, и оказалось, что одному дюйму на экране соответствуют 72 экранных точки. Именно это соотношение зафиксировано в единице измерения `pt`. С развитием технологий улучшались экраны и их разрешение, в один дюйм стало умещаться 96 точек, и это было зафиксировано в `px`.

- `px` соответствуют пикселям на экране. `1px` интерпретируется как 1/96 дюйма.
- `cm` — сантиметры. `1cm` = `96px / 2.54`.
- `in` — дюймы. `1in` = `96px` = `2.54cm`.
- `mm` — миллиметры. `1mm` = `1/10cm`.
- `Q` — четверть миллиметра. `1Q` = `1/40cm`.
- `pc` — пики. `1pc` = `1/16in`.
- `pt` — пункты. `1pt` = `1/72in`.

Абсолютные величины, отличные от пикселей, удобно использовать для вывода на печать.

На сегодняшний день существуют экраны с разной плотностью пикселей и разным разрешением, поэтому соотношение единиц измерения к точкам экрана утратило прежний смысл. Сантиметры и дюймы при выводе на экран не будут соответствовать своим реальным размерам.

###### Единицы измерения углов

 Скопировать ссылку "Единицы измерения углов"

Используются, как правило, для задания угла поворота элемента, направления линейного градиента или угла поворота конического градиента.

- `deg` — градусы угла. Полная окружность содержит 360 градусов. В тригонометрии 0° соответствует пересечению окружности с осью _x_, и градусы отсчитываются против часовой стрелки. В CSS `0deg` соответствует пересечению окружности с осью _y_, а градусы отсчитываются по часовой стрелке:

![Отсчёт градусов в тригонометрии и CSS](https://doka.guide/css/numeric-types/images/angles-300w.png)

- `grad` — градианы. 1/100 от прямого угла (0.9°). Полная окружность содержит 400 градиан. Эта единица измерения чуть удобнее градусов в плане практических расчётов.
- `rad` — радианы. Полная окружность содержит 2π (~6.2832) радиан.
- `turn` — оборот. Полная окружность соответствует одному обороту (`1turn`). Поворот элемента на 90 градусов соответствует `0.25turn`.

###### Единицы измерения времени

 Скопировать ссылку "Единицы измерения времени"

Используются для задания длительности анимации или перехода в свойствах [`animation`](https://doka.guide/css/animation/) и [`transition`](https://doka.guide/css/transition/).

- `ms` — миллисекунда.
- `s` — секунда. `1s` = `1000ms`.

###### Единицы, связанные с разрешением экрана

 Скопировать ссылку "Единицы, связанные с разрешением экрана"

Используются для указания плотности пикселей (разрешения экрана) в медиавыражениях.

- `dpi` — указывает плотность пикселей в точках на дюйм (_dots per inch_). Обычные экраны имеют плотность пикселей 72 или 96dpi, но при печати это разрешение гораздо выше (300 и более точек на дюйм). `1dpi` = `0.39dpcm`. В примере ниже изменим размер шрифта при печати на устройствах с плотностью пикселей больше 300:

`@media print and (min-resolution: 300dpi) {   .element {     font-size: 8pt;   } }`
Скопировать

- `dpcm` — плотность пикселей в точках на сантиметр. `1dpcm` = `2.54dpi`.
- `dppx`, `x` — описывает плотность в точках на `px`. Поскольку соотношение `in` и `px` равно 1/96, `1dppx` = `96dpi`.

###### Проценты

 Скопировать ссылку "Проценты"

Используются, чтобы указать, что значение представляет собой долю от другой величины. Исходное значение, от которого берётся часть, может относиться как к самому элементу, так и к его предку. Всё зависит от того, для какого свойства мы применяем проценты.

Например, при указании `width: 50%` ширина элемента будет высчитана как 50% (половина) от ширины родителя. Но если мы укажем в процентах положение фона `background-position-x: 30%`, это значение будет высчитано относительно ширины самого элемента.

###### Почему лучше использовать `em` и `rem` вместо `px` с точки зрения доступности интерфейса?

Что такое `em`

 Скопировать ссылку "Что такое em"

Единицы `em` в CSS — это относительная единица измерения, которую используют для определения размера элементов, в основном для размера шрифта. Поскольку так задаются размеры относительно родительского элемента, `1em` равен размеру шрифта, установленному в родительском элементе.

Это означает, что если установите размер шрифта в родительском `<div>` как `20px` и размер шрифта дочернего `<div>` как `2em`, размер шрифта в дочернем `<div>` будет равен `40px`.

Что такое `rem`

 Скопировать ссылку "Что такое rem"

`rem` — это ещё одна относительная единица для величины шрифта в CSS. Так как `em` равен размеру пункта текущего шрифта, то `rem` относится к размеру шрифта корневого элемента. Обычно это тег [`<html>`](https://doka.guide/html/html/).

Польза для доступности

 Скопировать ссылку "Польза для доступности"

Единицы `em` и `rem` — масштабируемый и гибкий способ изменения размеров шрифта на странице, в отличие от `px`. Если измените размер шрифта корневого элемента, все элементы, размер которых измеряется с помощью `em` или `rem`, будут автоматически обновлены, чтобы сохранить их относительные значения.

Для того, чтобы шрифты на странице были доступными, рекомендуют использовать относительные единицы вместо абсолютных. Это особенно важно для пользователей, которые изменяют размер шрифта, разрядку букв и размеры других элементов для более удобного чтения и взаимодействия. Так изменение настроек шрифта в браузере пользователя не приведёт к проблемам со стилями, читаемостью или непредсказуемым результатам.

###### Расскажите как соотносятся с размером шрифта `px`, `em` и `rem`?

Пиксель `px` – это абсолютная единица измерения. `1px` интерпретируется как 1/96 дюйма. Главное достоинство использования пикселей для определения размера – чёткость и понятность. Однако, пиксель является фиксированной величиной и не позволяет устанавливать соотношение между различными размерами.

В отличие от `px`, единицы `em` и `rem` – относительные величины.

При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.  
`1em` равен размеру шрифта, установленному в родительском элементе.

Размер шрифта в `rem` рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/).


##### Контекст наложения
https://doka.guide/css/stacking-context/

Контекст наложения — набор правил, на основании которых браузер решает, какой элемент на странице будет выше или ниже других. Условно, если представлять элементы как колоду карт, то правила формирования контекста наложения тасуют колоду. Это одна из основных концепций CSS.

![Слои находятся на разном удалении от взгляда пользователя и могут перекрывать друг друга](https://doka.guide/css/stacking-context/images/stacking-context-300w.png)

Браузер при отрисовке страницы идёт сверху вниз по HTML-разметке и рисует блоки один за другим в том же порядке, в котором они расположены. Мы видим и воспринимаем это как плоский лист, на котором один за другим выстраиваются элементы. Но браузер хитрый и на самом деле он располагает элементы не только по осям _x_ и _y_, но ещё и по оси _z_. По глубине, так сказать.

Вы можете резонно заметить «Монитор же плоский! Какая ещё глубина?». Ваша правда. Но браузеру важно учитывать глубину элементов, чтобы при необходимости правильно наложить их друг на друга.

В стандартной ситуации тот элемент, который находится ниже в HTML-разметке будет ближе к пользователю. Давайте посмотрим на примере. Пусть в нашей разметке будет два блока:

`<div class="block first"></div> <div class="block second"></div>`

И для наглядности мы сдвинем второй блок чуть вверх и вправо:

`.second {   margin-top: -50px;   margin-left: 50px; }`

![[Pasted image 20250504133705.png]]
В результате явно видно, что второй блок перекрывает собою первый, а значит находится выше в _стопке_ элементов по оси _z_.

###### `z-index`

Но мы можем не подчиняться стандартным правилам браузера и устанавливать свой порядок наложения элементов друг на друга. Для этого понадобится свойство [`z-index`](https://doka.guide/css/z-index/).

Перемешаем элементы в нашем примере. Для наглядности добавим третий блок:

```css
<div class="block first"></div> 
<div class="block second"></div> 
<div class="block third"></div>
```
Скопировать

И пусть последний блок и первый блоки перекрывают второй блок. Для этого достаточно добавить позиционирование и `z-index` для первого, а последний и так выше, просто по порядку следования:

```css
.first {   
	position: relative;   z-index: 1; 
}
```
![[Pasted image 20250504133857.png]]

###### Контекст наложения

 Скопировать ссылку "Контекст наложения"

На самом деле уже в предыдущих примерах мы с вами поработали с контекстом наложения. Просто не знали об этом 😅

**Контекст наложения** — это концепция трёхмерного расположения элементов по оси _z_ относительно пользователя, смотрящего на экран.

Самый базовый контекст наложения, существующий на любой странице формируется корневым элементом [`<html>`](https://doka.guide/html/html/). Все элементы внутри этого контекста сортируются и располагаются с оглядкой друг на друга.

Но мы можем создавать контексты наложения не только на странице целиком, но и в каждом отдельном блоке. Тогда вложенные в него дочерние блоки будут сортироваться и располагаться уже по правилам этого нового, родительского контекста наложения.

Новый контекст наложения формируется если:

1. это корневой элемент ([`<html>`](https://doka.guide/html/html/)),
2. элемент позиционирован абсолютно ([`position: absolute`](https://doka.guide/css/position/)) или относительно (`position: relative`) со свойством [`z-index`](https://doka.guide/css/z-index/), значение которого не `auto`,
3. флекс-элемент со свойством `z-index`, значение которого не `auto` и чей родительский элемент имеет свойство [`display: flex`](https://doka.guide/css/flexbox-guide/) или `display: inline-flex`,
4. элементу задано свойство [`opacity`](https://doka.guide/css/opacity/) со значением меньше `1`,
5. элементу задано свойство [`transform`](https://doka.guide/css/transform/) со значением не `none`,
6. элементу задано свойство `mix-blend-mode` со значением не `normal`,
7. элементу задано свойство [`filter`](https://doka.guide/css/filter/) со значением не `none`,
8. элементу задано свойство `isolation` со значением `isolate`,
9. элемент с `position: fixed`,
10. элементу задано свойство [`will-change`](https://doka.guide/css/will-change/) или аналогичный атрибут,
11. элементу задано свойство `-webkit-overflow-scrolling` со значением `touch`.

Остальные элементы, не создающие собственный контекст наложения, используют родительский контекст.

Обычно достаточно запомнить первые три сценария и чуть-чуть помнить про следующие два. Если браузер рисует что-то, чего вы не ожидали, можно всегда вернуться и подсмотреть остальные.
###### Порядок наложения

 Скопировать ссылку "Порядок наложения"

Внутри каждого контекста наложения существует свой порядок отрисовки элементов и их компонентов. Ниже перечисление идёт от самого нижнего слоя, до самого верхнего:

1. Фон ([`background`](https://doka.guide/css/background/)) и рамки элемента ([`border`](https://doka.guide/css/border/));
2. Позиционированные элементы (включая потомков), у которых значение свойства `z-index` меньше 0;
3. Элементы без контекста наложения с `display: block`;
4. Элементы со свойством [`float`](https://doka.guide/css/float/);
5. Элементы с `display: inline`;
6. Элементы (включая потомков) с `z-index: auto` или `z-index: 0`, а также элементы с `opacity` меньше 1;
7. Элементы (включая потомков) с `z-index` больше 0.

Согласно этому порядку, элемент с отрицательным значением `z-index` никогда не будет ниже фона или рамки родительского элемента.






##### Как вынести элемент в отдельный слой

https://habr.com/ru/companies/skillfactory/articles/654715/

В CSS можно вынести элемент в отдельный слой с помощью свойства **`isolation`** или **`will-change`**, а также принудительно создать новый слой с помощью **`transform`**, **`opacity`** или других свойств, которые создают **"stacking context"** (контекст наложения).  

###### **1. Создание нового слоя с помощью `isolation`**  
Свойство `isolation: isolate` создает новый контекст наложения, что полезно для управления z-index:  
```css
.element {
  isolation: isolate; /* Создает новый stacking context */
  z-index: 10; /* Теперь z-index работает внутри этого контекста */
}
```

###### **2. Принудительное создание слоя с `will-change`**  
Оптимизация рендеринга с помощью `will-change` (может ускорить анимации):  
```css
.element {
  will-change: transform, opacity; /* Браузер заранее выделит слой */
}
```
⚠️ **Важно:** Не злоупотребляйте `will-change`, так как это может увеличить потребление памяти.  

###### **3. Создание слоя через `transform` или `opacity`**  
Некоторые свойства автоматически создают новый слой:  
```css
.element {
  transform: translateZ(0); /* Аппаратное ускорение (может создать слой) */
  /* или */
  opacity: 0.999; /* Не 1, чтобы браузер оптимизировал */
}
```

###### **4. Использование `contain` для оптимизации**  
Свойство `contain` ограничивает область перерисовки и может помочь в производительности:  
```css
.element {
  contain: paint; /* Браузер не будет перерисовывать элементы вне этого блока */
}
```

###### **Когда это полезно?**  
- При анимациях (`transform`, `opacity`) для плавности.  
- При работе с `z-index`, чтобы избежать конфликтов.  
- Для оптимизации рендеринга сложных компонентов.  

Если вам нужно управлять слоями глобально (например, в `@layer`), используйте **CSS Cascade Layers**:  
```css
@layer utilities {
  .element {
    /* Стили в отдельном слое */
  }
}
```

Выбор метода зависит от задачи:  
- **Для анимаций** → `will-change`, `transform`.  
- Для **управления z-index** → `isolation`.  
- Для **оптимизации рендеринга** → `contain`.  

###### **Зачем выносить элементы в отдельные слои?**
###### **1. Ускорение анимаций и переходов**
Когда браузер рендерит страницу, он проходит несколько этапов:
1. **Layout** (расчёт геометрии)  
2. **Paint** (отрисовка пикселей)  
3. **Composite** (композиция слоёв)  

Если элемент находится в **отдельном слое**, браузер может пропускать этапы **Layout** и **Paint** при анимациях `transform` и `opacity`, что делает анимации плавными (60 FPS).  

**Пример:**  
```css
.box {
  will-change: transform; /* Браузер заранее выделит слой */
  /* или */
  transform: translateZ(0); /* "Хак" для создания слоя */
}
```
→ Анимация `transform: scale()` или `opacity` будет работать на GPU.

###### **2. Избежание "дёрганий" при прокрутке**
Элементы с `position: fixed`, `sticky` или сложные анимации могут тормозить, если браузер постоянно пересчитывает их положение. Вынос в отдельный слой уменьшает нагрузку на CPU.

###### **3. Контроль над `z-index` (изоляция контекста наложения)**
Если у вас сложная вёрстка с множеством `z-index`, `isolation: isolate` помогает избежать неожиданного перекрытия элементов.

---

###### **Как браузер использует GPU?**
Когда элемент становится **композитным слоем**, браузер может отдать его рендеринг **графическому процессору (GPU)**. Это особенно полезно для:
- Плавных анимаций (`transform`, `opacity`).  
- Параллакс-эффектов.  
- Сложных `position: sticky` / `fixed`-элементов.  

**Но!** GPU рендеринг ≠ волшебная оптимизация.  
→ Каждый слой потребляет видеопамять (особенно на мобильных устройствах).  
→ Слишком много слоёв могут **замедлить** страницу.

---

###### **Когда это действительно нужно?**
✅ **Анимации** (`transform`, `opacity`, `filter`).  
✅ **Фиксированные элементы** (например, шапка сайта).  
✅ **Сложные интерфейсы** (кастомные скроллы, canvas, WebGL).  

❌ **Не нужно** применять ко всем элементам подряд – это может **увеличить потребление памяти** и даже замедлить страницу.

---

###### **Как проверить, что элемент в отдельном слое?**
1. **Chrome DevTools** → **Layers** (вкладка в "Инструментах разработчика").  
2. **Edge/Chrome** → `F12` → **Rendering** → **Layer borders** (покажет слои цветными рамками).  

Если элемент стал отдельным слоем, вы увидите его в списке.

---

###### **Вывод**
Вынос в отдельный слой **ускоряет анимации и сложные эффекты**, но требует баланса.  
**Лучшие практики:**  
- Используйте `will-change` или `transform: translateZ(0)` **только для анимируемых элементов**.  
- Не злоупотребляйте – слишком много слоёв = больше нагрузки на GPU.  
- Проверяйте в DevTools, действительно ли элемент стал слоем.  

Если нужно ускорить анимацию – это отличный способ. Если нет – лучше не создавать лишние слои. 🚀

##### Image / picture

https://doka.guide/html/picture/
https://habr.com/ru/companies/vdsina/articles/555736/

В CSS и HTML есть два элемента для работы с изображениями — `<img>` и `<picture>`. Они похожи, но служат разным целям. Разберём их ключевые отличия, плюсы и минусы, а также когда какой использовать.

---

###### **1. `<img>` — обычное изображение**
###### **Как работает?**
```html
<img src="image.jpg" alt="Описание" width="800" height="600">
```
- Загружает **одну версию** изображения.
- Подходит для статичных картинок без адаптации под разные устройства.

###### **Плюсы:**
- Простота использования.
- Поддержка во всех браузерах.
- Можно стилизовать через CSS (`border`, `filter`, `object-fit` и др.).

###### **Минусы:**
- Нет адаптивности под разные разрешения экрана.
- Если изображение слишком большое для мобильных — тратится лишний трафик.
- Если слишком маленькое для десктопа — выглядит размытым.

---

###### **2. `<picture>` — адаптивное изображение**
###### **Как работает?**
```html
<picture>
  <source media="(min-width: 1200px)" srcset="large.jpg">
  <source media="(min-width: 768px)" srcset="medium.jpg">
  <source srcset="small.jpg">
  <img src="fallback.jpg" alt="Описание"> <!-- Фолбэк -->
</picture>
```
- Позволяет загружать **разные изображения** в зависимости от:
  - **Размера экрана** (`media`).
  - **Плотности пикселей** (`srcset`).
  - **Формата изображения** (WebP, AVIF, JPEG и др.).

###### **Плюсы:**
- **Оптимизация загрузки** (меньший вес на мобильных).
- Поддержка **современных форматов** (WebP, AVIF) с фолбэком.
- Можно делать **арт-дирекшн** (разные картинки для разных экранов).

###### **Минусы:**
- Сложнее в вёрстке.
- Не всегда нужен (если изображение простое).

---

###### **3. Ключевые отличия**
| Характеристика       | `<img>`                          | `<picture>`                      |
|----------------------|----------------------------------|----------------------------------|
| **Адаптивность**     | Нет (одно изображение)           | Да (разные версии под экраны)    |
| **Оптимизация**      | Нет (может грузить лишнее)       | Да (загружает оптимальный вариант) |
| **Форматы**         | Только указанный в `src`         | Поддержка WebP/AVIF с фолбэком   |
| **Арт-дирекшн**      | Нет                              | Да (можно менять картинку)       |
| **Сложность**        | Просто                          | Сложнее (нужно прописывать `source`) |

---

###### **4. Когда что использовать?**
###### **Используйте `<img>`, если:**
- Изображение **простое** (иконка, логотип, фон).
- Нет требований к адаптивности.
- Нужна максимальная простота.

###### **Используйте `<picture>`, если:**
- Нужна **адаптивность** (разные размеры для мобильных и десктопов).
- Хотите **сэкономить трафик** (загрузка WebP вместо JPEG).
- Нужен **арт-дирекшн** (например, обрезанная версия для мобильных).

---

###### **5. Пример: Оптимизация с `<picture>`**
```html
<picture>
  <!-- AVIF (если поддерживается) -->
  <source type="image/avif" srcset="image.avif">
  
  <!-- WebP (если AVIF не поддерживается) -->
  <source type="image/webp" srcset="image.webp">
  
  <!-- Фолбэк для старых браузеров -->
  <img src="image.jpg" alt="Пример" loading="lazy">
</picture>
```
→ Браузер выберет самый оптимальный формат.

---

###### **6. CSS для `<img>` и `<picture>`**
Оба элемента можно стилизовать:
```css
img, picture {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
}

/* object-fit для управления обрезкой */
img {
  object-fit: cover;
}
```

---

###### **Вывод**
- `<img>` — **простое решение** для статичных изображений.  
- `<picture>` — **гибкий инструмент** для адаптивности и оптимизации.  

Выбирайте `<picture>`, если важно:  
✅ Адаптивное изображение.  
✅ Оптимизация загрузки.  
✅ Поддержка современных форматов.  

Для всего остального достаточно `<img>`. 🖼️


##### CSS-препроцессоры
https://doka.guide/tools/preprocessors/

Препроцессор — это инструмент, который расширяет стандартные возможности CSS с помощью новых синтаксических конструкций, таких как миксины, циклы, переменные и другие. Препроцессоры так называются потому, что принимают данные (ваш код в формате _stylus_, _sass_, _scss_ или _less_) и потом компилируют (преобразуют) их в обычный CSS-код. Этим они отличаются от постпроцессоров, которые улучшают именно CSS. К примеру, подставляют вендорные префиксы.

Основные препроцессоры — это [Sass](https://sass-lang.com/), [Less](https://lesscss.org/) и [Stylus](https://stylus-lang.com/). У них различные синтаксисы, а Sass поддерживает два: sass и SCSS.

CSS пока ещё нет поддержки миксинов, с помощью которых можно добавлять адаптивность сайту, вынося отдельные стили и «примешивая» их потом.

###### `@extend`

Во всех препроцессорах есть интересная фича — `@extend`. С её помощью расширяют классы за счёт других. С одной стороны, это удобно и сокращает количество написанного кода, с другой, если неправильно использовать фичу, это приведёт к хаосу в организации кода. Станет трудно разобраться, какие CSS-стили получатся в итоге. Дело в том, что из-за `@extend` возникает неявная связанность между оригинальными классами и теми классами, которые их расширяют. Изменяя стили из первоначального класса, мы автоматически вносим изменения и во все другие, которые содержат расширения. Так что, при большом количестве расширений, стили могут измениться сразу в нескольких местах. Важно следить за тем, есть ли у родительских стилей зависимость от дочерних. Таким образом, при использовании `@extend` стоит сначала подумать, будет ли это хорошим решением для конкретного проекта, и действительно ли оно упрощает вашу работу.

###### Миксины

Миксины (mixins) похожи на функции в языках программирования. В них передают аргументы, задают им значения по умолчанию и так далее. Миксины помогают группировать нужные стили и повторно использовать их в нескольких местах кода или в разных CSS-файлах. Это пригодится, когда в проекте ну очень много стилей и строк кода, сложная логика вычисления значений для CSS-свойств, а ещё когда хотите подстраховаться и не споткнуться об разные особенности отрисовки стилей в браузерах.



##### Миксины

https://sass-lang.su/documentation/at-rules/mixin

https://ru.hexlet.io/courses/css-sass/lessons/mixin/theory_unit

https://sass-scss.ru/documentation/miksini/ispolzovanie_miksina/

###### Миксины в CSS-препроцессорах: Полное руководство

Миксины (mixins) — это одна из самых мощных возможностей CSS-препроцессоров, позволяющая создавать переиспользуемые блоки стилей с возможностью параметризации.

###### Что такое миксины?

Миксины можно сравнить с функциями в программировании — это фрагменты кода, которые:
1. Можно многократно использовать
2. Можно параметризировать
3. Можно включать в различные селекторы

###### Синтаксис миксинов в разных препроцессорах

###### В Sass/SCSS
```scss
// Объявление миксина
@mixin border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
}

// Использование
.button {
  @include border-radius(10px);
}
```

###### В Less
```less
// Объявление
.border-radius(@radius) {
  border-radius: @radius;
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
}

// Использование
.button {
  .border-radius(10px);
}
```

###### В Stylus
```stylus
// Объявление
border-radius(radius)
  border-radius radius
  -webkit-border-radius radius
  -moz-border-radius radius

// Использование
.button
  border-radius(10px)
```

###### Возможности миксинов

###### 1. Параметры по умолчанию
```scss
@mixin box-shadow($x: 0, $y: 0, $blur: 5px, $color: #000) {
  box-shadow: $x $y $blur $color;
}

.card {
  @include box-shadow($y: 10px);
}
```

###### 2. Несколько параметров
```scss
@mixin position($position, $top: null, $right: null, $bottom: null, $left: null) {
  position: $position;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

.modal {
  @include position(absolute, 10px, 10px);
}
```

###### 3. Переменное количество аргументов
```scss
@mixin transition($properties...) {
  transition: $properties;
}

.element {
  @include transition(color 0.3s ease, background 0.5s linear);
}
```

###### 4. Содержимое блока (@content)
```scss
@mixin media($width) {
  @media (min-width: $width) {
    @content;
  }
}

@include media(768px) {
  .container {
    width: 750px;
  }
}
```

###### Практические примеры использования

###### 1. Кроссбраузерные стили
```scss
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.header {
  @include flex-center;
}
```

###### 2. Адаптивные медиа-запросы
```scss
@mixin respond-to($breakpoint) {
  @if $breakpoint == phone {
    @media (max-width: 599px) { @content; }
  } @else if $breakpoint == tablet {
    @media (min-width: 600px) { @content; }
  } @else if $breakpoint == desktop {
    @media (min-width: 1200px) { @content; }
  }
}

.section {
  padding: 10px;
  
  @include respond-to(tablet) {
    padding: 20px;
  }
}
```

###### 3. Сложные анимации
```scss
@mixin pulse-animation($name, $color) {
  @keyframes #{$name} {
    0% { box-shadow: 0 0 0 0 rgba($color, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba($color, 0); }
    100% { box-shadow: 0 0 0 0 rgba($color, 0); }
  }
}

@include pulse-animation(pulse-red, #ff0000);
```

###### Разница между миксинами и другими возможностями

###### Миксины vs @extend
- **Миксины** копируют код в каждое место использования
- **@extend** объединяет селекторы (может приводить к неожиданным результатам)

###### Миксины vs Функции
- **Миксины** генерируют CSS-код
- **Функции** возвращают значения для использования в свойствах

###### Лучшие практики

1. Называйте миксины по их функции, а не по реализации
2. Документируйте параметры миксинов
3. Разделяйте сложные миксины на более простые
4. Избегайте избыточного использования (не создавайте миксины для одноразовых стилей)

Миксины — это мощный инструмент, который при правильном использовании значительно упрощает поддержку CSS и уменьшает количество повторяющегося кода.

##### Placeholder (Silent) селекторы

https://sass-lang.su/documentation/style-rules/placeholder-selectors

В Sass есть особый тип селектора, известный как “placeholder”. Он выглядит и действует как селектор класса, но начинается с `%` и не включается в вывод CSS. Фактически, любой сложный селектор (те, что между запятыми), который даже _содержит_ селектор-заполнитель, не включен в CSS, равно как и любое правило стиля, все селекторы которого содержат заполнители.
Селекторы-заполнители полезны при написании библиотеки Sass, где каждое правило стиля может использоваться или не использоваться. Как правило, если вы пишете таблицу стилей только для своего собственного приложения, часто лучше просто расширить селектор классов, если он доступен.

```scss
%toolbelt {
  box-sizing: border-box;
  border-top: 1px rgba(#000, .12) solid;
  padding: 16px 0;
  width: 100%;

  &:hover { border: 2px rgba(#000, .5) solid; }
}

.action-buttons {
  @extend %toolbelt;
  color: #4285f4;
}

.reset-buttons {
  @extend %toolbelt;
  color: #cddc39;
}
```

```css
.action-buttons, .reset-buttons {
  box-sizing: border-box;
  border-top: 1px rgba(0, 0, 0, 0.12) solid;
  padding: 16px 0;
  width: 100%;
}
.action-buttons:hover, .reset-buttons:hover {
  border: 2px rgba(0, 0, 0, 0.5) solid;
}

.action-buttons {
  color: #4285f4;
}

.reset-buttons {
  color: #cddc39;
}
```


Placeholder селекторы (также известные как "silent" или "абстрактные" селекторы) — это специальный тип селекторов в Sass, которые существуют только во время компиляции и не попадают в итоговый CSS-файл.

###### Синтаксис placeholder-селекторов

Placeholder селекторы начинаются с символа `%`:

```scss
%center-element {
  display: flex;
  justify-content: center;
  align-items: center;
}

// Используется через @extend
.modal {
  @extend %center-element;
  background: white;
}

.tooltip {
  @extend %center-element;
  position: absolute;
}
```

После компиляции получим:

```css
.modal, .tooltip {
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal {
  background: white;
}

.tooltip {
  position: absolute;
}
```

###### Отличия от миксинов и обычных селекторов

| Характеристика       | Placeholder (`%`) | Миксины (`@mixin`) | Обычные селекторы |
|----------------------|-------------------|--------------------|-------------------|
| Попадает в CSS       | Нет               | Нет                | Да                |
| Использование        | `@extend`         | `@include`         | Напрямую          |
| Генерируемый код     | Группировка селекторов | Копирование кода | Как есть          |
| Оптимизация          | Лучшая            | Худшая             | Средняя           |

###### Преимущества placeholder-селекторов

1. **Оптимизация CSS-кода** - Sass группирует все селекторы, которые наследуют placeholder
2. **Чистота итогового CSS** - не содержит "вспомогательных" классов
3. **Повторное использование** без дублирования кода
4. **Семантичность** - логическое разделение абстрактных стилей и конкретных компонентов

###### Практические примеры использования

###### 1. Абстрактные стилевые паттерны

```scss
%clearfix {
  &::after {
    content: '';
    display: table;
    clear: both;
  }
}

.container {
  @extend %clearfix;
}
```

###### 2. Сброс стилей

```scss
%reset-list {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nav {
  @extend %reset-list;
  
  li {
    display: inline-block;
  }
}
```

###### 3. Анимации

```scss
%fade-in {
  animation: fadeIn 0.3s ease-out forwards;
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
}

.modal {
  @extend %fade-in;
}
```

###### Ограничения и рекомендации

1. **Нельзя использовать параметры** (в отличие от миксинов)
2. **Лучше подходят для статических стилей**, которые не нужно кастомизировать
3. **Избегайте слишком глубокого наследования** - может привести к неожиданному росту CSS
4. **Не злоупотребляйте** - используйте там, где действительно нужна группировка селекторов

###### Сочетание с другими возможностями Sass

Placeholder-селекторы можно комбинировать с:

```scss
// С миксинами
@mixin responsive-layout {
  %base-layout {
    display: grid;
    gap: 1rem;
  }
  
  @extend %base-layout;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

// В медиа-запросах
@media (min-width: 768px) {
  %desktop-only {
    display: block;
  }
  
  .menu {
    @extend %desktop-only;
  }
}
```

###### Итог

Placeholder-селекторы — это мощный инструмент для:
- Создания абстрактных стилевых паттернов
- Оптимизации итогового CSS-кода
- Уменьшения дублирования в исходном коде
- Поддержания чистоты и структурированности стилей

Используйте их вместо миксинов, когда вам нужно повторное использование без параметризации, и когда важна оптимальная группировка селекторов в скомпилированном CSS.


##### Разница между `@import` и `@use` в Sass

https://sass-lang.su/documentation/at-rules/use

###### `@import`

`@import` - это устаревший способ подключения файлов в Sass, который имеет несколько проблем:

```scss
// styles.scss
@import 'variables';
@import 'buttons';
```

###### Проблемы `@import`:
1. **Глобальная область видимости** - все переменные, миксины и функции доступны везде
2. **Конфликты имен** - можно случайно переопределить переменные
3. **Дублирование кода** - если один файл импортируется несколько раз
4. **Низкая производительность** - Sass должен обрабатывать каждый импорт

###### `@use` (современный способ)

`@use` был введен в Sass 1.23.0 как замена `@import`:

```scss
// styles.scss
@use 'variables';
@use 'buttons';
```

###### Преимущества `@use`:
1. **Локальная область видимости** - переменные доступны только через namespace
2. **Защита от конфликтов** - имена не пересекаются
3. **Контроль зависимостей** - явное указание что откуда используется
4. **Ленивая загрузка** - файлы загружаются только когда нужны

###### Использование переменных через `@use`:
```scss
@use 'variables' as vars;

.element {
  color: vars.$primary-color;
}
```

###### Возможности `@use`:
1. **Псевдонимы**:
```scss
@use 'very/long/path/to/variables' as v;
color: v.$primary;
```

2. **Глобальный доступ** (не рекомендуется):
```scss
@use 'variables' as *;
color: $primary;
```

3. **Конфигурация модулей**:
```scss
@use 'theme' with (
  $primary: blue,
  $secondary: green
);
```

###### Миграция с `@import` на `@use`

1. Заменяем `@import` на `@use`
2. Добавляем namespace для доступа к переменным
3. Используем `as *` только если необходимо
4. Для совместимости можно использовать `@forward`

###### Пример полной миграции

**Было (с @import):**
```scss
// _variables.scss
$primary: #3498db;

// styles.scss
@import 'variables';

.button {
  background: $primary;
}
```

**Стало (с @use):**
```scss
// _variables.scss
$primary: #3498db !default;

// styles.scss
@use 'variables' as vars;

.button {
  background: vars.$primary;
}
```

###### Вывод

- **Используйте `@use`** для новых проектов
- **Избегайте `@import`** - он устарел и будет удален в будущем
- **`@forward`** используйте для создания библиотек
- **Пространства имен** помогают организовать код

`@use` делает код более предсказуемым, безопасным и поддерживаемым.
## Browser

  

##### Критические этапы рендеринга

https://doka.guide/tools/how-the-browser-creates-pages/

https://developer.mozilla.org/ru/docs/Web/Performance/Guides/Critical_rendering_path

Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

1. Сперва ему нужно скачать исходники.
2. Затем их нужно прочитать и _распарсить_.
3. После этого браузер приступает к _рендерингу_ — отрисовке.

###### Получение ресурсов, Fetching

Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например, данные в виде [JSON](https://doka.guide/tools/json/), так и картинки, видео, файлы стилей и скриптов.

Самый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего `index.html`).
###### Парсинг, Parsing

По мере того как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.
###### DOM

Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется [DOM](https://doka.guide/js/dom/).

_DOM (Document Object Model)_ — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.

Для такого документа:

```html
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello</title>
  </head>
  <body>
    <p class="text">Hello world</p>
    <img src="/hello.jpg" alt="Привет!">
  </body>
</html>

```

...получится такое дерево:

![DOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/DOM-300w.png)

Пока браузер парсит документ и строит DOM, он натыкается на элементы типа [`<img>`](https://doka.guide/html/img/), [`<link>`](https://doka.guide/html/link/), [`<script>`](https://doka.guide/html/script/), которые содержат ссылки на другие ресурсы.

Если ресурс _неблокирующий_ (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. _Блокирующие_ ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.

###### CSSOM

Когда браузер находит элемент `<link>`, который указывает на файл стилей, браузер скачивает и парсит его. Результат парсинга CSS-кода — CSSOM.

_CSSOM (CSS Object Model)_ — по аналогии с DOM, представление стилевых правил в виде дерева.

Для документа выше с такими стилями:

```css

body {
  font-size: 1.5rem;
}

.text {
  color: red;
}

img {
  max-width: 100%;
}

```

...получим такое дерево:

![CSSOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/CSSOM-300w.png)

Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время ожидания, пока «страница загрузится».

Благодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.

###### Render Tree

После того как браузер составил DOM и CSSOM, он объединяет их в общее _дерево рендеринга_ — Render Tree.

Render Tree — это термин, который используется движком WebKit, в других движках он может отличаться. Например, Gecko использует термин Frame Tree.

В итоге для нашего документа выше мы получим такое дерево:

![Render tree](https://doka.guide/tools/how-the-browser-creates-pages/images/render-tree-300w.png)

Обратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через [`display: none`](https://doka.guide/css/display/), он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.

Общая схема парсинга выглядит вот так:

![Общая схема парсинга HTML и CSS](https://doka.guide/tools/how-the-browser-creates-pages/images/1-300w.png)

На первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.

###### Вычисление позиции и размеров, Layout

После того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется _Layout_.

Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого _рекурсивно_.

Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

###### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.

###### «Грязные» элементы

Это те элементы, которые были изменены, и их дочерние элементы.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![Дерево «грязных» и перерисованных элементов](https://doka.guide/tools/how-the-browser-creates-pages/images/2-300w.png)

Дальше браузер приступает к, собственно, отрисовке.

###### Непосредственно отрисовка, Paint

Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

###### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.

В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:

- `background-color`;
- `background-image`;
- `border`;
- `children`;
- `outline`.

###### CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![Схема композитинга](https://doka.guide/tools/how-the-browser-creates-pages/images/3-300w.png)

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com/)».

###### Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame()`.

```js

const animate = () => { 
	// Код анимации 
}

```

Эта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.

Если мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).

Это можно сделать топорно, через интервал:

```js
// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)

```

Либо использовать `window.requestAnimationFrame()`:

```js

window.requestAnimationFrame(animate)

```

Интервалы не всегда запускаются в нужный момент. [`setInterval()`](https://doka.guide/js/setinterval/) не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.

С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.

А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:

![Анимация с setInterval](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-300w.png)

С `requestAnimationFrame()` анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.

Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.

![Анимация с requestAnimationFrame](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2-300w.png)

Для динамики всегда используйте [`transform`](https://doka.guide/css/transform/) и [`opacity`](https://doka.guide/css/opacity/), избегайте изменения остальных свойств (типа `left`, `top`, [`margin`](https://doka.guide/css/margin/), [`background`](https://doka.guide/css/background/) и так далее).

Таким образом вы дадите браузеру возможность оптимизировать отрисовку, отчего страница станет отзывчивее.

Для анимаций, которые необходимо перерисовывать на каждый фрейм, используйте `requestAnimationFrame()`.

Это сделает тяжёлую анимацию менее рваной.

##### Что такое прогрессивный рендеринг (progressive rendering)?

Чтобы понять что такое progressive rendering, нужно понимать отличие _client-side rendering_ от _server-side rendering_.

При **client-side rendering** (CSR) контент отрисовывается на стороне клиента (в браузере). Такой подход используется в React, когда браузеру отсылается практически пустой HTML-документ, а потом запускается скрипт, который генерирует HTML в указанном скрипту теге. Как правило это `<div id="root">`. Пользователь будет видеть пустую страницу, пока JS-файл полностью не загрузится.

При **server-side rendering** (SSR) HTML-разметка генерируется на сервере, отсылается браузеру и после этого отрисовывается на клиенте. Пользователь увидит контент сразу же, но не сможет взаимодействовать со страницей, пока не загрузится JS-файл.

При использовании прогрессивного рендеринга, кусочки HTML генерируется на сервере и отсылаются браузеру в порядке их приоритетности. То есть, элементы с самым высоким приоритетом (например `<header>`, фон, главная интерактивная часть страницы) генерируются на сервере, отсылаются браузеру и отрисовываются в первую очередь. Это позволяет пользователю увидеть самый важный контент как можно скорее, не дожидаясь полной загрузки всего контента. То есть, progressive rendering что-то среднее между client-side rendering и server-side rendering.

Техники реализации прогрессивного рендеринга:

1. **Ленивая загрузка** (Lazy Loading). Загрузка контента по мере необходимости. Например, если страница достаточно большая, не нужно загружать изображения вне вьюпорта. Загрузка изображения стартует за некоторое время до того как она появится во вьюпорте. Эту же технику можно использовать для загрузки контента изначально скрытых элементов. Например, можно загрузить контент закрытого меню когда пользователь наводит курсор на кнопку открытия.
2. **Приоритизация контента**. Например, не загружать изначально все CSS-стили. Добавлять в `<head>` загрузку только тех стилей, которые нужны для текущей видимой области HTML-документа. Остальные стили можно добавить в `<body>`.

##### reflow/repaint/compose

##### что вычисляется на процессоре а что на gpu в css?
В CSS практически все вычисления выполняются на **CPU**, а не на GPU. Однако есть определённые свойства и операции, которые могут **передаваться на GPU** для ускорения рендеринга.  

###### **Что обрабатывается на CPU?**  
Большинство вычислений в CSS выполняется на CPU, включая:  
- **Разметку (Layout / Reflow)** – вычисление размеров и позиций элементов (`width`, `height`, `margin`, `padding`, `position` и т. д.).  
- **Стилизацию (Style Calculation)** – применение CSS-правил (`color`, `font-size`, `background` и др.).  
- **Обработку сложных селекторов** (например, вложенные `:hover`, `:nth-child()`).  

###### **Что может обрабатываться на GPU?**  
Некоторые CSS-свойства могут **использовать GPU-ускорение** (через аппаратное ускорение), что улучшает производительность:  
1. **3D-трансформации** (`transform: translate3d()`, `rotate3d()`, `scale3d()`).  
2. **Анимации и переходы** (`transition`, `animation`) с `transform` или `opacity`.  
3. **Фильтры** (`filter: blur()`, `drop-shadow()`).  
4. **Наложения** (`will-change: transform, opacity`).  
5. **Видео и Canvas** (рендеринг `<video>` и `<canvas>` может использовать GPU).  

###### **Как задействовать GPU?**  
Чтобы браузер использовал GPU, можно применить:  
```css
.element {
    transform: translateZ(0); /* или translate3d(0, 0, 0) */
    will-change: transform;   /* подсказка браузеру */
}
```  
Это перемещает элемент в отдельный **GPU-слой (composition layer)**, что ускоряет анимации.  

###### **Вывод**  
- **CPU:** Основные вычисления (разметка, стилизация).  
- **GPU:** Отдельные оптимизированные операции (анимации, трансформации, фильтры).  

Если нужно ускорить анимации, лучше использовать `transform` и `opacity`, а не свойства, вызывающие перерасчёт разметки (например, `width` или `margin`).

##### CORS

##### cookie

##### REST

##### graph QL

##### GET/POST/PUT/DELETE?PATCH

##### Объясните разницу между `cookie`, `sessionStorage` и `localStorage`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-cookie-sessionstorage-%D0%B8-localstorage "Прямая ссылка на объясните-разницу-между-cookie-sessionstorage-и-localstorage")

  

Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

  

||`cookie`|`localStorage`|`sessionStorage`|

|---|---|---|---|

|Инициатор|Клиент или сервер. Сервер может использовать заголовок `Set-Cookie`|Клиент|Клиент|

|Срок хранения|Устанавливается вручную|Всегда|До закрытия вкладки|

|Хранение между сессиями|Зависит от установки срока хранения|Да|Нет|

|Отправка на сервер с каждым HTTP-запросом|автоматически, с помощью заголовка `Cookie`|Нет|Нет|

|Емкость (на один домен)|4 КБ|5 МБ|5 МБ|

|Доступность|В любом окне|В любом окне|В той же вкладке|

  

###### Ссылки[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-5 "Прямая ссылка на Ссылки")

  

- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)

- [http://tutorial.techaltum.com/local-and-session-storage.html](http://tutorial.techaltum.com/local-and-session-storage.html)

##### Объясните разницу между `<script>`, `<script async>` и `<script defer>`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-script-script-async-%D0%B8-script-defer "Прямая ссылка на объясните-разницу-между-script-script-async-и-script-defer")

  

- `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.

- `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.

- `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

  

Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.

## JS

  

##### переменные/ let/const/var

##### замыкания

##### рекурсия

##### объекты

##### this

##### event loop

##### методы массивов

##### Promise

##### статические методы promise

##### прототипное насследноваие

##### DOM

##### события

##### всплытие/погружение

##### делегирование событий

##### объект события

##### this/currentTarget vs target

##### логические операторы

##### Map, Set, WeakMap, WeakSet

##### каррирование

##### webworkers

##### стрелочные функции, function declaration/expression

##### Опциональная цепочка '?.'

##### call/apply/bind

  

## TS

  

##### **Какие типы данных поддерживает TypeScript?**

  

- **Ответ:** TypeScript поддерживает:

    - Примитивные типы: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.

    - Сложные типы: `array`, `tuple`, `enum`, `object`, `function`.

    - Специальные типы: `any`, `unknown`, `void`, `never`.

##### interface vs type

- `type` может использоваться для создания псевдонимов для любых типов, включая примитивы, объединения и пересечения.

- `interface` используется только для описания формы объектов и может быть расширен с помощью `extends`.

##### type guards

##### generics

##### union / intersection

- - **Union types (`|`):** Позволяют указать, что переменная может быть одного из нескольких типов.

        typescript

        let value: string | number;

    - **Intersection types (`&`):** Позволяют объединить несколько типов в один.

        typescript

        type A = { a: string };

        type B = { b: number };

        type C = A & B; // { a: string, b: number }

  

---

##### any vs unknown

`any` — это тип, который отключает проверку типов для переменной. Его следует использовать только в крайних случаях, когда тип неизвестен или сложно определить.

`unknown` — это тип, который требует явного приведения перед использованием. В отличие от `any`, он безопаснее, так как не позволяет выполнять операции без проверки типа.

  

##### **абстрактный класс**

Абстрактный класс — это класс, который не может быть инстанциирован напрямую. Он используется как шаблон для других классов и может содержать абстрактные методы (без реализации).

  
  

## React

##### зачем нужен

##### виртуальный ДОМ

##### коммит/рендер

##### состояние

##### useMemo, useCallback, memo

##### useEffect

##### context

  
  

## Алгоритмы

  

О() нотация

массивы

хэш-таблицы

бинарный поиск

сортировка

  

### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

```typescript

function isPalindrome(s: string): boolean {

  

  if (s.trim() === "") {

    return true;

  }

  

  let str = "";

  

  const lowerString = s.toLowerCase();

  

  for (let i = 0; i <= lowerString.length - 1; i++) {

    if (

      (lowerString[i] >= "a" && lowerString[i] <= "z") ||

      (lowerString[i] >= "0" && lowerString[i] <= "9")

    ) {

      str += lowerString[i];

    }

  }

  

  let left = 0;

  let right = str.length - 1;

  

  while (left < right) {

    if (str.charCodeAt(left) === str.charCodeAt(right)) {

      left++;

      right--;

    } else {

      return false;

    }

  }

  

  return true;

}

  

```

### [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

```typescript

function isAnagram(s: string, t: string): boolean {

    const n = s.length;

    const m = t.length;

  

    if (n !== m) return false;

    const hash = new Map<string, number>();

  

    for (const i of s) {

        const value = hash.get(i) || 0;

        hash.set(i, value + 1);

    }

  

    for (const i of t) {

        const value = hash.get(i) || 0;

        hash.set(i, value - 1);

  

        if (hash.get(i) < 0) {

            return false;

        }

    }

  

    return true;

};

```

### [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

```typescript

function isValid(s: string): boolean {

    const characters = ['{', '(', '['];

  

    const stack = []

  

    for (let i of s) {

        if (characters.includes(i)) {

            stack.push(i)

        } else {

            if (stack.length > 0) {

                let last = stack.pop()

                if (last === '{' && i !== '}') return false

                if (last === '(' && i !== ')') return false

                if (last === '[' && i !== ']') return false

            } else {

                return false

            }

        }

    }

  

    if (stack.length > 0) return false

  

    return true

};

```

  

### [1. Two Sum](https://leetcode.com/problems/two-sum/)

```typescript

function twoSum(nums: number[], target: number): number[] {

    const map = new Map<number, number>();

  

    for (let i = 0; i < nums.length; i++) {

        let diff = target - nums[i];

        if (map.has(diff)) {

            return [i, map.get(diff)];

        }

        map.set(nums[i], i);

    }

    return [];

};

```

  

### [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const set = new Set(nums);

  

    return nums.length !== set.size;

};

```

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const map = new Map<number, boolean>();

  

    for (let num of nums) {

        if (map.has(num)) return true;

        map.set(num, true);

    }

  

    return false;

};

```

  

### [704. Binary Search](https://leetcode.com/problems/binary-search/)

```typescript

function search(nums: number[], target: number): number {

    const n = nums.length;

    let left = 0;

    let right = n - 1;

  

    while (left <= right) {

        let mid = Math.floor((left + right) / 2);

  

        if (nums[mid] === target) {

            return mid;

        } else if (nums[mid] < target) {

            left = mid + 1;

        } else {

            right = mid - 1;

        }

    }

  

    return -1;

};

```