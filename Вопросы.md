## HTML/ CSS

##### **Что такое семантика в HTML?**
##### Блочные и строчные элементы
##### Для чего нужен DOCTYPE?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%B4%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-doctype "Прямая ссылка на Для чего нужен DOCTYPE?")

**DOCTYPE** — это сокращение от **DOCument TYPE** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег `button` может содержать в себе тег `span`, но не `div`), в то время как DOCTYPE объявляет, к какому DTD _предположительно_ относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим **no-quirks**, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим **quirks**.

DOCTYPE для стандарта HTML5 определяется как `<!DOCTYPE html>`.

##### Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B5%D0%B9-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%BE%D0%B9-%D1%81%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D1%82%D1%81%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%BB%D0%B0%D0%B3%D0%B0%D1%82%D1%8C-link-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-css-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-headhead-%D0%B0-script-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B4%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-js-%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-body-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-%D0%BB%D0%B8-%D0%B2%D1%8B-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F "Прямая ссылка на почему-хорошей-практикой-считается-располагать-link-для-подключения-css-между-headhead-а-script-для-подключения-js-ставить-перед-body-знаете-ли-вы-исключения")

**Размещение `<link>` внутри `<head>`**

Размещение `<link>` внутри тега `<head>` необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

**Размещение `<script>` прямо перед `</body>`**

Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.

##### Что такое прогрессивный рендеринг[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D0%B8%D0%BD%D0%B3 "Прямая ссылка на Что такое прогрессивный рендеринг")

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события `DOMContentLoaded` или `load`, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать [в этой статье](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/).

##### Поток документа

Это принцип организации элементов на странице при отсутствии стилей: если мы напишем HTML и не напишем CSS, то отображение в браузере будет предсказуемо благодаря тому, что мы абсолютно точно знаем, как браузер располагает элементы в потоке.

Даже если к странице не подключено никаких стилей, к каждому элементу всё равно будут применяться CSS-правила, «зашитые» в движке браузера.
https://doka.guide/html/flow/
##### **Что такое селекторы в CSS?**
**Селектор** определяет, к какому элементу применять то или иное CSS-правило.

##### **Что такое специфичность в CSS?**
**Специфичность** - это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу и, следовательно, будут применены. Специфичность основана на правилах соответствия, состоящих из [селекторов CSS](https://developer.mozilla.org/ru/docs/Web/CSS/Reference#selectors) различных типов.
##### **Как работает свойство `position` в CSS?**
##### **Что такое Box Model?** border-box/content-box
##### единицы измерения

## Browser

##### Критические этапы рендеринга
##### reflow/repaint/compose
##### что вычисляется на процессоре
##### CORS
##### cookie
##### REST
##### graph QL
##### GET/POST/PUT/DELETE?PATCH
##### Объясните разницу между `cookie`, `sessionStorage` и `localStorage`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-cookie-sessionstorage-%D0%B8-localstorage "Прямая ссылка на объясните-разницу-между-cookie-sessionstorage-и-localstorage")

Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

||`cookie`|`localStorage`|`sessionStorage`|
|---|---|---|---|
|Инициатор|Клиент или сервер. Сервер может использовать заголовок `Set-Cookie`|Клиент|Клиент|
|Срок хранения|Устанавливается вручную|Всегда|До закрытия вкладки|
|Хранение между сессиями|Зависит от установки срока хранения|Да|Нет|
|Отправка на сервер с каждым HTTP-запросом|автоматически, с помощью заголовка `Cookie`|Нет|Нет|
|Емкость (на один домен)|4 КБ|5 МБ|5 МБ|
|Доступность|В любом окне|В любом окне|В той же вкладке|

###### Ссылки[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8-5 "Прямая ссылка на Ссылки")

- [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
- [http://tutorial.techaltum.com/local-and-session-storage.html](http://tutorial.techaltum.com/local-and-session-storage.html)
##### Объясните разницу между `<script>`, `<script async>` и `<script defer>`.[​](https://www.frontendinterviewhandbook.com/ru/html-questions#%D0%BE%D0%B1%D1%8A%D1%8F%D1%81%D0%BD%D0%B8%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-script-script-async-%D0%B8-script-defer "Прямая ссылка на объясните-разницу-между-script-script-async-и-script-defer")

- `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.
## JS

##### переменные/ let/const/var
##### замыкания
##### рекурсия
##### объекты
##### this
##### event loop
##### методы массивов
##### Promise
##### статические методы promise
##### прототипное насследноваие
##### DOM
##### события
##### всплытие/погружение
##### делегирование событий
##### объект события
##### this/currentTarget vs target
##### логические операторы
##### Map, Set, WeakMap, WeakSet
##### каррирование
##### webworkers
##### стрелочные функции, function declaration/expression
##### Опциональная цепочка '?.'
##### call/apply/bind

## TS

##### **Какие типы данных поддерживает TypeScript?**

- **Ответ:** TypeScript поддерживает:
    
    - Примитивные типы: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
        
    - Сложные типы: `array`, `tuple`, `enum`, `object`, `function`.
        
    - Специальные типы: `any`, `unknown`, `void`, `never`.
##### interface vs type
- `type` может использоваться для создания псевдонимов для любых типов, включая примитивы, объединения и пересечения.
    
- `interface` используется только для описания формы объектов и может быть расширен с помощью `extends`.
##### type guards
##### generics
##### union / intersection
- - **Union types (`|`):** Позволяют указать, что переменная может быть одного из нескольких типов.
        
        typescript
                
        let value: string | number;
        
    - **Intersection types (`&`):** Позволяют объединить несколько типов в один.
        
        typescript
        
        
        type A = { a: string };
        type B = { b: number };
        type C = A & B; // { a: string, b: number }
        

---
##### any vs unknown
`any` — это тип, который отключает проверку типов для переменной. Его следует использовать только в крайних случаях, когда тип неизвестен или сложно определить.
`unknown` — это тип, который требует явного приведения перед использованием. В отличие от `any`, он безопаснее, так как не позволяет выполнять операции без проверки типа.

##### **абстрактный класс**
Абстрактный класс — это класс, который не может быть инстанциирован напрямую. Он используется как шаблон для других классов и может содержать абстрактные методы (без реализации).


## React
##### зачем нужен
##### виртуальный ДОМ
##### коммит/рендер
##### состояние
##### useMemo, useCallback, memo
##### useEffect
##### context


## Алгоритмы

О() нотация
массивы
хэш-таблицы
бинарный поиск
сортировка

### [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
```typescript
function isPalindrome(s: string): boolean {

  if (s.trim() === "") {
    return true;
  }

  let str = "";

  const lowerString = s.toLowerCase();

  for (let i = 0; i <= lowerString.length - 1; i++) {
    if (
      (lowerString[i] >= "a" && lowerString[i] <= "z") ||
      (lowerString[i] >= "0" && lowerString[i] <= "9")
    ) {
      str += lowerString[i];
    }
  }

  let left = 0;
  let right = str.length - 1;

  while (left < right) {
    if (str.charCodeAt(left) === str.charCodeAt(right)) {
      left++;
      right--;
    } else {
      return false;
    }
  }

  return true;
}

```
### [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
```typescript
function isAnagram(s: string, t: string): boolean {
    const n = s.length;
    const m = t.length;

    if (n !== m) return false;
    
    const hash = new Map<string, number>();

    for (const i of s) {
        const value = hash.get(i) || 0;
        hash.set(i, value + 1);
    }

    for (const i of t) {
        const value = hash.get(i) || 0;
        hash.set(i, value - 1);

        if (hash.get(i) < 0) {
            return false;
        }
    }

    return true;
};
```
### [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
```typescript
function isValid(s: string): boolean {
    const characters = ['{', '(', '['];

    const stack = []

    for (let i of s) {
        if (characters.includes(i)) {
            stack.push(i)
        } else {
            if (stack.length > 0) {
                let last = stack.pop()
                if (last === '{' && i !== '}') return false
                if (last === '(' && i !== ')') return false
                if (last === '[' && i !== ']') return false
            } else {
                return false
            }
        }
    }

    if (stack.length > 0) return false

    return true
};
```

### [1. Two Sum](https://leetcode.com/problems/two-sum/)
```typescript
function twoSum(nums: number[], target: number): number[] {
    const map = new Map<number, number>();

    for (let i = 0; i < nums.length; i++) {
        let diff = target - nums[i];
        if (map.has(diff)) {
            return [i, map.get(diff)];
        }
        map.set(nums[i], i);
    }
    
    return [];
};
```

### [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

```typescript
function containsDuplicate(nums: number[]): boolean {
    const set = new Set(nums);

    return nums.length !== set.size;
};
```

```typescript
function containsDuplicate(nums: number[]): boolean {
    const map = new Map<number, boolean>();

    for (let num of nums) {
        if (map.has(num)) return true;
        map.set(num, true);
    }

    return false;
};
```

### [704. Binary Search](https://leetcode.com/problems/binary-search/)
```typescript
function search(nums: number[], target: number): number {
    const n = nums.length;
    
    let left = 0;
    let right = n - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
};
```