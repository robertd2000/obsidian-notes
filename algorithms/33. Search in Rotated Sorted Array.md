[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

Имеется целочисленный массив `nums`, отсортированный по возрастанию (с различными значениями). Перед передачей в вашу функцию `nums`, возможно, вращается с неизвестным индексом поворота `k` `(1 <= k < nums.length) `таким образом, что результирующий массив будет` [nums[k], nums[k 1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (индексированный с `0`). Например, `[0,1,2,4,5,6,7]` может быть вращаться с индексом поворота `3` и стать `[4,5,6,7,0,1,2]`. Учитывая массив nums `после` возможного поворота и целочисленную цель, верните индекс цели, если она находится в `nums`, или `-1`, если она не находится в `nums`. Вы должны написать алгоритм со сложностью выполнения `O(log n)`.

Решение задачи будет с помощью 2 указателей:  `left` и `right`. Смысл в том что мы с помощью бинарного поиска ищем элемент в одной из половин массива и в таком случае одна из половин массива всегда будет отсортирована. При этом в неотсортированной половине массива тоже одна из половин будет отсортирована. 

Итерируемся до тех пор, пока `left <= right`

Находим середину массива (индекс середины массива) `mid` по формуле:
`Math.floor((left + right) / 2)`

Если элемент в середине массива `nums[mid]` равен искомому `target`, то возвращаем `mid`.

Если `nums[left] <= nums[mid]`, то есть ищем в левой части массива и  выполняем   проверку на то, какая часть массива отсортирована: в случае, если  `nums[left] <= target && target <= nums[mid]` (то есть искомое число находится в левой части массива и левая часть массива отсортирована) - уменьшаем `right` до` mid - 1 `(то есть сдвигаем правую границу), иначе сдвигаем левую границу - `left = mid + 1`, так как правая часть массива отсортирована

Иначе проверяем в какой части массива находится число - если в правой и правая часть отсортирована - `nums[mid] <= target && target <= nums[right]`, то сдвигаем левую границу - `left = mid + 1`, иначе сдвигаем правую - `right = mid - 1`

Если число не найдено, возвращает `-1`

![[Pasted image 20240629164428.png]]

```ts

function search(nums: number[], target: number): number {
	const n = nums.length;
	
	let left = 0;
	let right = n - 1;
	
	while (left <= right) {
		let mid = Math.floor((left + right) / 2);
		
		if (nums[mid] == target) return mid;
		
		if (nums[left] <= nums[mid]) {
			if (nums[left] <= target && target <= nums[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		} else {
			if (nums[mid] <= target && target <= nums[right]) {
				left = mid + 1;
			} else { 
				right = mid - 1;
			}
		}
	}
	
	return -1;
};

```
