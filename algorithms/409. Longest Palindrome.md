[409. Longest Palindrome](https://leetcode.com/problems/longest-palindrome/)

Given a string `s` which consists of lowercase or uppercase letters, return the length of the **longest** 

**palindrome**

 that can be built with those letters.

Letters are **case sensitive**, for example, `"Aa"` is not considered a palindrome.

**Example 1:**

**Input:** s = "abccccdd"
**Output:** 7
**Explanation:** One longest palindrome that can be built is "dccaccd", whose length is 7.

**Example 2:**

**Input:** s = "a"
**Output:** 1
**Explanation:** The longest palindrome that can be built is "a", whose length is 1.

**Constraints:**

- `1 <= s.length <= 2000`
- `s` consists of lowercase **and/or** uppercase English letters only.

[409. Самый длинный палиндром](https://leetcode.com/problems/longest-palindrome/)

Для строки `s`, состоящей из строчных или заглавных букв, вернуть длину **самого длинного**

**палиндрома**,

который можно построить с помощью этих букв.

Буквы **чувствительны к регистру**, например, `"Aa"` не считается палиндромом.

**Пример 1:**

**Вход:** s = "abccccdd"
**Выход:** 7
**Объяснение:** Один из самых длинных палиндромов, который можно построить, — это "dccaccd", длина которого равна 7.

**Пример 2:**

**Вход:** s = "a"
**Выход:** 1
**Объяснение:** Самый длинный палиндром, который можно построить, — это "a", длина которого равна 1.

**Ограничения:**

- `1 <= s.length <= 2000`
- `s` состоит только из строчных **и/или** заглавных английских букв.

Задачу можно решить с помощью подсчета входящих элементов. Алгоритм такой: мы считаем сколько раз встретился тот или иной элемент в строке и если на текущей итерации он встретился кратно двум раз, то увеличиваем длину максимального палиндрома на 2, иначе ничего не делаем, но обновляем значение в счетчике. После этого проверяем, есть ли в нашем счетчике хотя бы одно нечетное значение и если есть, то увеличиваем максимальную длину на 1.

Это работает, так как палиндром может быть как четной длины, так и нечетной. В случае если он нечетный, то только одна буква может встретиться нечетное количество раз. В нашем алгоритме мы каждый раз проверяем на нечетность текущее количество вхождений буквы в строку и в случае если оно четно, то увеличиваем результат на 2, иначе ничего не делаем. В итоге у нас в счетчике будет несколько нечетных значений, но из них нам нужно только одно, так как только одна буква может встретиться нечетное количество раз. 

Решим задачу с помощью HashSet. Создадим переменную seen, в которую будем добавлять встреченные нами элементы и переменную res, в которой будем хранить максимальную длину палиндрома:

```typescript
const seen = new Set();

let res = 0;
```

Далее итерируемся по строке и на каждой итерации проверяем, встречалась ли эта буква в сете seen. Если встречалась, то значит сейчас текущая буква находится в seen ка минимум 2 раза. Поэтому увеличиваем res на 2. Так как нас не волнует счетчик сам по себе (не важно какая буква сколько раз встретилась, важно количество повторений), нас больше волнует встречалась ли нам буква или нет. Если нет, то просто добавим ее в seen. Если уже встречалась, то значит она уже была в строке минимум один раз и тогда мы можем удалить ее из seen и обновить res. Мы можем удалить букву из seen так как неважно сколько раз она встречалась, а информация о длине палиндрома и так хранится в res. 

```typescript
for (let c of s) {
	if (seen.has(c)) {
		res += 2;
		seen.delete(c);
	} else {
		seen.add(c);
	}
}
```

Далее нужно проверить, остались ли какие либо элементы в seen. Если остались, то значит минимум одна буква встречается нечетное количество раз и нужно обновить res. Нам не важно сколько раз конкретно встретилась буква и какая именно, важен сам факт того что хотя бы одна буква встретилась нечетное число раз, так как только одна буква может встретиться нечетное количество раз. 

```typescript
if (seen.size) {
	res += 1
}
```

Итоговый код:

```typescript
function longestPalindrome(s: string): number {
    const seen = new Set();

    let res = 0;

    for (let c of s) {
        if (seen.has(c)) {
            res += 2;
            seen.delete(c);
        } else {
            seen.add(c);
        }
    }

    if (seen.size) {
        res += 1
    }

    return res;
};
```

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        seen = set()

        res = 0

        for i in s:
            if i in seen:
                seen.remove(i)
                res += 2
            else:
                seen.add(i)

        if seen:
            res += 1

        return res
```

