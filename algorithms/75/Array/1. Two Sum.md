[1. Two Sum](https://leetcode.com/problems/two-sum/)

Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.

You can return the answer in any order.

**Example 1:**

**Input:** nums = [2,7,11,15], target = 9
**Output:** [0,1]
**Explanation:** Because nums[0] + nums[1] == 9, we return [0, 1].

**Example 2:**

**Input:** nums = [3,2,4], target = 6
**Output:** [1,2]

**Example 3:**

**Input:** nums = [3,3], target = 6
**Output:** [0,1]

**Constraints:**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?

Дан массив целых чисел `nums` и целое число `target`, вернуть _индексы двух чисел так, чтобы их сумма равнялась `target`_.

Можно предположить, что каждый вход будет иметь **_точно_ одно решение**, и нельзя использовать _один и тот же_ элемент дважды.

Ответ можно вернуть в любом порядке.

**Пример 1:**

**Вход:** nums = [2,7,11,15], target = 9
**Выход:** [0,1]
**Объяснение:** Поскольку nums[0] + nums[1] == 9, мы возвращаем [0, 1].

**Пример 2:**

**Вход:** nums = [3,2,4], цель = 6
**Выход:** [1,2]

**Пример 3:**

**Вход:** nums = [3,3], цель = 6
**Выход:** [0,1]

**Ограничения:**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= цель <= 109`
- **Существует только один допустимый ответ.**

**Продолжение:** Можете ли вы придумать алгоритм, который имеет временную сложность меньше, чем `O(n2)`?

Можно решить задачу в лоб за квадратичное время, но есть решение лучше. 

Если массив был бы по умолчанию отсортирован, то можно было бы решить задачу с помощью 2 указателей за линейное время без использования дополнительной памяти. Можно отсортировать его самим, но время выполнения будет n lg n так как сортировка слиянием занимает n lg n, а поиск с помощью 2 указателей n.

3 вариант - использовать хэш таблицу и решить задачу за линейное время. Создадим хэш таблицу map. Далее итерируемся по массиву с числами и помещаем число в эту таблицу map как ключ, а его индекс как значение. Идея алгоритма в том, что мы ищем число равное сумме 2 других чисел в массиве, а значит если мы знаем первое число, то мы легко найдем и второе. Поэтому мы помещаем встреченные нами числа в хэш таблицу. Далее мы проходим еще раз по массиву и отнимаем от искомого числа текущее и проверяем, есть ли такое число в хэш таблице, т. е. среди тех чисел, которые мы уже видели. Если есть, то возвращает текущий индекс и индекс числа из таблицы.

То есть идея в том, что мы каждый раз отнимаем от искомого числа текущее и проверяем, есть ли оно в таблице, встречалось ли оно уже нам. Используем хэш таблицу так как она позволяет иметь доступ к своим элементам за константное время.

Код:

```typescript
function twoSum(nums: number[], target: number): number[] {
    const map = new Map();

    for (let i = 0; i < nums.length; i++) {
        const diff = target - nums[i];

        if (map.has(diff)) {
            const index = map.get(diff);
            return [i, index];
        }

        map.set(nums[i], i);
    }
};
```

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash = {}

        for i in range(len(nums)):
            dif = target - nums[i]
            if dif in hash:
                return [hash[dif], i]
            
            hash[nums[i]] = i

        return []
```

То есть мы отнимаем от искомого target наше текущее число, которое может быть правильным ответом и проверяем, есть ли оно в массиве