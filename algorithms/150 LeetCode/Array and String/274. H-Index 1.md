[274. H-Index](https://leetcode.com/problems/h-index/)

Дан массив целых чисел `citations`, где `citations[i]` - это количество цитирований, полученных исследователем для его `i-й` статьи, вернуть _индекс Хирша исследователя_.

Согласно [определению индекса Хирша в Википедии](https://en.wikipedia.org/wiki/H-index): индекс Хирша определяется как максимальное значение `h`, при котором данный исследователь опубликовал не менее `h` статей, каждая из которых была процитирована не менее `h` раз.

**Example 1:**

**Input:** citations = [3,0,6,1,5]
**Output:** 3
**Explanation:** [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.

**Example 2:**

**Input:** citations = [1,3,1]
**Output:** 1

**Constraints:**

- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`

Основная идея в том, что нужно отсортировать массив по возрастанию и проверять, подходит ли текущее значение. Так как индекс Хирша - это количество статей с как минимум рейтингом равным количеству статей. То есть чтобы иметь индекс Хирша 3, нужно иметь 3 статьи с рейтингом не менее 3. 

Поэтому будем пробегаться по массиву с конца. Заведем переменную `hIndex`, которая будет обозначать текущий индекс Хирша, по умолчанию он будет равен `1`. Далее мы сравниваем последний элемент массива `citations` с `hIndex` и, если он больше или равен ему, то увеличиваем `hIndex` на `1`, так как индекс Хирша точно как минимум равен `hIndex`. В случае, если `hIndex` больше текущего элемента, то значит и другие элементы в массиве меньше чем `hIndex`, так как массив отсортирован, а значит индекс Хирша будет меньше чем текущий `hIndex` на `1` - то есть мы выходим из цикла и возвращаем `hIndex - 1`:

```ts
const n = citations.length;
	
let hIndex = 1;

for (let i = n - 1; i >= 0; i--) {
	if (hIndex > citations[i]) {
		return hIndex - 1;
	}
	
	hIndex++;
}
	  
return n
```

Данное решение работает за `O(n log n)`, так как мы сортируем массив за `n log n`, а алгоритм поиска индекса Хирша выполняется за `n`. Можно улучшить скорость выполнения алгоритма с помощью  сортировки подсчетом - *counting sort*, так как максимальная длина массивов - `1000` и максимальное значение - `1000`, а также элементы в массиве `arr1` повторяются, значит  *counting sort* хорошо подходит для данной задачи, так как позволяет выполнить сортировку быстрее чем *merge sort* или *быструю сортировку* - за `O(n)` вместо `O(n log n)`. Кроме того, максимальное значение, которое нас интересует не может быть больше длины массива `citations` так как индекс Хирша ограничен количеством статей и не может быть больше длинны `citations` `n`, значит мы можем хранить все элементы массива `citations`, которые больше длины `citations` в индекс `citations.length`.

Для этого создадим массив `count` длинной в `1001`, в котором будем хранить количество повторений элементов массива `arr1`. Далее нужно проитерироваться по массиву `arr1` и записать количество повторений значений при этом, если значение больше чем длина массива `n`, то записываем его как `n`:

```ts
const count = new Array<number>(n + 1).fill(0);
  
for (let i of citations) {
	if (i > n) {
		count[n]++;
	} else {
		count[i]++;
	}
}
```


Далее нужно отсортировать массив  `citations` - итерируемся `n` раз и  итерируемся по количеству повторений этого значения и подставляем каждый раз соответствующее значение по индексу `pos`, после чего увеличиваем `pos` на 1:

```ts
	
let pos = 0;
  
for (let i = 0; i <= n; i++) {
	for (let j = 0; j < count[i]; j++) {
		citations[pos] = i;
		pos++;
	}
}
	
```

Таким образом, используя сортировку подсчетом, мы повышаем общую скорость алгоритма до `O(n)`.

Итоговый код:
```ts

function hIndex(citations: number[]): number {
	const n = citations.length;
	const count = new Array<number>(n + 1).fill(0);
	  
	for (let i of citations) {
		if (i > n) {
			count[n]++;
		} else {
			count[i]++;
		}
	}
	
	let pos = 0;
	  
	for (let i = 0; i <= n; i++) {
		for (let j = 0; j < count[i]; j++) {
			citations[pos] = i;
			pos++;
		}
	}
	
	let hIndex = 1;
	
	for (let i = n - 1; i >= 0; i--) {
		if (hIndex > citations[i]) {
			return hIndex - 1;
		}
		
		hIndex++;
	}
	  
	return n
};

```