[169. Majority Element](https://leetcode.com/problems/majority-element/)

Given an array `nums` of size `n`, return _the majority element_.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

**Example 1:**

**Input:** nums = [3,2,3]
**Output:** 3

**Example 2:**

**Input:** nums = [2,2,1,1,1,2,2]
**Output:** 2

**Constraints:**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

Если задан массив `nums` размера `n`, вернуть _элемент большинства_.

Элемент большинства — это элемент, который появляется более `⌊n / 2⌋` раз. Можно предположить, что элемент большинства всегда существует в массиве.

**Пример 1:**

**Вход:** nums = [3,2,3]
**Выход:** 3

**Пример 2:**

**Вход:** nums = [2,2,1,1,1,2,2]
**Выход:** 2

**Ограничения:**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

**Продолжение:** Смогли бы вы решить задачу за линейное время и в `O(1)` пространстве?


## Решение

###  1 Подход

Используя сортировку

Так как по условию _элемент большинства_ это элемент который появляется более `⌊n / 2⌋` раз, то если отсортировать массив, то элемент посередине массива будет  _элементом большинства_ ( _элемент большинства_ займет как минимум более половины массива). Соответственно нужно отсортировать массив и найти индекс середины массива, который и будет искомым значением:
```typescript
function majorityElement(nums: number[]): number {
    const n = nums.length;

    nums.sort((a, b) => a - b);

    const mid = Math.floor(n / 2);

    return nums[mid];
};
```

**Сложность:**
По времени - O(n log n), так как мы сортируем массив nums, что занимает n log n времени.
По памяти - O(1)

###  2 Подход

Использую хэш таблицу

Можно создать хэш таблицу и подсчитать в ней количество повторений значений в массиве. Далее нужно найти как минимум сколько раз должен повторяться  _элемент большинства_ в массиве - `⌊n / 2⌋`:
```python
n = len(nums) // 2
```
После этого нужно пройтись по ключам и значениям хэш таблицы и сравнить количество повторений с  `⌊n / 2⌋` и венрнуть искомый элемент:
```python
for key, val in hash.items():
            if val > n:
                return key 
```

Полное решение:

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        hash = {}

        for i in nums:
            if i in hash:
                hash[i] = hash[i] + 1
            else:
                hash[i] = 1

        n = len(nums) // 2

        for key, val in hash.items():
            if val > n:
                return key 
```
Сложность:**
По времени - O(n)
По памяти - O(n), так как мы используем дополнительную память
###  3 Подход

Без использования дополнительной памяти и за линейное время

1. Алгоритм начинается с предположения, что первый элемент является кандидатом большинства, и устанавливает счетчик равным 1.
2. По мере итерации по массиву он сравнивает каждый элемент с кандидатом:
	a. Если текущий элемент совпадает с кандидатом, он предполагает, что он усиливает элемент большинства, поскольку появляется снова. Поэтому счетчик увеличивается на 1.
	b. Если текущий элемент отличается от кандидата, он предполагает, что может быть равное количество вхождений элемента большинства и других элементов. Поэтому счетчик уменьшается на 1.
- Обратите внимание, что уменьшение счетчика не меняет того факта, что элемент большинства встречается более n/2 раз.
3. Если счетчик становится равным 0, это означает, что текущий кандидат больше не является потенциальным элементом большинства. В этом случае из оставшихся элементов выбирается новый кандидат.
4. Алгоритм продолжает этот процесс, пока не пройдет весь массив.
5. Конечное значение переменной `candidate` будет содержать элемент большинства.

```typescript
function majorityElement(nums: number[]): number {
    let count = 0;
    let candidate = 0;

    for (let num of nums) {
        if (count === 0) {
            candidate = num;
        }

        if (num === candidate) {
            count++;
        } else {
            count--;
        }
    }

    return candidate;
};
```

**Сложность:**
По времени - O(n)
По памяти - O(1)