
[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

Given an integer array `nums`, find the 

subarray

 with the largest sum, and return _its sum_.

**Example 1:**

**Input:** nums = [-2,1,-3,4,-1,2,1,-5,4]
**Output:** 6
**Explanation:** The subarray [4,-1,2,1] has the largest sum 6.

**Example 2:**

**Input:** nums = [1]
**Output:** 1
**Explanation:** The subarray [1] has the largest sum 1.

**Example 3:**

**Input:** nums = [5,4,-1,7,8]
**Output:** 23
**Explanation:** The subarray [5,4,-1,7,8] has the largest sum 23.

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.

[53. Максимальный подмассив](https://leetcode.com/problems/maximum-subarray/)

Для заданного целочисленного массива `nums` найдите

подмассив

с наибольшей суммой и верните _его сумму_.

**Пример 1:**

**Вход:** nums = [-2,1,-3,4,-1,2,1,-5,4]
**Выход:** 6
**Пояснение:** Подмассив [4,-1,2,1] имеет наибольшую сумму 6.

**Пример 2:**

**Вход:** nums = [1]
**Выход:** 1
**Пояснение:** Подмассив [1] имеет наибольшую сумму 1.

**Пример 3:**

**Вход:** nums = [5,4,-1,7,8]
**Выход:** 23
**Пояснение:** Подмассив [5,4,-1,7,8] имеет наибольшую сумму 23.

**Ограничения:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**Продолжение:** Если вы нашли решение `O(n)`, попробуйте закодировать другое решение, используя подход **разделяй и властвуй**, который более тонкий.

Можно решить задачу грубой силой в лоб, проверяя каждый подмассив, но это очень медленное решение: от `O(n^3)` до `O(n^2)` в лучшем случае.

Нужно воспользоваться динамическим программированием и запоминать сумму подмассивов на каждой итерации, при этом игнорируя случаи, когда сумма меньше 0, так как тогда предыдущая сумма элементов не имеет для нас смысла, так как мы ищем максимальную. 

Заведем 2 переменные: `max` - указывающую на максимальную сумму подмассива и `sum` указывающую на текущую сумму элементов. 

Далее итерируемся по элементам nums и на каждой итерации проверяем: `sum` меньше 0? Если да, то присваиваем `sum` 0. Далее прибавляем к `sum` текущее число, после этого обновляем `max`.

```typescript
function maxSubArray(nums: number[]): number {
    let max = nums[0];
    let sum = 0;

    for (let num of nums) {
        if (sum < 0) {
            sum = 0;
        }
        sum += num;
        max = Math.max(max, sum);
    }

    return max;
};
```

То есть на каждой итерации мы прибавляем к sum текущий элемент массива (если сумма sum меньше 0 на предыдущей итерации, то sum = 0) и после этого обновляем max. По умолчанию приравниваем max первый элемент массива, чтобы получить правильный ответ в случае если все элементы массива отрицательные числа. 