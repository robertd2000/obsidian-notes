[849. Maximize Distance to Closest Person](https://leetcode.com/problems/maximize-distance-to-closest-person/)

You are given an array representing a row of `seats` where `seats[i] = 1` represents a person sitting in the `ith` seat, and `seats[i] = 0` represents that the `ith` seat is empty **(0-indexed)**.

There is at least one empty seat, and at least one person sitting.

Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. 

Return _that maximum distance to the closest person_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/10/distance.jpg)

**Input:** seats = [1,0,0,0,1,0,1]
**Output:** 2
**Explanation:** 
If Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.
If Alex sits in any other open seat, the closest person has distance 1.
Thus, the maximum distance to the closest person is 2.

**Example 2:**

**Input:** seats = [1,0,0,0]
**Output:** 3
**Explanation:** 
If Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.
This is the maximum distance possible, so the answer is 3.

**Example 3:**

**Input:** seats = [0,1]
**Output:** 1

**Constraints:**

- `2 <= seats.length <= 2 * 104`
- `seats[i]` is `0` or `1`.
- At least one seat is **empty**.
- At least one seat is **occupied**.


[849. Увеличьте расстояние до ближайшего человека](https://leetcode.com/problems/maximize-distance-to-closest-person/)

Вам дан массив, представляющий ряд мест, где место[i] = 1 представляет человека, сидящего на месте с номером i, а место[i] = 0 представляет, что место с номером i пусто** (индексировано с 0)**.

Есть по крайней мере одно свободное место и по крайней мере один сидящий человек.

Алекс хочет сесть на место так, чтобы расстояние между ним и ближайшим к нему человеком было максимальным.

Верните _это максимальное расстояние до ближайшего человека_.

**Пример 1:**

![](https://assets.leetcode.com/uploads/2020/09/10/distance.jpg)

**Вход:** seats = [1,0,0,0,1,0,1]
**Выход:** 2
**Объяснение:**
Если Алекс сидит на втором свободном месте (т. е. seats[2]), то ближайший человек находится на расстоянии 2.

Если Алекс сидит на любом другом свободном месте, то ближайший человек находится на расстоянии 1.
Таким образом, максимальное расстояние до ближайшего человека равно 2.

**Пример 2:**

**Вход:** seats = [1,0,0,0]
**Выход:** 3
**Объяснение:**
Если Алекс сидит на последнем месте (т. е. seats[3]), то ближайший человек находится на расстоянии 3 мест.
Это максимально возможное расстояние, поэтому ответ 3.

**Пример 3:**

**Вход:** seats = [0,1]
**Выход:** 1

**Ограничения:**

- `2 <= seats.length <= 2 * 104`
- `seats[i]` равно `0` или `1`.
- По крайней мере одно место **пусто**.
- По крайней мере одно место **занято**.

Задача решается за линейное время и без использования дополнительной памяти. Нужно учесть два пограничных случая:
- когда массив начинается с 0
- когда массив заканчивается 0

Начнем с того, что инициализируем 2 переменные:

```typescript
let max = 0;
let count = 0;
```

`max` - максимальная дистанция между сидениями, `count` текущее расстояние между 2 сидениями. 

Для начала обработаем стандартный сценарий, когда массив начинается с `1` и заканчивается `1`. Для начала мы должны посчитать количество подряд идущих пустых мест, а затем найти их максимальную длину в массиве:

```typescript
if (seats[i] === 0) {
	count++;
} else {
	count = 0;
}
```

Если текущий элемент массива равен `0`, то увеличиваем `count` на единицу, иначе обнуляем `count`. Таким образом мы узнаем количество идущих подряд нулей. Далее нужно узнать сколько максимум кресел (нулей) идут подряд:

```typescript
max = Math.max(max, Math.ceil(count / 2));
```

Так как мы рассчитываем стандартный сценарий, то нужно округлить `count / 2`, так как нужно узнать расстояние до ближайшего кресла, когда пустые кресла находятся между 2 занятыми: то есть мы узнаем максимальное расстояние между креслами справа и слева, так как пустое кресло с максимальным расстоянием от ближайшего будет находится между 2 занятыми креслами (то есть кресла с 2 сторон).

В итоге ответом будет `max`. 

Однако необходимо еще обработать вышеуказанные случаи, когда массив начинается с `0` и/или заканчивается `0`. 

Если массив заканчивается `0`, то значит мы может сесть на последнее кресло, так как справа от него кресел нет и тогда нам не нужно делить `count` на `2`, то есть мы можем взять все расстояние от левого кресла (все пустые кресла идущие подряд до конца массива в случае если последнее кресло тоже пустое). Для этого проверим, равен ли  `i` последнему индексу в массиве: если да, то рассчитаем `max` от предыдущего `max` и текущего `count`. Иначе выполним старую проверку:

```typescript
if (i === n - 1) {
	max = Math.max(max, count);
} else {
	max = Math.max(max, Math.ceil(count / 2));
}
```

Наконец, нужно предусмотреть случай, когда массив начинается с `0`. Есть 2 способа решения - с помощью дополнительного цикла (скорость выполнения при этом не изменится) и с помощью дополнительной переменной.

Используем дополнительный цикл: 

```typescript
let i = 0;
```

Далее сделаем проверку на то, что первый элемент массива равен `0` и, в таком случае, выполним цикл до тех пор, пока текущий элемент массива равен `0`. В теле цикла увеличим `count`, так как это идущие подряд `0` и рассчитаем `max`:

```typescript
if (seats[0] === 0) {
	while (seats[i] === 0) {
		count++;
		max = Math.max(max, count);
		i++;
	}
}
```

В данном случае `max = Math.max(max, count)`, так как слева нет кресел. То есть если первый элемент массива равен нулю, мы ищем количество идущих подряд нулей с начала массива. Далее мы выполняем предыдущий цикл (начать его можно с `i`, чтобы не было лишних итераций).

Можно использовать доп. переменную, просто указывающую, что первый элемент массива равен `0` и если он равен нулю, то рассчитывать `max` как `Math.max(max, count)`.

Итоговое решение:

```typescript
function maxDistToClosest(seats: number[]): number {
    const n = seats.length;

    let max = 0;
    let count = 0;
    let i = 0;

    if (seats[0] === 0) {
        while (seats[i] === 0) {
            count++;
            max = Math.max(max, count);
            i++;
        }
    }

    for (; i < n; i++) {
        if (seats[i] === 0) {
            count++;
            if (i === n - 1) {
                max = Math.max(max, count);
            } else {
                max = Math.max(max, Math.ceil(count / 2));
            }
        } else {
            count = 0;
        }
    }

    return max;
};
```

Сложность алгоритма:
- по времени - `O(n)`
- по памяти - `O(1)` - так как мы не используем дополнительной памяти