[240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)

Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix `matrix`. This matrix has the following properties:

- Integers in each row are sorted in ascending from left to right.
- Integers in each column are sorted in ascending from top to bottom.

Напишите эффективный алгоритм, который ищет значение `target` в матрице целых чисел `m x n`. Эта матрица имеет следующие свойства:

- Целые числа в каждой строке сортируются по возрастанию слева направо.
- Целые числа в каждом столбце сортируются по возрастанию сверху вниз.
**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg)

**Input:** matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
**Output:** true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg)

**Input:** matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
**Output:** false

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= n, m <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- All the integers in each row are **sorted** in ascending order.
- All the integers in each column are **sorted** in ascending order.
- `-10^9 <= target <= 10^9`

Для решения задачи воспользуемся фактом, что строки и столбцы матрицы отсортированы. Значит, если мы начнем с правого верхнего угла и будем сравнивать значение с `target`, то:

- если значение больше чем `target`, то значит все что справа от текущего значения не подходит, так как тоже будет больше чем `target`. Значит нужно уменьшить текущее значение (столбец).
- если значение меньше чем target, то все что слева будет меньше чем `target`, а все что справа мы уже проверили, так как начали с правого верхнего угла. В таком случае, нужно смотреть на нижнюю строку, так как значения в ней будут больше чем в текущей строке.
- если значение найдено, возвращаем его

Итак, создаем две переменные `row`, которая будет обозначать строку (по умолчанию `0`) и `col`, которая будет указывать на столбец (по умолчанию будет `matrix[i].length == n` ) . 
Создадим цикл, который будет выполняться до тех пор, пока `row < n` (чтобы не выйти за границы `matrix`) и пока` col >= 0` (чтобы не выйти за границы `matrix[i]`). То есть в худшем случае мы проверим все элементы матрицы. 

В теле цикла проверяем, является текущий элемент искомым и, если да, возвращаем `true`. 
Иначе проверим, больше ли текущий элемент чем искомый. Если да, то все что справа от него не подходит, значит нужно проверить то что слева. Значит нужно уменьшить `col` на `1`. 
Иначе, если элемент меньше текущего, то искать  слева не имеет смысла, так как все элементы слева меньше (справа тоже, так как мы там уже проверили). Поэтому нужно воспользоваться тем, что матрица отсортирована и по вертикали (по столбцам) и посмотреть на строку ниже, так как значение там будет выше чем в текущей строке - увеличить `row` на `1`. 

Если после того, как мы проверили все элементы, искомый так и не был найден, то возвращаем `false`.

```ts

function searchMatrix(matrix: number[][], target: number): boolean {
	const n = matrix.length;
	const m = matrix[0].length;
	
	let row = 0;
	let col = m - 1;
	
	while (row < n && col >= 0) {
		if (matrix[row][col] === target) {
			return true;
		}
			else if (matrix[row][col] > target) {
		col--;
		} else {
			row++;
		}
	}
	
	return false;
};

```

Cкорость алгоритма - `O(m+n)`

