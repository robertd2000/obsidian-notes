```ts

console.log('foo');

setTimeout(() => {
  console.log('bar');
}, 0);

queueMicrotask(() => {
  console.log('baz');
  Promise.resolve().then().then(() => console.log('ban'));
});

new Promise((resolve) => {
  console.log('bla');
  resolve('baf');
}).then(console.log);

console.log('bak');

// foo bla bak baz baf ban bar

//-----------------------------

/*
Необходимо написать функцию которая будет возвращать массив чисел фибоначи.*
Решить наиболее оптимальным образом.

* числа фибоначи это последовательность чисел,
где каждое следующее число, является суммой 2х предыдущих.

Пример: fibonacci(5) -> 1,2,3,5,8
*/
function fibonacci(num) {
    if (num < 1) return 1

    return fibonacci(num - 1) + fibonacci(num - 2)
}

console.log(fibonacci(10))


//-----------------------------

class Parent {
  foo() {
    console.log('It works!');
  }
}

class Example extends Parent {
}


/* Solution after time */
function partial(ex, mixin) {
    Object.setPrototypeOf(mixin, Object.getPrototypeOf(ex.prototype))
    Object.definePrototype(ex.prototype, Object.getOwnPropertyDescriptors(mixin))
}

partial(Example, {
  foo() {
    super.foo();
    console.log('Yeaaah');
  },

  get bar() {
    return Math.random();
  }
});

const example = new Example();

example.foo(); // It works! Yeaaah

console.log(example.bar); // Случайное число
console.log(example.bar); // Случайное число
console.log(example.bar); // Случайное число
```

```js

// console.log(1); // 1

// setTimeout(() => console.log(2), 0);

// Promise.resolve().then(() => console.log(3));

// let prom = new Promise(function(resolve, reject) {
// console.log(4);
// resolve();
// });

// prom.then(function() {
// console.log(5);
// })

// Promise.resolve().then(()=> setTimeout(() => console.log(6));

// Promise.resolve().then(()=> console.log(7)));

// setTimeout(() => console.log(8), 0);

// console.log(9);

// 1 4 9 3 5 7 2 8 6

// 4 Напишите функцию mergeTwoArrays(a, b), которая принимает два массива a и b в качестве входных данных.

// Функция должна возвращать новый массив, содержащий все элементы двух исходных массивов, чередующиеся между собой.

console.log(mergeArrays(['a', 'b', 'c', 'd', 'e'] , [1, 2, 3, 4, 5]))
// ['a', 1, 'b', 2, 'c', 3, 'd', 4, 'e', 5]
console.log(mergeArrays([1, 2, 3], ['a', 'b', 'c', 'd', 'e', 'f'] ))
// [1, 'a', 2, 'b', 3, 'c', 'd', 'e', 'f']

function mergeArrays(a1, a2) {
  const res = []

  const n = a1.length
  const m = a2.length

  let k = n < m ? n : m
  let i = 0

  while (i < k) {
    res.push(a1[i])
    res.push(a2[i])
    i ++
  }

  if (k < n) {
    res.push(...a1.slice(k))
  }

  if (k < m) {
    res.push(...a2.slice(k))
  }

  return res
}

// Vladislav Naumenko
// Напишите функцию sum(num1, num2) ), которая принимает в качестве параметров номера банковских карт в виде строк и возвращает их сумму. BigInt использовать нельзя.


function sum(num1, num2) {
  let n = num1.length
  let res = Array(n).fill(0)

  let k = 0

  let i = n - 1

  while (i >= 0) {
    let sum = +num1[i] + +num2[i]

    let a = sum >= 10 ? sum % 10 : sum
    if (k) a += k

    if (sum >= 10) {
      k = 1
    } else {
      k = 0
    }

    res[i] = a
    i -= 1
  }

  return res.join('')
}

console.log(sum('2200290526525457', '2200290526525457'))
console.log(BigInt(2200290526525457) + BigInt(2200290526525457))

```

// напиши функцию чтобы она работала с любым массивом и возвращала уникальные элементы массива

```ts

Array.prototype.findUnique = function() {
    const map = new Map();
    
    for (let i = 0; i < this.length; i++) {
        const val = map.get(this[i]) || 0
        map.set(this[i], val + 1)
    }

    return this.filter((i) => map.get(i) === 1)
}
console.log([2, 2, 3, 4, 5, 4, 1, 3, 2, 6].findUnique()); // 5 1 6

```


![[Pasted image 20250307123901.png]]

1 promise  4 timeout 777 t1 t2 tim2
start end p1 p2 time 3 5 

![[Pasted image 20250309163052.png]]

![[Pasted image 20250310113247.png]]
![[Pasted image 20250310113710.png]]
![[Pasted image 20250310114440.png]]
![[Pasted image 20250310144018.png]]
![[Pasted image 20250310144621.png]]

```ts

function strjoin(delimeter, ...strings) {
    return strings.join(delimeter)
}

console.log(strjoin('-', 'a', 'b', 'c'))

```

```ts

const square = x => x * x;
const times2 = x => x * 2;
const sum = (a, b) => a + b;

function compose(...fns) {
    return (...args) => {
        return fns.reduceRight((acc, fn) => {
            if (Array.isArray(acc)) return fn(...acc)
            
            return fn(acc)
        }, args)
    }
}

console.log(compose(square, times2)(2), compose(square, times2)(2) === square(times2(2)));
console.log(compose(square, times2, sum)(3, 4), compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));


```

![[Pasted image 20250310160345.png]]
```ts

import asyncAuth from '.'

function auth() {
	return new Promise((res, rej) => {
		asyncAuth((error, data) => {
			if (error) return rej(error)
			return res(data)
		})
	})
}

```

![[Pasted image 20250310162318.png]]

```ts

async function tryAuth(n) {
	try {
		const data = await auth()

		return data
	} catch (err) {
		n--;
		if (n === -1) throw err;
		return tryAuth(n)  
	}	
}
```

![[Pasted image 20250310164045.png]]

```ts

function callLimit(fn, limit, callback) {
    let n = 0;
    
    const f = function(...args) {
        if (n === limit) return;
        if (n === limit && callback) {
            setTimeout(() => callback(), 0)
        }
        n++;
        return fn(...args)
    }
    
    f.reset = function() {
        n = 0
    }
    
    return f
}

function log(title, message) {
	console.log(title, message)
}

var logLimited = callLimit(log, 3)
logLimited("1", "d")
logLimited("2", "d")
logLimited("3", "d")
logLimited("4", "d")

logLimited.reset()

logLimited("5", "d")
logLimited("6", "d")
logLimited("7", "d")
logLimited("8", "d")

```

![[Pasted image 20250310171433.png]]

![[Pasted image 20250311134856.png]]

```ts

type Bike = {ride : () => void;}

type Car = {drive: () => void;}

type Plane = {fly : () => void;}

  

type Entity = Bike | Car | Plane

  

const isCar = (entity: Entity): entity is Car => {

  return entity.hasOwnProperty("drive")

}

  

const isBike = (entity: Entity): entity is Bike => {

  return entity.hasOwnProperty("ride")

}

  

const actWith = (entity: Entity) => {

  if (isCar(entity)) {

    entity.drive()

  }

  

  if (isBike(entity)) {

    entity.ride()

  }

}

  

const car: Car = {

  drive: () => {

    console.log('car')

  }

}

  

const bike: Bike = {

  ride: () => {

    console.log('ride')

  }

}

```

![[Pasted image 20250312160608.png]]

![[Pasted image 20250312160701.png]]

![[Pasted image 20250313124753.png]]

```js

const  asyncLimit = (fn, n) => {
    return async (...args) => {
        const timer = new Promise((_, rej) => {
            setTimeout(() => rej(new Error("Function execution timed out")), n)
        })
        
        return Promise.race([fn(...args), timer])
    }
}

const fn = async (n) => {
	await new Promise(res => setTimeout(res, 100));
	
	return n * n;
}

const fn2 = async (a, b) => {
	await new Promise(res => setTimeout(res, 120));
	
	return a + b;
}

const limitedFn = asyncLimit(fn, 50);
limitedFn(5).then(console.log).catch((err) => console.log(err.message)); // "Function execution timed out"

const limitedFn2 = asyncLimit(fn, 150);
limitedFn2(5).then(console.log).catch((err) => console.log(err.message)); // 25

const limitedFn3 = asyncLimit(fn2, 100);
limitedFn3(1, 2).then(console.log).catch((err) => console.log(err.message)); // "Function execution timed out"

const limitedFn4 = asyncLimit(fn2, 150);
limitedFn4(1, 2).then(console.log).catch((err) => console.log(err.message)); // 3


```
![[Pasted image 20250313131647.png]]

```js

class MinStack {
	stack = []
    minStack = []
	min = Infinity
	
	pop() {
		let prev = this.stack.pop();

		if (prev === this.min) {
			this.min = this.minStack.pop()
		}
	}

	push(val) {
		if (val < this.min) {
			this.minStack.push(this.min)
			this.min = val
		}

		this.stack.push(val)
	}
	getMin() {
		return this.min
	}
}

const stack = new MinStack()

stack.push(10)
stack.push(12)
console.log(stack.getMin())
stack.push(5)
console.log(stack.getMin())
stack.push(3)
console.log(stack.getMin())
stack.pop()
console.log(stack.getMin())
stack.pop()
console.log(stack.getMin())


```

```js
console.log(1)

setTimeout(() => console.log(2))

Promise.resolve(3).then(console.log)

Promise.resolve().then(() => setTimeout(() => console.log(4)))

Promise.resolve(5).then(console.log)

setTimeout(() => console.log(6))

console.log(7)

// 1 7 3 5 2 6 4

```

```js

console.log(1)

setTimeout(() => console.log(2))

Promise.reject(3).catch(console.log)

new Promise((res) => setTimeout(res)).then(() => console.log(4))

Promise.resolve(5).then(console.log)

console.log(6)

setTimeout(() => console.log(7))

// 1 6 3 5 2 4 7

```

![[Pasted image 20250327160025.png]]

```js

console.log(Boolean(1)) // true

console.log(Boolean("0")) // true

console.log(Boolean("")) // false

console.log(Number("  123   ")) // 123

console.log(Number("  123;   ")) // NaN

console.log(Number(true)) // 1

console.log([].push(1, 2).unshift(3).join()) // error 

console.log(2 && 1 && 0 && null && 0 && undefined) // 0

let obj = {
	"0": 1,
	0: 2
}

console.log(obj["0"] + obj[0]) // 4

let name = "Billy"

function sayHi() {
	console.log(name)
}

setTimeout(() => {
	let name = "Van"
	sayHi()
}, 1000)

// Billy

let x = 5
console.log(x++) // 5

```

```js

function isAnagram(s, p) {
	const n = s.length;
	const m = p.length;

	if (n != m) return false;
	
	const map = new Map();

	for (let c of s) {
		const key = c.toLowerCase()
		const val = map.get(key) || 0;
		map.set(key, val + 1);
	}

	for (let c of p) {
		const key = c.toLowerCase()
		const val = map.get(key) || 0;
		map.set(key, val - 1);

		if (map.get(key) < 0) {
			return false;
		}
	}

	
	return true;
}

console.log(isAnagram('abc', 'cba')); // true
console.log(isAnagram('abc', 'cbaf')); // true

```

```js

function isInt(n) {
	return n == Math.round(n)
}

console.log(isInt(4))
console.log(isInt(4.2))
console.log(isInt(-4.2))
console.log(isInt(-4))
```

```ts

const test: number[] = Array.from(Array(5), (_, index) => index);

  

const promises = test.map((item, index) => {

    return new Promise((res, rej) => setTimeout(() => res(index), index * 100))

})

  

const promiseAll = async <T, >(promises: Promise<T>[]): Promise<T[]> => {

    const result: T[] = []

    return await new Promise((res, rej) => {

  

        promises.forEach(async promise => {

            promise.then(val => {

                result.push(val)

                if (result.length === promises.length) res(result)

            }).catch(rej)

        })

    })

}

  

promiseAll(promises).then(data => console.log(data))

```

```ts
type CurriedFunction = ((b: number) => CurriedFunction) & (() => number);

  

function carried(a: number): CurriedFunction {

    function inner(b?: number): any {

        if (b !== undefined) {

            return carried(a + b);

        }

        return a;

    }

    return inner as CurriedFunction;

}

  

console.log(carried(2)(3)(4)(10)(11)());  // Output: 30
```
![[Pasted image 20250409155513.png]]
```js

const input = [
    { value: 'abcd', order: 4, expired: false },
    { value: 'quer', order: 2, expired: true },
    { value: 'xyz1', order: 1, expired: false },
    { value: 'abx2', order: 3, expired: false },
];

function cancateFromArr(arr) {
	return arr.filter(item => !item.expired)
		.sort((a, b) => a.order - b.order)
		.map(item => item.value.split('').reverse().join(''))
		.join('')
			.split('')
			.filter((item, idx, arr) => arr.indexOf(item) === idx)
			.join('')
		
}

console.log(cancateFromArr(input))

```

```js

const input = [
    { value: 'abcd', order: 4, expired: false },
    { value: 'quer', order: 2, expired: true },
    { value: 'xyz1', order: 1, expired: false },
    { value: 'abx2', order: 3, expired: false },
];

function cancateFromArr(arr) {
	arr.sort((a, b) => a.order - b.order)

	
    const str = arr.reduce((acc, val) => {
        if (!val.expired) return acc += val.value.split('').reverse().join('')
        return acc
    }, '')
    
    return str.split('')
		.filter((item, idx, arr) => arr.indexOf(item) === idx)
		.join('')
    
}

console.log(cancateFromArr(input))

```
```js


const input = [
    { value: 'abcd', order: 4, expired: false },
    { value: 'quer', order: 2, expired: true },
    { value: 'xyz1', order: 1, expired: false },
    { value: 'abx2', order: 3, expired: false },
];

function cancateFromArr(arr) {
    return arr
        .sort((a, b) => a.order - b.order)
        .reduce((acc, val) => {
            if (!val.expired) {
                let value = val.value
                let a = ''
                
                for (let i = value.length - 1; i >= 0; i--) {
                    const item = value[i]
                    if (!acc.includes(item)) a += item
                }
    
                return acc + a
            }
            return acc
        }, '')
}

console.log(cancateFromArr(input))

```

![[Pasted image 20250409174515.png]]
```js
const run = () => {
    setTimeout(() => {
        console.log('timeOut');
    }, 0);

    console.log(1);

    new Promise((resolve) => {
        console.log('Promise');
        setTimeout(() => {
            console.log('777');
            resolve();
        }, 0);
    })
    .then(() => {
        console.log('then1');
    })
    .then(() => {
        console.log('then2');
    });
    
    console.log(4);

    setTimeout(() => {
        console.log('timeOut2');
    }, 0);
};

run();
```
1 Pr 4 tm1 777 t1 t2 tm2 
### 🔹 Порядок вывода в консоль:

1. `1`
    
2. `Promise`
    
3. `4`
    
4. `timeOut`
    
5. `777`
    
6. `then1`
    
7. `then2`
    
8. `timeOut2`


```ts

type ArrType = Array<number> | ArrType
const array = [1, [2, [3]], [4, 5]]
```

![[Pasted image 20250409181240.png]]

```ts

type ExampleType = {
    Field1: string
    Field2: string
    Field3: number
    Field4: boolean
}


type StringKeys<T> = keyof Pick<T, { [K in keyof T]: T[K] extends string ? K : never }[keyof T]>;
type Result = StringKeys<ExampleType>; // "Field1" | "Field2"

```

```ts

const X = {a: 1, b: 2, c: 3, d: 4}

const Y = {a: '1', b: '2', c: '3', d: '4'}

  

function getProperty<K extends keyof T, T>(obj: T, key: K): T[K] {

    return obj[key]

}

  

console.log(getProperty(X, 'a'))

console.log(getProperty(X, 'v'))

console.log(getProperty(Y, 'a'))

```

![[Pasted image 20250410122919.png]]

![[Pasted image 20250410132053.png]]
заблокирует рендер, тк выполняется синхронно
можно вынести в useEffect или сделать вот так () => heavyFunc(count)
![[Pasted image 20250410132241.png]]

![[Pasted image 20250410132934.png]]

это работает, тк useEffect асинхронный и return  срабатывает раньше
![[Pasted image 20250411112936.png]]

![[Pasted image 20250411113730.png]]

![[Pasted image 20250411113858.png]]
![[Pasted image 20250411145759.png]]

![[Pasted image 20250411145819.png]]

```js

// Выровнять глубоко вложенный массив без использования `Array.flat`
// Максимально-возможный уровень вложенности - 1000

/**
    * @param {any[]} arr
    * @param {number} depth
    * @return {any[]}
*/

const arr = [1, [2, [3, [4, 5]]], 6];
const a = flat(arr, 1);
// Ожидаемый результат: [1, 2, [3, [4, 5]], 6]
console.log(a)

function flat(arr, n) {
    const res = []
    
    const f = (m, arr) => {
        for (let i = 0; i < arr.length; i++) {
        		if (Array.isArray(arr[i]) && m >= 0) {
        		    if (m === 0) {
        		        res.push(arr[i])
        		    } else {
        	   		    f(m - 1, arr[i])	        
        		    }
     
        		} else {
        		    res.push(arr[i])
        		}
        	}
        
        return 
    }

    f(n, arr)
    return res
}

function flat2(arr, n) {
    const res = []
    
    const flatten = (arr, deph) => {
        for (let i of arr) {
            if (Array.isArray(i) && deph > 0) {
                flatten(i, deph - 1)
            } else {
                res.push(i)
            }
        }
    }

    flatten(arr, n)
    return res
}

```

![[Pasted image 20250415113204.png]]

```js

class Stack {
    constructor() {
        this.storage = [];
    }

    push(data) {
        this.storage.push(data);
    }

    pop() {
        return this.storage.pop();
    }

    size() {
        return this.storage.length;
    }
}

class Queue {
    constructor() {
        this.stack1 = new Stack();
        this.stack2 = new Stack();
    }

    // Добавить в очередь
    enqueue(data) {
	    this.stack1.push(data)
    }
    
    // Вернуть следующего в очереди
    dequeue() {}
    
    // Сколько в очереди
    count() {}
}

const queue = new Queue();

queue.enqueue(1);
queue.enqueue(2);

queue.dequeue(); // 1

queue.enqueue(3);
queue.enqueue(4);

queue.dequeue(); // 2
```

![[Pasted image 20250422163458.png]]

![[Pasted image 20250422165332.png]]

1 5 8 3 6 2 7 4

```js

function sleep(ms) {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve(ms)
		}, ms)
	})
}
```

```ts

type SleepType =
  | 500
  | 1000
  | 1500
  | 2000
  | 2500
  | 3000
  | 3500
  | 4000
  | 4500
  | 5000;

function sleepTS<T extends number>(ms: T): Promise<T> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(ms);
    }, ms);
  });
}

sleepTS(1000)
  .then((res) => console.log(res))
  .then((res) => {
    console.log(res);
    return sleepTS(500);
  })
  .then((res) => {
    console.log(res);
  });
  
// 1s -> 1000
// undefined
// 500ms -> 500

```
![[Pasted image 20250422215921.png]]
1 3 4 2

![[Pasted image 20250422221141.png]]

```js

// клон obj c тем же прототипом (с поверхностным копированием свойств)` 
let clone = Object.create(
	Object.getPrototypeOf(obj),
	Object.getOwnPropertyDescriptors(obj))
;

```

axios interseptor 401 ошибка promise all refresh token если упадут 5 запросов


```ts

let isRefreshing = false;
let failedRequests: (() => void)[] = [];

api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && originalRequest && !originalRequest._retry) {
      if (isRefreshing) {
        return new Promise((resolve) => {
          failedRequests.push(() => {
            originalRequest._retry = true;
            resolve(api(originalRequest));
          });
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        const newAccessToken = await refreshToken();
        isRefreshing = false;
        
        api.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;
        
        failedRequests.forEach((callback) => callback());
        failedRequests = [];
        return api(originalRequest);
      } catch (refreshError) {
        failedRequests.forEach((callback) => callback());
        failedRequests = [];
        isRefreshing = false;
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```