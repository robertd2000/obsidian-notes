# Индексы в SQL: подробное руководство

## Что такое индекс и зачем он нужен?

**Индекс** — это специальная структура данных, которая ускоряет операции извлечения данных из таблицы за счет дополнительных затрат на запись и хранение.

### Аналогия
Представьте книгу:
- **Без индекса**: Чтобы найти нужную тему, нужно просмотреть всю книгу
- **С индексом**: Смотрите в оглавление и сразу переходите на нужную страницу

## Принцип работы индексов

Индексы работают по принципу **сбалансированных деревьев (B-tree, B+tree)**, которые:
- Обеспечивают логарифмическую сложность поиска O(log n)
- Поддерживают сортировку данных
- Эффективны для диапазонных запросов

## Основные виды индексов

### 1. B-tree индекс (Балансированное дерево)
**Наиболее распространенный тип**

```sql
-- Создание B-tree индекса
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_date ON orders(order_date DESC);
```

**Когда использовать:**
- Точечные запросы (WHERE column = value)
- Диапазонные запросы (BETWEEN, >, <)
- Сортировка (ORDER BY)
- JOIN операции

**Ограничения:**
- Не эффективен для поиска по части строки (LIKE '%pattern%')
- Не подходит для колонок с низкой селективностью

### 2. Bitmap индекс
```sql
-- Создание bitmap индекса (поддерживается не всеми СУБД)
CREATE BITMAP INDEX idx_employees_gender ON employees(gender);
```

**Когда использовать:**
- Колонки с низкой кардинальностью (малое количество уникальных значений)
- Булевы значения (true/false)
- Статусные поля (активный/неактивный)

**Преимущества:**
- Эффективен для агрегаций
- Меньший размер compared to B-tree для low-cardinality данных

**Недостатки:**
- Высокая стоимость обновления
- Не подходит для часто изменяемых данных

### 3. Hash индекс
```sql
-- Создание hash индекса
CREATE INDEX idx_users_id_hash ON users USING HASH (id);
```

**Когда использовать:**
- Только точечные запросы (равенство)
- Частые поиски по точному соответствию

**Ограничения:**
- Не поддерживает диапазонные запросы
- Не поддерживает сортировку
- Может быть неэффективен при коллизиях

### 4. GiST (Generalized Search Tree)
```sql
-- Пример для PostgreSQL
CREATE INDEX idx_geodata_location ON geodata USING GIST (location);
```

**Когда использовать:**
- Географические данные
- Полнотекстовый поиск
- Иерархические данные

### 5. GIN (Generalized Inverted Index)
```sql
-- Для JSON данных в PostgreSQL
CREATE INDEX idx_users_profile_gin ON users USING GIN (profile);
```

**Когда использовать:**
- Составные значения (массивы, JSON)
- Полнотекстовый поиск
- Быстрый поиск по элементам массива

### 6. Covering Index (Покрывающий индекс)
```sql
-- Индекс, содержащий все необходимые для запроса данные
CREATE INDEX idx_orders_covering ON orders (customer_id, order_date) 
INCLUDE (total_amount, status);
```

**Когда использовать:**
- Частые запросы, выбирающие ограниченный набор колонок
- Избегание обращений к таблице

### 7. Unique индекс
```sql
CREATE UNIQUE INDEX idx_users_username_unique ON users(username);
```

**Когда использовать:**
- Гарантия уникальности значений
- Первичные и внешние ключи

### 8. Composite/Compound индекс (Составной)
```sql
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date DESC);
```

**Когда использовать:**
- Запросы с несколькими условиями WHERE
- Сортировка по нескольким колонкам
- JOIN по нескольким колонкам

**Важно**: Порядок колонок имеет значение (правило левого префикса)

### 9. Function-based индекс
```sql
-- Индекс на результат функции
CREATE INDEX idx_users_lower_name ON users(LOWER(username));
CREATE INDEX idx_orders_year ON orders(EXTRACT(YEAR FROM order_date));
```

**Когда использовать:**
- Поиск по преобразованным значениям
- Case-insensitive поиск

### 10. Partial/Filtered индекс (Частичный)
```sql
-- Индекс только для части данных
CREATE INDEX idx_orders_active ON orders(status) 
WHERE status = 'active';

CREATE INDEX idx_users_premium ON users(premium_expiry) 
WHERE is_premium = true;
```

**Когда использовать:**
- Большие таблицы, где нужна только часть данных
- Частые запросы с определенным условием
- Экономия места и улучшение производительности

### 11. Full-text индекс
```sql
-- Для полнотекстового поиска
CREATE INDEX idx_documents_content_fts ON documents 
USING GIN (to_tsvector('english', content));
```

**Когда использовать:**
- Поиск по текстовому содержимому
- Релевантный поиск

### 12. Spatial индекс
```sql
-- Для географических данных
CREATE SPATIAL INDEX idx_locations_geo ON locations(geo_point);
```

**Когда использовать:**
- GIS приложения
- Поиск ближайших объектов
- Пространственные запросы

## Стратегии применения индексов

### Когда создавать индексы:
1. **Первичные ключи** - автоматически создаются unique индекс
2. **Внешние ключи** - обязательно индексировать для JOIN
3. **Часто используемые в WHERE** колонки
4. **Колонки для сортировки** (ORDER BY)
5. **Колонки для группировки** (GROUP BY)
6. **Колонки для JOIN**

### Когда НЕ создавать индексы:
1. **Маленькие таблицы** (< 1000 строк)
2. **Часто изменяемые таблицы** - каждый индекс замедляет INSERT/UPDATE/DELETE
3. **Колонки с низкой селективностью** (пол с 2 значениями)
4. **Колонки, редко используемые в запросах**

## Мониторинг и оптимизация индексов

### Анализ использования индексов:
```sql
-- PostgreSQL
SELECT * FROM pg_stat_all_indexes WHERE schemaname = 'public';

-- MySQL
SHOW INDEX FROM table_name;

-- Анализ запросов
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```

### Поиск неиспользуемых индексов:
```sql
-- PostgreSQL
SELECT * FROM pg_stat_all_indexes 
WHERE idx_scan = 0 AND schemaname = 'public';
```

### Перестроение индексов:
```sql
-- Перестроение индекса
REINDEX INDEX index_name;

-- Перестроение всех индексов таблицы
REINDEX TABLE table_name;
```

## Лучшие практики

### 1. Принцип избирательности
```sql
-- Хорошо: высокая селективность
CREATE INDEX idx_users_email ON users(email);

-- Плохо: низкая селективность
CREATE INDEX idx_users_gender ON users(gender);
```

### 2. Правило левого префикса
```sql
-- Индекс (a, b, c) будет работать для:
-- WHERE a = 1
-- WHERE a = 1 AND b = 2
-- WHERE a = 1 AND b = 2 AND c = 3

-- Но НЕ будет работать для:
-- WHERE b = 2
-- WHERE c = 3
-- WHERE b = 2 AND c = 3
```

### 3. Индекс на часто изменяемые данные
Взвешивайте пользу от индекса против стоимости его поддержки:
- Каждый INSERT/UPDATE/DELETE требует обновления индексов
- Больше индексов = медленнее запись

### 4. Размер индекса
```sql
-- Компактные индексы работают быстрее
CREATE INDEX idx_users_name ON users(last_name(10)); -- Первые 10 символов
```

### 5. Мониторинг и обслуживание
- Регулярно анализируйте использование индексов
- Удаляйте неиспользуемые индексы
- Перестраивайте фрагментированные индексы

## Примеры оптимизации запросов

### До оптимизации:
```sql
SELECT * FROM orders 
WHERE customer_id = 123 
AND order_date BETWEEN '2023-01-01' AND '2023-12-31'
ORDER BY total_amount DESC;
```

### После добавления индекса:
```sql
CREATE INDEX idx_orders_customer_date_amount 
ON orders(customer_id, order_date, total_amount DESC);

-- Теперь запрос использует covering index
SELECT customer_id, order_date, total_amount 
FROM orders 
WHERE customer_id = 123 
AND order_date BETWEEN '2023-01-01' AND '2023-12-31'
ORDER BY total_amount DESC;
```

## Заключение

Индексы — мощный инструмент оптимизации, но требующий:
1. **Понимания** структуры данных и запросов
2. **Баланса** между скоростью чтения и записи
3. **Регулярного мониторинга** и обслуживания
4. **Тестирования** на реальных данных и нагрузке

Правильное использование индексов может ускорить запросы в сотни раз, но неправильное — замедлить всю систему. Всегда тестируйте изменения на staging-окружении перед применением в production.